
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, height=device-height">
    <title>詞海拾心 </title>

  <!-- ▼▼▼ 請用這段完整的程式碼，取代你舊的 CSP meta 標籤 ▼▼▼ -->
<meta http-equiv="Content-Security-Policy" content="
    default-src 'self';
    script-src 'self' 'unsafe-inline' https://www.gstatic.com https://*.firebaseio.com;
    style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
    font-src 'self' https://fonts.gstatic.com;
    img-src 'self' https: data:;
    media-src 'self';
    connect-src 'self' https://*.firebaseio.com wss://*.firebaseio.com https://www.gstatic.com;
    object-src 'none';
    base-uri 'self';
    form-action 'none';
">


    
      <!-- ▼▼▼ 【核心修正】請將這三行 Google Fonts 連結加在這裡 ▼▼▼ -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@400;700&display=swap" rel="stylesheet">
    <style>

 /* ▼▼▼ 新增的樣式 ▼▼▼ */

/* ======================================================= */
/* ====== 【全新整合】遊戲進度條統一樣式區塊 ====== */
/* ======================================================= */

/* --- 1. 所有進度條的通用預設樣式 (預設為隱藏) --- */
.progress-container,
.opponent-progress-container,
.unlock-progress-container {
    position: absolute;
    left: 10px;
    right: 10px;
    width: auto;
    height: 12px;
    border-radius: 6px;
    overflow: hidden;
    z-index: 10;
    
    /* 預設狀態：透明且在畫面下方，準備滑入動畫 */
    opacity: 0;
    transform: translateY(100%);
    transition: opacity 0.5s ease, transform 0.5s ease;
}

/* --- 2. 各進度條的精確位置與外觀 --- */

/* 歌曲播放進度條 (最底層) */
.progress-container {
    bottom: 10px;
    background: rgba(255, 255, 255, 0.1);
}

/* 對手分數進度條 (中間層) */
.opponent-progress-container {
    bottom: 27px; /* 10px(歌曲條) + 12px(高度) + 5px(間距) */
    background: rgba(0, 0, 0, 0.4);
    border: 1px solid rgba(255, 255, 255, 0.2);
}

/* 己方分數進度條 (最上層) */
.unlock-progress-container {
    bottom: 44px; /* 27px(對手條) + 12px(高度) + 5px(間距) */
    background: rgba(0, 0, 0, 0.4);
    border: 1px solid rgba(255, 255, 255, 0.2);
    display: flex;
    align-items: center;
}

/* --- 3. 遊戲開始時的顯示邏輯 --- */

/* 當遊戲開始時，顯示己方分數條和歌曲進度條 */
.game-running .progress-container,
.game-running .unlock-progress-container {
    opacity: 1;
    transform: translateY(0);
}

/* 僅在「線上對戰模式」下，才額外顯示對手進度條 */
.game-running.online-mode .opponent-progress-container {
    opacity: 1;
    transform: translateY(0);
}





.unlock-progress-bar {
    height: 100%; /* [修訂] 高度填滿容器 */
    min-height: 12px; /* 確保即使 height=100% 時也有最小高度，避免容器塌陷 */
    width: 0%;    /* [修訂] 由 JS 控制寬度來顯示進度 */
    background: linear-gradient(90deg, #1D976C, #93F9B9); /* [修訂] 漸變方向改為 90 度 */
    transition: width 0.2s ease-out, box-shadow 0.3s ease; /* [修訂] 動畫屬性改為 width */
    box-shadow: 0 0 10px rgba(147, 249, 185, 0);
}

        /* 當進度超過門檻時的發光效果 */
        .unlock-progress-bar.glowing {
            box-shadow: 0 0 15px 5px rgba(147, 249, 185, 0.8);
        }

       .unlock-progress-marker {
            position: absolute;
            /* [刪除] left: 35%;  <-- 我們將完全由 JS 控制位置，可刪除此行 */
            top: -5px;
            bottom: -5px;
            width: 2px;
            height: auto;
            /* [刪除] 以下兩行關於顏色的定義將移至新的 class 中 */
            /* background: #FFD700; */
            /* box-shadow: 0 0 8px #FFD700; */
            z-index: 2;
        }

        /* ▼▼▼ 【新增】為不同類型的合格線設定專屬顏色 ▼▼▼ */
        .unlock-progress-marker.song-marker {
            background: #FFD700; /* 金黃色，代表解鎖歌曲 */
            box-shadow: 0 0 8px #FFD700;
        }

        .unlock-progress-marker.difficulty-marker {
            background: #F96666; /* 亮紅色，代表挑戰更高難度 */
            box-shadow: 0 0 8px #F96666;
        }
        
        body {
     
           background: #f0f4f8; /* 一個乾淨、柔和的淺灰色 */
           font-family: 'Noto Serif TC', 'cwTeXHei', 'cwTeXFangSong', 'cwTeXKai', 'cwTeXMing', 'PingFang TC', 'Microsoft JhengHei', serif;
            touch-action: manipulation; /* Prevent default touch actions like double-tap zoom */
            color: #333;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
            /* Disable text selection and double-tap zoom */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 10% 20%, rgba(255, 200, 124, 0.1) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(108, 99, 255, 0.1) 0%, transparent 20%);
            z-index: -1;
        }
        /* Background Image with 60% Opacity */
        .background-image {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('背景.png');
            background-size: cover;
            background-position: center;
            opacity: 0.6; /* 60% transparency */
            z-index: -2; /* Behind the main content */
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 10px; /* Reduced padding */
            position: relative; /* Needed for z-index */
            z-index: 1; /* Above the background image */
        }
        /* Main game area container with border */
       /* 主要遊戲區域容器 */
.main-game-container {
     border: 2px solid rgba(0, 0, 0, 0.1); /* 邊框可以調淡一些 */
     border-radius: 15px;
     padding: 15px;
     background: rgba(255, 255, 255, 0.3); /* 【修改】從黑色透明變為白色透明 */
     box-shadow: 0 0 20px rgba(0, 0, 0, 0.1); /* 陰影可以調淡 */
     margin-bottom: 20px;
}
        header {
            text-align: center;
            padding: 10px 0; /* Reduced padding */
            margin-bottom: 10px; /* Reduced margin */
        }
        h1 {
            font-size: 2.5rem; /* Adjusted for better responsiveness */
            margin-bottom: 5px;
            background: linear-gradient(45deg, #ff8a00, #e52e71);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }
        .subtitle {
            font-size: 1rem; /* Adjusted */
            opacity: 0.8;
            margin-bottom: 10px; /* Reduced margin */
        }
        .game-container {
            display: flex;
            flex-direction: column;
            gap: 10px; /* Reduced gap */
        }
     /* 1. 遊戲 UI 主容器：增加足夠的底部空間容納三個進度條 */
.game-ui {
    position: relative; 
    display: flex;
    flex-wrap: wrap; 
    justify-content: space-between;
    align-items: center; 
    gap: 8px; 
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px; 
    padding: 10px; 
    /* [核心修訂] 增加底部內邊距，為三個進度條和它們之間的間距騰出空間 */
    padding-bottom: 70px; 
    backdrop-filter: blur(10px);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2); 
}
        .stats {
    display: flex;
    /* [核心修訂] 將分數框之間的間距從 10px 增加到 20px */
    gap: 20px; 
}
        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px; /* Reduced radius */
            padding: 8px 12px; /* Reduced padding */
            min-width: 90px; /* Reduced width */
            text-align: center;
        }
        .stat-value {
            font-size: 1.5rem; /* Adjusted */
            font-weight: bold;
            color: #ffcc00;
        }
      .stat-label {
    font-size: 1rem;
    color: #333; /* 使用清晰的深灰色 */
    opacity: 1;
    font-weight: bold;
    /* 【核心修訂】改用單一、柔和的陰影來增加易讀性 */
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}
        .controls {
            display: flex;
            gap: 8px; /* Reduced gap */
            align-items: center;
        }
        /* SVG Start Button Styles */
        .svg-button {
            background: none;
            border: none;
            padding: 0;
            cursor: pointer;
            width: 80px;
            height: 40px; 
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.3s ease;
        }
        .svg-button:hover {
            transform: translateY(-2px);
        }
        .svg-button:active {
            transform: translateY(1px);
        }
        .svg-button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
            transform: none;
        }
        .start-button-svg {
            width: 100%;
            height: 100%;
        }
        /* Music Selector SVG Icon */
        .music-selector {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping */
            gap: 8px; /* Reduced gap */
            align-items: center;
        }
        .music-select-wrapper {
            position: relative;
            display: inline-block;
        }
       /* 歌曲選擇下拉選單 */
.music-select-wrapper select {
    background: rgba(0, 0, 0, 0.3);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.2);
    padding: 8px 35px 8px 12px;
    border-radius: 50px;
    font-size: 0.9rem;
    min-width: 0;
    
    /* [核心修訂] 移除 flex: 1; 並設定一個最大寬度 */
    max-width: 120px; 
    
    appearance: none;
    cursor: pointer;
}
        .music-select-wrapper select:disabled {
            color: #888;
            cursor: not-allowed;
        }
        .music-icon {
            position: absolute;
            right: 10px; /* Position icon inside the select box */
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none; /* Icon doesn't interfere with click */
            fill: white; /* Icon color */
            width: 16px;
            height: 16px;
        }

        /* Personal High Score Button */
        .personal-high-score-btn {
            background: none;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            transition: background 0.3s ease, border-color 0.3s ease;
        }
        .personal-high-score-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }
        .personal-high-score-icon {
            width: 18px;
            height: 18px;
            fill: white;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 5px; /* Reduced gap */
            font-size: 0.9rem; /* Adjusted */
        }
        input[type="range"] {
            width: 80px; /* Reduced width */
        }
        .difficulty-selector {
            display: flex;
            gap: 5px; /* Reduced gap */
            align-items: center;
            font-size: 0.9rem; /* Adjusted */
        }
        /* 難度選擇下拉選單 */
.difficulty-selector select {
    background: rgba(0, 0, 0, 0.3);
    color: white;
    border: 1px solid rgba(255, 255, 255, 0.2);
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 0.9rem;
    
    /* [核心修訂] 新增一個最大寬度 */
    max-width: 110px;
}
        .difficulty-selector select:disabled {
            color: #888;
            cursor: not-allowed;
        }
     /* 2. 音樂進度條 (最底層) */

        .progress-bar {
    height: 100%;
    /* ▼▼▼ 【核心修訂】請將 background 屬性修改如下 ▼▼▼ */
    background: linear-gradient(90deg, #ffeb3b, #ffc107); /* <-- 這是新的黃色漸變 */
    width: 0%;
    transition: width 0.1s linear;
}
        .game-area {
            display: flex;
            flex-direction: column;
            gap: 10px; /* Reduced gap */
        }
        .tracks {
    display: flex;
    justify-content: center;
    gap: 8px; /* Reduced gap */
    position: relative;
    height: 600px; /* Increased height */
    background: rgba(0, 0, 0, 0.2); /* 【修改這裡】將 0.05 增加到 0.2 或 0.25 試試看 */
    border-radius: 10px; /* Reduced radius */
    overflow: hidden;
    padding: 15px 0; /* Reduced padding */
    transition: box-shadow 0.3s ease;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.12); /* 添加一個柔和、自然的陰影 */
}


        /* Combo Glow Effects */
        .tracks.combo-blue {
            box-shadow: 0 0 20px 5px rgba(30, 144, 255, 0.7); /* Softer blue */
        }
        .tracks.combo-orange {
            box-shadow: 0 0 25px 8px rgba(255, 165, 0, 0.7); /* Softer orange */
        }
        .tracks.combo-pink {
            box-shadow: 0 0 30px 10px rgba(255, 105, 180, 0.7); /* Softer pink */
        }
        .tracks.combo-purple {
            box-shadow: 0 0 35px 12px rgba(147, 112, 219, 0.7); /* Softer purple */
        }
        .tracks.combo-rainbow {
             box-shadow: 0 0 40px 15px;
             animation: rainbowGlow 1.5s infinite;
        }
        @keyframes rainbowGlow {
            0% { box-shadow-color: rgba(255, 0, 0, 0.7); }
            16.66% { box-shadow-color: rgba(255, 255, 0, 0.7); }
            33.33% { box-shadow-color: rgba(0, 255, 0, 0.7); }
            50% { box-shadow-color: rgba(0, 255, 255, 0.7); }
            66.66% { box-shadow-color: rgba(0, 0, 255, 0.7); }
            83.33% { box-shadow-color: rgba(255, 0, 255, 0.7); }
            100% { box-shadow-color: rgba(255, 0, 0, 0.7); }
        }
        /* 每個單獨的軌道 */
.track {
    width: 80px;
    height: 100%;
    background: rgba(0, 0, 0, 0.1); 
    border-radius: 8px; /* Reduced radius */
    position: relative;
}
        .track::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, transparent 0%, rgba(255, 255, 255, 0.2) 100%);
            pointer-events: none;
        }
        .hit-line {
            position: absolute;
            bottom: 100px;
            left: 0;
            width: 100%;
            height: 4px; /* Reduced height */
            background: linear-gradient(90deg, #ff8a00, #e52e71);
            border-radius: 2px; /* Reduced radius */
            box-shadow: 0 0 10px rgba(229, 46, 113, 0.7); /* Reduced shadow */
            z-index: 10;
        }
        .note {
            position: absolute;
            width: 70px;
            height: 25px; /* Reduced height */
            background: linear-gradient(45deg, #00c9ff, #92fe9d);
            border-radius: 12px; /* Reduced radius */
            top: -50px;
            left: 5px;
            box-shadow: 0 0 10px rgba(0, 201, 255, 0.7); /* Reduced shadow */
            animation: fall linear;
            z-index: 5;
        }
        .long-note {
            position: absolute;
            width: 70px;
            background: linear-gradient(45deg, #ff416c, #ff4b2b);
            border-radius: 12px; /* Reduced radius */
            top: -50px;
            left: 5px;
            box-shadow: 0 0 10px rgba(255, 65, 108, 0.7); /* Reduced shadow */
            animation: fall linear;
            z-index: 5;
            transition: background 0.1s ease, box-shadow 0.1s ease; /* Added for smooth color change */
        }
        .long-note.held {
            background: linear-gradient(45deg, #ffdd4b, #ff8c4b); /* Yellow/Orange Gradient */
            box-shadow: 0 0 15px rgba(255, 221, 75, 0.9); /* Brighter Glow */
        }
        @keyframes fall {
            from { transform: translateY(-50px); }
            to { transform: translateY(650px); } /* Adjusted for increased track height */
        }
        .key-hint {
            position: absolute;
            bottom: 50px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 1.3rem; /* Adjusted */
            font-weight: bold;
            color: rgba(255, 255, 255, 0.7);
        }
        .judgment {
            position: absolute;
            bottom: 150px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 1.5rem; /* Adjusted */
            font-weight: bold;
            opacity: 0;
            z-index: 20;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.8); /* Reduced shadow */
            animation: judgmentFade 1s ease-out;
        }
        @keyframes judgmentFade {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-40px); } /* Reduced transform */
        }
        .perfect { color: #ffcc00; }
        .great { color: #00ccff; }
        .good { color: #00ff99; }
        .miss { color: #ff3366; }
        .combo-display {
            position: absolute;
            top: 20%; /* Moved up */
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem; /* Adjusted */
            font-weight: bold;
            /* [修訂] 移除固定的黃色，由下面的類別決定 */
            opacity: 0;
            z-index: 15;
            animation: comboFlash 0.5s ease-out;
            pointer-events: none; /* Ensure it doesn't block clicks */
        }
         /* [修訂] Combo Display Colors - 新增基礎顏色，並調整現有顏色 */
        .combo-display.combo-base { color: #e0e0e0; text-shadow: 0 0 10px rgba(224, 224, 224, 0.7); }
        .combo-display.combo-blue { color: #1e90ff; text-shadow: 0 0 15px rgba(30, 144, 255, 0.8); }
        .combo-display.combo-orange { color: #ffa500; text-shadow: 0 0 15px rgba(255, 165, 0, 0.8); }
        .combo-display.combo-pink { color: #ff69b4; text-shadow: 0 0 15px rgba(255, 105, 180, 0.8); }
        .combo-display.combo-purple { color: #9370db; text-shadow: 0 0 15px rgba(147, 112, 219, 0.8); }
        .combo-display.combo-rainbow {
            background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00, #00ffff, #0000ff, #ff00ff, #ff0000);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            animation: comboFlashRainbow 0.5s ease-out, rainbowText 2s linear infinite;
        }
        @keyframes comboFlash {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(1.3); } /* Reduced scale */
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }
        @keyframes comboFlashRainbow {
             0% { opacity: 1; transform: translate(-50%, -50%) scale(1.5); }
             100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }
        @keyframes rainbowText {
            0% { background-position: 0% 50%; }
            100% { background-position: 100% 50%; }
        }
        /* [修訂] 第二點：新增打擊感動畫 */
        .track.hit-effect {
            animation: trackFlash 0.2s ease-out;
        }
        @keyframes trackFlash {
            0% { background-color: rgba(255, 255, 255, 0.35); }
            100% { background-color: rgba(255, 255, 255, 0.15); }
        }
        .hit-line.pulse-effect {
    animation: hitLinePulse 0.2s ease-out; /* 延長到 0.2s */
}
@keyframes hitLinePulse {
    0% { transform: scaleX(1); box-shadow: 0 0 10px rgba(229, 46, 113, 0.7); }
    50% { transform: scaleX(1.1); box-shadow: 0 0 30px 8px rgba(255, 204, 0, 1); } /* 加強陰影與縮放 */
    100% { transform: scaleX(1); box-shadow: 0 0 10px rgba(229, 46, 113, 0.7); }
}
       
        /* ====== 【修訂後】粒子效果 CSS ====== */

/* --- Hit Particle (打擊線粒子) --- */
.hit-particle {
    position: absolute;
    bottom: 100px; /* 起始位置在打擊線 */
    width: var(--size, 10px);
    height: var(--size, 10px);
    border-radius: 50%;
    pointer-events: none;
    z-index: 30;
    opacity: 0; 
    will-change: transform, opacity; 
    /* ▼▼▼ 【新增】強制將粒子提升到獨立的渲染層，啟用硬體加速 ▼▼▼ */
    transform: translateZ(0); 
}

/* 當粒子被激活時，添加 .animate class 來觸發動畫 */
.hit-particle.animate {
    animation: particleBurst 0.6s ease-out forwards;
}

@keyframes particleBurst {
    0% {
        transform: translateY(0) scale(1) rotate(var(--rot, 0deg));
        opacity: 1; /* 動畫開始時變為可見 */
    }
    100% {
        transform: translateY(var(--y)) translateX(var(--x)) scale(0) rotate(var(--rot-end, 360deg));
        opacity: 0; /* 動畫結束時淡出 */
    }
}


/* --- Note Particle (音符爆炸粒子) --- */
.note-particle {
    position: absolute;
    width: var(--size, 8px);
    height: var(--size, 8px);
    border-radius: 30%;
    pointer-events: none;
    z-index: 30;
    opacity: 0; 
    will-change: transform, opacity;
    /* ▼▼▼ 【新增】強制將粒子提升到獨立的渲染層，啟用硬體加速 ▼▼▼ */
    transform: translateZ(0);
}

/* 當粒子被激活時，添加 .animate class 來觸發動畫 */
.note-particle.animate {
     animation: noteDecompose 0.5s ease-out forwards;
}

@keyframes noteDecompose {
    0% {
        transform: translate(0, 0) scale(1) rotate(0deg);
        opacity: 1;
    }
    100% {
        transform: translate(var(--x), var(--y)) scale(0.2) rotate(var(--rot-end, 360deg));
        opacity: 0;
    }
}

        
        /* Touch Controls - Positioned in flow, not fixed */
        .touch-controls {
            display: none; /* [修訂] 預設隱藏，由 JS 控制顯示 */
            justify-content: center;
            gap: 15px;
            margin-top: 15px; /* Added margin to separate from tracks */
            padding: 10px 0;
            width: 100%;
            z-index: 100;
        }
        /* [修訂] 第三點：更有質感的半透明按鍵設計 */
        .touch-key {
            width: 70px;
            height: 70px;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            cursor: pointer;
            user-select: none;
            transition: transform 0.1s ease, box-shadow 0.1s ease, background 0.1s ease;
            /* Glassmorphism / Translucent Texture */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }
   /* ====== Final "Starlight Silver" Key Styles (Ultimate Palette) ====== */

/* --- 所有按鍵的統一基礎樣式 --- */
.touch-key {
    border: 2px solid;
    /* 過渡效果中加入 filter，讓提亮動畫更平滑 */
    transition: box-shadow 0.15s ease, transform 0.1s ease, filter 0.1s ease, background 0.15s ease;
}

/* A 鍵 - 宇宙青石 (Cosmic Teal) */
.touch-key[data-key="65"] {
    background: linear-gradient(135deg, rgba(0, 220, 220, 0.7), rgba(0, 100, 120, 0.8));
    border-color: rgba(80, 230, 230, 0.8);
    box-shadow: 0 0 15px rgba(0, 220, 220, 0.6);
}

/* S 鍵 - 藍寶石 (Sapphire) */
.touch-key[data-key="83"] {
    background: linear-gradient(135deg, rgba(0, 201, 255, 0.7), rgba(0, 123, 255, 0.75));
    border-color: rgba(100, 220, 255, 0.8);
    box-shadow: 0 0 15px rgba(0, 201, 255, 0.6);
}

/* D 鍵 - 冰晶石 (Ice Crystal) */
.touch-key[data-key="68"] {
    background: linear-gradient(135deg, rgba(210, 240, 255, 0.7), rgba(150, 210, 255, 0.8));
    border-color: rgba(220, 245, 255, 0.85);
    box-shadow: 0 0 18px rgba(180, 225, 255, 0.7);
}

/* F 鍵 - 星光銀 (Starlight Silver) - 明亮、高雅的中性色 */
.touch-key[data-key="70"] {
    background: linear-gradient(135deg, rgba(225, 230, 235, 0.7), rgba(170, 180, 190, 0.8));
    border-color: rgba(230, 235, 240, 0.8);
    box-shadow: 0 0 15px rgba(210, 215, 220, 0.7);
}


/* --- 按下時激活的效果 --- */
.touch-key:active, .touch-key.pressed {
    /* 使用 filter 大幅提亮和增加飽和度，產生晶石被激活的感覺 */
    filter: brightness(1.3) saturate(1.2);
    /* 同時光暈劇烈迸發 */
    box-shadow: 0 0 28px 5px;
}

/* 為每個按鍵的迸發光暈指定顏色 */
.touch-key[data-key="65"]:active, .touch-key[data-key="65"].pressed { box-shadow: 0 0 28px 5px rgba(0, 220, 220, 0.8); }
.touch-key[data-key="83"]:active, .touch-key[data-key="83"].pressed { box-shadow: 0 0 28px 5px rgba(0, 201, 255, 0.8); }
.touch-key[data-key="68"]:active, .touch-key[data-key="68"].pressed { box-shadow: 0 0 28px 5px rgba(180, 225, 255, 0.85); }
.touch-key[data-key="70"]:active, .touch-key[data-key="70"].pressed { box-shadow: 0 0 28px 5px rgba(225, 230, 235, 0.9); }
        /* [修訂] 第二點：移除原先的 Media Query，改由 JS 控制
        @media (hover: none) and (pointer: coarse) {
            .touch-controls {
                display: flex;
            }
            .key-hint {
                display: none;
            }
        }
        */
      
/* A prominent, inviting call-to-action */
.restart-btn {
    background: #fff;  /* 改成白底 */
    color: #333;
    border: none;
    padding: 14px 35px;
    border-radius: 50px;
    font-size: 1.2rem;
    font-weight: bold;
    cursor: pointer;
    margin-top: 10px;  /* 減少 margin，讓它靠近上方 */
    transition: transform 0.2s ease;
}

.restart-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 20px rgba(0, 201, 255, 0.3);
}

/* Responsive adjustments for Game Over Modal */
@media (max-width: 480px) {
   
    .game-over-title {
        font-size: 2.2rem;
    }
    .game-over-stats {
        flex-direction: column; /* Stack stats vertically */
    }
    .stat-number {
        font-size: 2rem;
    }
    .restart-btn {
        padding: 12px 30px;
        font-size: 1.1rem;
    }
}

        
        /* Settings Modal Styles */
        .settings-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        .settings-modal.active {
            opacity: 1;
            pointer-events: all;
        }
        .settings-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 0 40px rgba(255, 138, 0, 0.5);
            max-width: 500px;
            width: 90%;
            position: relative;
        }
        .close-settings {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
        }
        .settings-title {
            font-size: 2rem;
            margin-bottom: 20px;
            text-align: center;
            color: #ffcc00;
        }
        .setting-group {
            margin-bottom: 20px;
        }
        .setting-label {
            display: block;
            margin-bottom: 8px;
            font-size: 1.1rem;
        }
        .setting-control {
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 1rem;
        }
       /* --- 1. 滑桿軌道的基礎樣式 --- */
.setting-slider {
    -webkit-appearance: none; /* 移除 Chrome/Safari 的預設樣式 */
    appearance: none;
    width: 100%;
    height: 8px; /* 軌道高度 */
    background: #4a5568; /* 軌道底色 (未填充部分) */
    border-radius: 5px;
    outline: none;
    transition: opacity .2s;
    cursor: pointer;
}

/* --- 2. 滑桿拖曳鈕 (Thumb) 的樣式 --- */
.setting-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px; /* 拖曳鈕寬度 */
    height: 20px; /* 拖曳鈕高度 */
    background: #e2e8f0; /* 拖曳鈕顏色 */
    border-radius: 50%;
    border: 2px solid #718096;
    box-shadow: 0 0 5px rgba(0,0,0,0.2);
}

.setting-slider::-moz-range-thumb {
    width: 20px;
    height: 20px;
    background: #e2e8f0;
    border-radius: 50%;
    border: 2px solid #718096;
    box-shadow: 0 0 5px rgba(0,0,0,0.2);
}

/* Copyright Disclaimer Modal Styles */
.copyright-disclaimer-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.85);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1005;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.4s ease;
}
.copyright-disclaimer-modal.active {
    opacity: 1;
    pointer-events: all;
}
.disclaimer-content {
    background: linear-gradient(135deg, #2c1810, #1a1a2e);
    padding: 40px;
    border-radius: 20px;
    box-shadow: 0 0 50px rgba(255, 215, 0, 0.3);
    max-width: 500px;
    width: 90%;
    position: relative;
    text-align: left;
    border: 1px solid rgba(255, 215, 0, 0.2);
    animation: modalPop 0.5s ease-out;
}
.close-disclaimer {
    position: absolute;
    top: 15px;
    right: 15px;
    background: none;
    border: none;
    color: #FFD700;
    font-size: 1.8rem;
    cursor: pointer;
    transition: color 0.3s ease, transform 0.2s ease;
}
.close-disclaimer:hover {
    color: #fff;
    transform: rotate(90deg);
}
.disclaimer-title {
    font-size: 2rem;
    margin-bottom: 30px;
    text-align: center;
    color: #FFD700;
    text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
}
.disclaimer-section {
    margin-bottom: 25px;
    padding: 20px;
    background: rgba(0, 0, 0, 0.3);
    border-radius: 15px;
    border-left: 4px solid #FFD700;
}
.disclaimer-section h3 {
    color: #FFD700;
    margin-bottom: 10px;
    font-size: 1.3rem;
    display: flex;
    align-items: center;
    gap: 10px;
}
.disclaimer-section p {
    color: #e0e0e0;
    line-height: 1.6;
    font-size: 1.1rem;
}




        /* Personal High Score Modal */
        .personal-high-score-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1002;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        .personal-high-score-modal.active {
            opacity: 1;
            pointer-events: all;
        }
        .personal-high-score-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 0 40px rgba(255, 138, 0, 0.5);
            max-width: 500px;
            width: 90%;
            position: relative;
            text-align: center;
        }
        .close-personal-high-score {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
        }
        .personal-high-score-title {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: #ffcc00;
        }
        .personal-high-score-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .personal-high-score-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .personal-high-score-label {
            font-weight: bold;
        }
        .personal-high-score-value {
            font-size: 1.2rem;
            color: #00c9ff;
        }

        /* Settings Button SVG */
        .settings-btn {
            background: none;
            border: none;
            padding: 0;
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .settings-icon {
            width: 100%;
            height: 100%;
            fill: white;
        }

        /* Music Player Button */
        .music-player-btn {
            background: none;
            border: none;
            padding: 0;
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: 10px; /* Add some space */
        }
        .music-player-icon {
            width: 100%;
            height: 100%;
            fill: white;
        }

        /* Music Player Modal */
       .music-player-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    /* [修訂] 改用更明亮、有活力的漸變色 */
      background-color: #0b192f; 
    background-image: 
        /* [保留] 原有的藍綠色光暈 */
        radial-gradient(at 20% 80%, hsla(190, 80%, 50%, 0.3), transparent 50%),
        radial-gradient(at 80% 10%, hsla(170, 70%, 60%, 0.25), transparent 50%),
        /* [增強] 大幅提升右上角金色光暈的亮度和範圍 */
        radial-gradient(at 90% 20%, hsla(40, 90%, 70%, 0.35), transparent 60%),
        /* [修訂] 將橙色替換為更優雅、空靈的柔和品紅 (Rose Gold / Magenta) */
        radial-gradient(at 10% 40%, hsla(45, 80%, 75%, 0.25), transparent 70%);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 1003;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.5s ease;
}
        .music-player-modal.active {
            opacity: 1;
            pointer-events: all;
        }
       .music-player-content {
    width: 90%;
    max-width: 800px;
    text-align: center;
    padding: 30px;
    background: rgba(255, 255, 255, 0.25);
    backdrop-filter: blur(30px);
    -webkit-backdrop-filter: blur(30px);
    border-radius: 20px;
    border: 1px solid rgba(230, 180, 80, 0.5);
    box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.2), 0 0 20px rgba(230, 180, 80, 0.2);
    /* [修訂 1] 移除 max-height，改用 height: 100% */
    height: 100%;
    /* [修訂 2] 新增 box-sizing，確保 padding 不會導致容器溢出 */
    box-sizing: border-box; 
    overflow-y: auto;
    display: flex;
    flex-direction: column;
}
        .music-player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }
        /* Removed .music-player-title style */
        .close-music-player {
            background: none;
            border: none;
            color: white;
            font-size: 2rem;
            cursor: pointer;
            padding: 5px 10px;
            border-radius: 5px;
            transition: background 0.3s ease;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .close-music-player:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        .close-music-player-icon {
             width: 100%;
             height: 100%;
             fill: white;
        }
        .now-playing {
    font-size: 1.5rem;
    margin-bottom: 20px;
    /* [修訂] 改為深灰色，增加易讀性 */
    color: #2c3e50; 
    font-weight: 600;
}
.lyric-line {
    margin: 10px 0;
    /* [修訂] 基礎文字顏色改為較深的灰色 */
    color: #a3a3a3;
    opacity: 0.7;
    transition: all 0.3s ease;
}
.lyric-line.active {
    opacity: 1;
    font-weight: bold;
    /* [修訂] 高亮顏色改為與新主題匹配的珊瑚紅 */
    color: #17a2b8;
    transform: scale(1.05);
    /* [修訂] 陰影改為更柔和的樣式 */
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.15);
}
        .no-lyrics {
            color: #aaa;
            font-style: italic;
        }
        .player-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-bottom: 20px;
        }
        .player-btn {
   background: rgba(255, 255, 255, 0.2); /* 稍微調亮背景 */
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: #2c3e50; 
    font-size: 2rem;
    cursor: pointer;
    width: 55px; /* [新增] 固定大小 */
    height: 55px; /* [新增] 固定大小 */
    display: flex; /* [新增] 用於居中圖示 */
    align-items: center; /* [新增] */
    justify-content: center; /* [新增] */
    padding: 0; /* [修訂] 移除內邊距 */
    border-radius: 50%;
    transition: background 0.3s ease, transform 0.2s ease;
    text-shadow: 0 1px 3px rgba(0,0,0,0.3); /* [新增] 圖示陰影 */
}
.player-btn:hover {
    background: rgba(255, 255, 255, 0.4); /* [修訂] 懸停時更亮 */
}

/* [新增] 當播放模式按鈕處於 active (例如隨機播放) 狀態時的樣式 */
.player-btn.active {
    background: rgba(23, 162, 184, 0.4); /* 使用主題中的青色作為高亮背景 */
    color: #fff;
    box-shadow: 0 0 10px rgba(23, 162, 184, 0.5); /* 添加柔和的光暈效果 */
}
        

/* 進度條軌道 */
.progress-slider {
    width: 100%;
    height: 8px;
    -webkit-appearance: none;
    /* [修訂] 軌道使用更柔和的顏色 */
   background: rgba(140, 115, 70, 0.3); 
    border-radius: 4px;
    outline: none;
}

/* 進度條滑塊 */
.progress-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    /* [修訂] 滑塊改為高雅的米白色 */
    background: #17a2b8; 
    border: none; /* [修訂] 移除邊框 */
    cursor: pointer;
    border: 1px solid rgba(0,0,0,0.1); /* [新增] 增加細微邊框 */
}
        .time-display {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 20px;
            font-size: 0.9rem;
            color: #ccc;
        }
        .volume-control-player {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
            justify-content: center;
        }
        .volume-control-player input[type="range"] {
            width: 150px;
        }
       .playlist {
    list-style: none;
    padding: 0;
    margin-top: 30px;
    max-height: 200px; /* 預設值，適用於小屏幕 */
    overflow-y: auto;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 10px;
    padding: 10px;
}

/* 在大屏幕上給播放列表更多空間 */
@media (min-width: 769px) {
    .playlist {
        max-height: 400px; /* 在電腦上顯示更多歌曲 */
    }
}
        .playlist-item {
    padding: 12px 15px; /* [修訂] 增加內邊距 */
    border-radius: 8px; /* [修訂] 圓角更柔和 */
    cursor: pointer;
    transition: background 0.3s ease;
    text-align: left;
    color: #e1d4dd; /* [新增] 設置基礎文字顏色 */
    border-bottom: 1px solid rgba(255, 255, 255, 0.05); /* [新增] 微妙的分隔線 */
}
.playlist-item:last-child {
    border-bottom: none; /* [新增] 最後一項不需要分隔線 */
}
.playlist-item:hover {
    background: rgba(255, 255, 255, 0.1);
}
.playlist-item.active {
    /* [修訂] 使用帶有半透明效果的紅黃橙線性漸變 */
    background: linear-gradient(90deg, 
        rgba(255, 107, 107, 0.8), /* 半透明的紅色 */
        rgba(255, 159, 67, 0.8), /* 半透明的橙色 */
        rgba(255, 221, 87, 0.8)  /* 半透明的黃色 */
    );
    
    /* 為了在半透明背景下依然清晰，保留白色文字和陰影 */
    color: white;
    font-weight: bold;
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
    
    /* [優化] 添加一個細緻的邊框，讓選中項在背景複雜時更突出 */
    border: 1px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 0 15px rgba(255, 159, 67, 0.3); /* 添加柔和的橙色光暈 */
}
        .playlist-item.locked {
             color: #888;
             cursor: not-allowed;
             opacity: 0.7;
        }
.playlist-item.disabled {
    opacity: 0.5;
    color: #888;
    text-decoration: line-through;
}

.playlist-item.disabled {
    opacity: 0.5;
    color: #888;
    text-decoration: line-through;
}

        /* Unlock Modal */
        .unlock-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1004;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        .unlock-modal.active {
            opacity: 1;
            pointer-events: all;
        }
        .unlock-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 0 40px rgba(255, 138, 0, 0.5);
            max-width: 400px;
            width: 90%;
            text-align: center;
            position: relative;
        }
        .unlock-icon {
            font-size: 4rem;
            color: #ffcc00;
            margin-bottom: 20px;
        }
        .unlock-message {
            font-size: 1.2rem;
            margin-bottom: 20px;
        }
        .unlock-requirement {
            font-size: 1rem;
            color: #00c9ff;
            margin-bottom: 30px;
        }
        .close-unlock {
            background: linear-gradient(45deg, #ff8a00, #e52e71);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        .close-unlock:hover {
            transform: translateY(-2px);
        }


        /* Responsive Design Adjustments */
       /* Responsive Design Adjustments for Tablets and Smaller Screens (Up to 1024px) */
@media (max-width: 1024px) {
    /* --- 基礎手機適配 (繼承自原來的 max-width: 768px) --- */
    h1 { font-size: 2rem; }
    .tracks { height: 500px; }
    .track { width: 60px; }
    .note, .long-note { width: 50px; }
    .hit-line { bottom: 90px; }
    .music-select-wrapper select { max-width: 150px; }
    .difficulty-selector select { max-width: 100px; }
    .music-player-content { padding: 15px; }
    .lyrics-container { height: 200px; font-size: 1rem; }
    .player-btn { font-size: 1.5rem; }
    .play-pause-btn { font-size: 2rem; }
    .playlist { max-height: 150px; }

    /* --- 新增/修改：針對平板尺寸 (769px - 1024px) 的優化 --- */
    @media (min-width: 769px) {
        /* 遊戲主頁優化 */
        h1 {
            font-size: 2.2rem; /* 稍微比手機大一點 */
        }
        .subtitle {
            font-size: 1.1rem;
        }
        .game-ui {
            flex-wrap: nowrap; /* 防止在中等屏幕上折行 */
            justify-content: space-between;
            gap: 15px; /* 增加一點間距 */
        }
        .stats {
            flex-wrap: nowrap;
            gap: 10px; /* 減少統計間的間距 */
        }
        .stat-box {
            padding: 8px 12px; /* 增加內邊距 */
            min-width: 90px; /* 增加最小寬度 */
        }
        .stat-value {
            font-size: 1.6rem; /* 稍微增大分數顯示 */
        }
        .controls {
            gap: 15px; /* 增加控制按鈕間距 */
        }
        .start-button-svg {
            width: 70px; /* 增大開始按鈕 */
            height: 35px;
        }
        .settings-btn {
            width: 45px; /* 增大設定按鈕 */
            height: 45px;
            font-size: 1.8rem;
        }

        /* 軌道和音符尺寸調整 */
        .tracks {
            height: 550px; /* 比手機高，比桌面低 */
            max-width: 600px; /* 限制最大寬度 */
            margin: 0 auto; /* 居中 */
        }
        .track {
            width: 70px; /* 增大軌道寬度 */
            margin: 0 5px; /* 軌道間距 */
        }
        .note, .long-note {
            width: 60px; /* 增大音符寬度 */
            height: 30px; /* 增大音符高度 */
        }
        .hit-line {
            bottom: 100px; /* 調整擊打線位置 */
            height: 5px;
        }
        .judgment {
            font-size: 2.2rem; /* 增大判定文字 */
            bottom: 170px; /* 調整判定文字位置 */
        }
        .combo-display {
            font-size: 3.2rem; /* 增大連擊數字 */
            top: 25%; /* 調整連擊數字位置 */
        }

        /* 下拉選單調整 */
        .music-select-wrapper select,
        .difficulty-selector select {
            font-size: 1rem; /* 增大字體 */
            padding: 8px 12px; /* 增大內邊距 */
            max-width: none; /* 移除最大寬度限制 */
        }
        .music-select-wrapper::after {
            right: 12px; /* 調整箭頭位置 */
        }

        /* CD 封面 */
.cd-cover-wrapper {
    max-width: 250px; /* 桌面版大小 */
}
/* 響應式設計：在小屏幕上縮小封面 */
/* 平板尺寸優化 */
@media (min-width: 769px) and (max-width: 1024px) {
     .cd-cover-wrapper {
         max-width: 230px; /* 平板版大小，介於手機和桌面之間 */
         margin-bottom: 20px; /* 可根據需要調整 */
     }
}
@media (max-width: 768px) { /* 手機版 */
    .cd-cover-wrapper {
        max-width: 220px;
    }
}
@media (max-width: 480px) { /* 小手機版 */
    .cd-cover-wrapper {
        max-width: 180px;
        margin-bottom: 15px;
    }
}

        /* 音樂播放器頁面優化 */
.music-player-content {
    width: 92%;
    max-width: 700px;
    padding: 25px 30px;
    border-radius: 20px;
    display: flex;
    flex-direction: column;
    /* 修改: 移除 max-height 和 overflow-y，讓內部元素控制滾動 */
    /* max-height: 90vh; */
    /* overflow-y: auto; */
    /* 新增: 確保容器本身不會溢出視口，但允許內部滾動 */
    max-height: 90vh;
    overflow: hidden; /* 防止容器本身溢出 */
}

.lyrics-container {
    /* 保留原有樣式 */
    font-size: 1.3rem;
    margin-bottom: 20px;
    padding: 10px;
    /* 修改: 移除固定 height，依賴 flex 分配空間 */
    /* height: 250px; */
    /* 修改: flex 屬性調整，允許增長和收縮，但基礎大小為 0 */
    flex: 1 1 0; /* grow, shrink, basis */
    min-height: 120px; /* 保持最小高度 */
    overflow-y: auto; /* 內部滾動 */
    /* 手機版樣式保留 */
    font-size: 1.2rem;
    margin-bottom: 15px;
}

.playlist {
    list-style: none;
    padding: 0;
    margin-top: 30px; /* 可根據需要調整 */
    /* 修改: 移除固定 max-height，改為 flex 控制 */
    /* max-height: 200px; */
    /* max-height: 150px; */
    overflow-y: auto;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 10px;
    padding: 10px;
    /* 修改: flex 屬性調整，允許增長和收縮，但基礎大小為 0 */
    flex: 1 1 0; /* grow, shrink, basis */
    /* 新增: 設置一個最小高度，確保至少能顯示一行 */
    min-height: 80px;
}

/* - 新增/修改：針對平板尺寸 (769px - 1024px) 的優化 - */
@media (min-width: 769px) and (max-width: 1024px) {
    .music-player-content {
        /* 在平板上可以稍微增加最大寬度和內邊距 */
        max-width: 800px;
        padding: 30px 40px;
    }
    .lyrics-container {
        /* 平板上可以增加歌詞區的高度偏好 */
        font-size: 1.4rem; /* 稍微增大字體 */
        min-height: 150px; /* 增加最小高度 */
    }
    .playlist {
        /* [關鍵修訂] 顯著增加播放清單在平板上的最大高度 */
        /* flex: 1 1 0; */ /* 可以保留 flex，但 max-height 更直接 */
        /* 移除 flex 或調整 basis，或者直接設置一個適合平板的高度 */
        flex: 0 1 auto; /* 不主動增長，可以收縮，根據內容 */
        max-height: 300px; /* 增大以顯示更多項目 */
        min-height: 150px; /* 增加最小高度 */
    }
    /* 確保內部滾動條在需要時出現 */
    .lyrics-container, .playlist {
        overflow-y: auto;
    }
}

/* 大屏幕優化保持不變 */
@media (min-width: 1025px) {
    .playlist {
        max-height: 400px;
    }
}
        .playlist-item {
            padding: 14px 18px; /* 增加內邊距 */
            border-radius: 10px; /* 增大圓角 */
        }

        /* --- 模態框 (Modal) 優化 --- */
        .game-over-content,
        .settings-content,
        .personal-high-score-content,
        .unlock-content,
        .disclaimer-content {
            width: 90%; /* 稍微增大寬度 */
            max-width: 500px; /* 設置最大寬度 */
            padding: 35px; /* 增加內邊距 */
            border-radius: 20px; /* 增大圓角 */
        }
        .game-over-title,
        .settings-title,
        .personal-high-score-title,
        .unlock-message,
        .disclaimer-title {
            font-size: 2rem; /* 增大標題 */
        }
        .game-over-stat {
            padding: 18px; /* 增加統計項內邊距 */
            min-width: 110px; /* 增加最小寬度 */
            margin: 10px; /* 調整外邊距 */
        }
        .stat-number {
            font-size: 2.2rem; /* 增大統計數字 */
        }
        .stat-label {
            font-size: 1.1rem; /* 增大統計標籤 */
        }
        .restart-btn,
        .close-settings,
        .close-personal-high-score,
        .close-unlock,
        .close-disclaimer {
            padding: 12px 25px; /* 增加按鈕內邊距 */
            font-size: 1.2rem; /* 增大按鈕文字 */
        }
        .setting-item {
            margin-bottom: 20px; /* 增加設定項間距 */
        }
        .setting-label {
            font-size: 1.1rem; /* 增大設定標籤 */
            margin-bottom: 8px; /* 增加下方間距 */
        }
        .setting-slider {
            width: 100%; /* 保持 100% 寬度 */
        }
        .disclaimer-section h3 {
            font-size: 1.4rem; /* 增大章節標題 */
        }
        .disclaimer-section p {
            font-size: 1.2rem; /* 增大段落文字 */
        }
    }
}

        
        @media (max-width: 480px) {
            h1 { font-size: 1.7rem; }
            .game-ui {
                justify-content: space-around;
                gap: 5px;
                flex-wrap: wrap;
            }
            .stats, .controls {
    flex-shrink: 1; 
    flex-wrap: wrap;
    justify-content: center;
    /* [核心修訂] 為分數框和控制按鈕內部元素之間新增 15px 的間距 */
    gap: 15px;
}
           .music-select-wrapper select {
    padding: 6px 30px 6px 10px;
    font-size: 0.8rem;
    max-width: 100px; /* [修訂] 減少寬度以容納按鈕 */
}
            .stat-box {
                padding: 6px 10px;
                min-width: 80px;
            }
            .stat-value {
                font-size: 1.3rem;
            }
            .tracks { height: 400px; }
            .track { width: 50px; }
            .note, .long-note { width: 40px; }
            .hit-line { bottom: 80px; }
            .difficulty-selector select {
    max-width: 70px; /* [修訂] 同樣減少寬度 */
    font-size: 0.8rem;
    padding: 4px 6px;
}
            .music-player-header {
                flex-direction: column;
                gap: 10px;
            }
            /* Removed .music-player-title style for small screens */
            .now-playing {
                font-size: 1.2rem;
            }
            .player-controls {
                gap: 10px;
            }
            .player-btn {
                font-size: 1.2rem;
                padding: 8px;
            }
            .play-pause-btn {
                font-size: 1.8rem;
            }
            .volume-control-player {
                flex-direction: column;
                gap: 5px;
            }
            .volume-control-player input[type="range"] {
                width: 100%;
            }
            .time-display {
                font-size: 0.8rem;
            }
            flex-shrink: 1; /* 允許在空間不足時被壓縮 */
    min-height: 100px; /* 設置一個最小高度 */
            .unlock-content {
                padding: 20px;
            }
            .unlock-icon {
                font-size: 3rem;
            }
            .unlock-message {
                font-size: 1rem;
            }
            .unlock-requirement {
                font-size: 0.9rem;
            }
.music-player-content {
    display: flex;
    flex-direction: column;
    /* [修訂] 將固定的 height 改為 max-height，讓容器有上下邊距 */
    max-height: 90vh; 
    overflow-y: auto;
    padding: 10px 15px; 
}


    .player-controls {
        gap: 15px; /* [修訂] 稍微拉開一點間距，避免誤觸 */
    }

    .player-btn {
        /* [修訂] 固定按鈕大小，讓佈局更穩定 */
        width: 45px;
        height: 45px;
        font-size: 1.2rem;
        padding: 0; /* 移除內邊距，因為已用 flex 居中 */
    }

    .play-pause-btn {
        width: 60px; /* [修訂] 讓播放鍵稍大，更突出 */
        height: 60px;
        font-size: 1.8rem;
    }

   .lyrics-container {
    flex: 1;
    min-height: 120px;
    overflow-y: auto;
    /* [修訂] 加大手機版面的歌詞字體，提升可讀性 */
    font-size: 1.2rem; 
    margin-bottom: 15px; 
}

.playlist {
    flex-shrink: 0;
    /* [修訂] 顯著增加播放清單的最大高度，使其在手機版面更易於滾動和查看 */
    max-height: 150px; 
}
        }

/* ====== 【NEW DESIGN】Notification Modal - "Heads-Up Display" Theme ====== */
.notification-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(25, 40, 60, 0.7);
    backdrop-filter: blur(5px);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2000;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.4s ease;
}

.notification-modal.active {
    opacity: 1;
    pointer-events: all;
}

/* The main container with 90% width */
.notification-content {
    background: #f0f4f8; /* A very light, clean, cool gray */
    color: #334155; /* Dark slate gray for high readability */
    width: 90%;
    max-width: 400px; /* Max width for larger screens */
    padding: 25px 30px;
    border-radius: 16px;
    text-align: center;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15); /* Soft, modern shadow */
    position: relative;
    border-left: 5px solid #64748b; /* Default border color */
    transform: scale(0.8);
    opacity: 0;
    transition: transform 0.4s cubic-bezier(0.18, 0.89, 0.32, 1.28), opacity 0.4s ease;
    box-sizing: border-box;
}

.notification-modal.active .notification-content {
    transform: scale(1);
    opacity: 1;
}

.close-notification {
    position: absolute;
    top: 10px;
    right: 15px;
    background: none;
    border: none;
    color: #94a3b8; /* Lighter gray for the 'x' */
    font-size: 2rem;
    cursor: pointer;
    transition: color 0.3s ease;
}

.close-notification:hover {
    color: #334155;
}

.notification-icon {
    font-size: 3.5rem;
    margin-bottom: 15px;
    animation: icon-pop 0.5s ease-out 0.3s backwards;
}

@keyframes icon-pop {
    0% { transform: scale(0); }
    80% { transform: scale(1.2); }
    100% { transform: scale(1); }
}

.notification-title {
    font-size: 1.6rem;
    margin-bottom: 8px;
    font-weight: 700;
}

.notification-message {
    font-size: 1rem;
    color: #64748b; /* Softer gray for the message body */
    line-height: 1.6;
}

.notification-message strong {
    font-weight: 700;
    color: #334155; /* Strong text matches the main text color */
}

/* --- Success Style --- */
.notification-content.success {
    border-left-color: #10b981; /* Bright green accent */
}
.notification-content.success .notification-icon {
    color: #10b981;
}
.notification-content.success .notification-title {
    color: #059669; /* Darker green for title */
}

/* --- Info/Failure Style --- */
.notification-content.info {
    border-left-color: #3b82f6; /* Bright blue accent */
}
.notification-content.info .notification-icon {
    color: #3b82f6;
}
.notification-content.info .notification-title {
    color: #2563eb; /* Darker blue for title */
}

/* Responsive adjustments for Notification Modal */
@media (max-width: 480px) {
    .notification-content {
        padding: 20px 25px;
    }
    .notification-title {
        font-size: 1.4rem;
    }
    .notification-message {
        font-size: 0.95rem;
    }
    .notification-icon {
        font-size: 3rem;
    }
}


/* ====== CD Cover Styles ====== */
.cd-cover-container {
    width: 100%;
    display: flex;
    justify-content: center;
    margin-bottom: 20px; /* 為 "正在播放" 文字留出空間 */
    padding: 0 10px; /* 兩側留白，避免貼邊 */
}

.cd-cover-wrapper {
    position: relative;
    width: 100%;
    max-width: 300px;
    aspect-ratio: 1 / 1;
    border-radius: 50%;  /* 改成 50% 變成圓形 */
    overflow: hidden;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    background: rgba(255, 255, 255, 0.1);
    display: flex;
    align-items: center;
    justify-content: center;
}

.cd-cover-img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: transform 0.5s ease;
    border-radius: 50%;  /* 新增：確保圖片本身圓形，防止溢出 */
    transform-origin: center;  /* 新增：確保旋轉以中心為軸 */
}

/* CD 覆蓋層效果 - 模擬 CD 的反光 */
.cd-cover-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0) 0%, 
        rgba(255, 255, 255, 0.1) 50%, 
        rgba(255, 255, 255, 0) 100%);
    pointer-events: none; /* 確保不阻擋點擊 */
}

/* 播放時的旋轉動畫 */
.cd-cover-img.playing {
    animation: cdSpin 15s linear infinite;
}

@keyframes cdSpin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

/* 響應式設計：在小屏幕上縮小封面 */
@media (max-width: 768px) {
    .cd-cover-wrapper {
        max-width: 220px; /* 中等屏幕 */
    }
}

@media (max-width: 480px) {
    .cd-cover-wrapper {
        max-width: 180px; /* 小屏幕 */
        margin-bottom: 15px; /* 縮小間距 */
    }
    .now-playing {
        font-size: 1.1rem; /* 配合縮小的封面，稍微減小字體 */
    }
}

/* 1. 遊戲 UI 主容器：確保有足夠的底部空間 */
.game-ui {
    position: relative; 
    display: flex;
    flex-wrap: wrap; 
    justify-content: space-between;
    align-items: center; 
    gap: 8px; 
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px; 
    padding: 10px; 
    /* [核心修訂] 重新計算 padding-bottom 以容納三個進度條和間隙 */
    padding-bottom: 75px; 
    backdrop-filter: blur(10px);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2); 
}







/* [新增] 對手進度條本身的樣式 */
.opponent-progress-bar {
    height: 100%;
    width: 0%; /* 由 JS 控制寬度 */
    /* [外觀] 使用與玩家不同的漸變色 (例如：激情的紅橙色) */
    background: linear-gradient(90deg, #e52e71, #ff8a00); 
    transition: width 0.2s ease-out; /* 動畫效果 */
    border-radius: 6px;
}

        
/* [新增] 遊戲中歌詞顯示容器 */


/* 遊戲運行中隱藏選擇器，避免重疊 */
.game-running .music-selector,
.game-running .difficulty-selector {
    display: none;       /* [修訂] 遊戲中隱藏選擇器，只顯示統計和進度 */
}

/* 響應式調整：小螢幕減少間距 */
@media (max-width: 768px) {
    .game-ui {
    /* [核心修訂] 增加手機版的底部內邊距，確保能容納所有進度條 */
    padding-bottom: 75px; 
}
    .game-lyrics-container {
        top: 5%;         /* [修訂] 小螢幕上移，避免擋軌道 */
        font-size: 1rem; /* [修訂] 縮小字體 */
    }
}        




        .track.flash-effect {
    animation: trackFlashStrong 0.3s ease-out; /* 新增強版閃光 */
}
.track.flash-perfect {
    animation: trackFlashPerfect 0.3s ease-out;
}
@keyframes trackFlashPerfect {
    0% { background-color: rgba(255, 204, 0, 0.5); } /* PERFECT 黃色閃爍 */
    100% { background-color: rgba(255, 255, 255, 0.15); }
}

.track.flash-great {
    animation: trackFlashGreat 0.3s ease-out;
}
@keyframes trackFlashGreat {
    0% { background-color: rgba(0, 204, 255, 0.5); } /* GREAT 藍色閃爍 */
    100% { background-color: rgba(255, 255, 255, 0.15); }
}

.track.flash-good {
    animation: trackFlashGood 0.3s ease-out;
}
@keyframes trackFlashGood {
    0% { background-color: rgba(0, 255, 153, 0.5); } /* GOOD 綠色閃爍 */
    100% { background-color: rgba(255, 255, 255, 0.15); }
}

        .hit-particle {
    width: 10px; /* 從 8px 增加到 10px */
    height: 10px;
    /* ... 其他樣式不變 */
}

        .hit-particle {
    position: absolute;
    bottom: 100px; /* Start at hit line */
    width: var(--size, 10px); /* 隨機尺寸，由 JS 設定 */
    height: var(--size, 10px);
    border-radius: 50%;
    pointer-events: none;
    z-index: 30;
    opacity: 1;
    animation: particleBurst 0.6s ease-out forwards; /* 延長到 0.6s，加強爆破 */
    transform: rotate(var(--rot, 0deg)); /* 新增：隨機旋轉 */
}

@keyframes particleBurst {
    0% {
        transform: translateY(0) scale(1) rotate(0deg);
        opacity: 1;
    }
    100% {
        transform: translateY(var(--y)) translateX(var(--x)) scale(0) rotate(var(--rot-end, 360deg)); /* 新增：結束時旋轉 */
        opacity: 0;
    }
}

/* ====== 【修訂後】歌詞填充測驗視窗樣式 ====== */
/* ====== 【再次修訂】歌詞填充測驗視窗樣式 ====== */
.lyrics-quiz-modal {
    position: fixed !important; /* 強化固定定位 */
    top: 0;
    left: 0;
    width: 100vw; /* 使用 viewport 單位 */
    overflow: hidden; /* 防止任何滾動或變動 */
    height: 100%;
    background: rgba(25, 40, 60, 0.85); /* 使用帶有色彩的深色背景 */
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2500;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.4s ease;
    backdrop-filter: blur(8px); /* 增強毛玻璃效果 */
}

.lyrics-quiz-modal.active {
    opacity: 1;
    pointer-events: all;
}

/* 【修訂】容器寬度已設為 90% */
.quiz-content {
    background: linear-gradient(145deg, #f8f9fa, #e9ecef);
    color: #343a40;
    padding: 30px 40px;
    border-radius: 20px;
    text-align: center;
    max-width: 500px;
    width: 90%; /* <--- 這行確保容器寬度為頁面的 90% */
    max-height: 80vh;
    overflow-y: auto; /* 如果內容過多，允許內部滾動 */
    padding-bottom: 200px; /* 關鍵：預留鍵盤高度（約200px，可根據測試調整） */
    position: relative;
    border: 1px solid rgba(0, 0, 0, 0.1);
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
    transform: scale(0.9);
    opacity: 0;
    transition: transform 0.4s cubic-bezier(0.18, 0.89, 0.32, 1.28), opacity 0.4s ease;
    box-sizing: border-box; /* 確保 padding 不會導致寬度溢出 */
}

        /* 輸入框：固定在底部上方，避免被鍵盤遮擋 */
.quiz-answer-input {
    position: sticky; /* 讓輸入框黏在視窗底部上方 */
    bottom: 10px; /* 距離底部10px */
    z-index: 10; /* 確保在頂層 */
}

.lyrics-quiz-modal.active .quiz-content {
    transform: scale(1);
    opacity: 1;
}

.quiz-title {
    font-size: 2.2rem;
    color: #17a2b8;
    margin-bottom: 10px;
    font-weight: 700;
}

.quiz-instructions {
    font-size: 1rem;
    color: #6c757d;
    margin-bottom: 20px;
}

.quiz-progress {
    background: #17a2b820;
    padding: 8px 12px;
    border-radius: 8px;
    margin-bottom: 25px;
    font-size: 1.1rem;
    font-weight: bold;
    color: #17a2b8;
    transition: all 0.3s ease;
    border: 1px solid #17a2b880;
}

.quiz-question-container {
    margin: 25px 0;
    padding: 25px;
    background: #ffffff;
    border-radius: 15px;
    min-height: 100px;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 1px solid #dee2e6;
}

#quizQuestionText {
    font-size: 1.6rem;
    color: #212529;
    line-height: 1.6;
    letter-spacing: 1px;
    font-weight: 500;
}

/* 【修正】處理填空底線的樣式 */
.quiz-blank {
    display: inline-block;
    width: 100px; /* 您可以依據平均答案長度調整此寬度 */
    border-bottom: 2px solid #6c757d;
    margin: 0 4px;
    /* 【核心修正】將 vertical-align 改為 baseline */
    vertical-align: baseline; /* 這會將元素的基線與文字的基線對齊，使底線位於正確位置 */
    /* 【核心修正】移除不再需要的微調屬性 */
    /* position: relative; (移除) */
    /* top: -4px; (移除) */
}

/* 【修訂】確保輸入框不會超出容器 */
.quiz-answer-input {
    width: 100%;
    padding: 15px;
    font-size: 1.2rem;
    border-radius: 12px;
    border: 2px solid #ced4da;
    background: #f8f9fa;
    color: #495057;
    text-align: center;
    transition: all 0.3s ease;
    box-sizing: border-box; /* <--- 這是確保輸入框寬度計算正確的關鍵 */
}

.quiz-answer-input:focus {
    outline: none;
    border-color: #17a2b8;
    box-shadow: 0 0 0 4px rgba(23, 162, 184, 0.25);
}

.quiz-answer-input.correct {
    border-color: #28a745;
    background-color: #e9f7ec;
}

.quiz-answer-input.incorrect {
    border-color: #dc3545;
    background-color: #fbebed;
    animation: shake 0.5s ease-in-out;
}

@keyframes shake {
    0%, 100% { transform: translateX(0); }
    10%, 30%, 50%, 70%, 90% { transform: translateX(-8px); }
    20%, 40%, 60%, 80% { transform: translateX(8px); }
}

.quiz-submit-btn {
    width: 100%;
    padding: 15px 20px;
    font-size: 1.2rem;
    font-weight: bold;
    color: #fff;
    background: linear-gradient(45deg, #17a2b8, #138496);
    border: none;
    border-radius: 12px;
    cursor: pointer;
    margin-top: 20px;
    transition: all 0.2s ease;
}

.quiz-submit-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 20px rgba(23, 162, 184, 0.3);
}

.quiz-submit-btn:disabled {
    background: #adb5bd;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

.quiz-close-btn {
    position: absolute;
    top: 15px;
    right: 20px;
    background: none;
    border: none;
    color: #adb5bd;
    font-size: 2rem;
    cursor: pointer;
    transition: color 0.3s ease, transform 0.3s ease;
}

.quiz-close-btn:hover {
    color: #495057;
    transform: rotate(90deg);
}

/* 響應式設計 */
@media (max-width: 480px) {
    .quiz-content {
        padding: 20px;
        padding-bottom: 250px; /* 小手機鍵盤可能更高，增加預留空間 */
    }
    .quiz-title {
        font-size: 1.8rem;
    }
    #quizQuestionText {
        font-size: 1.3rem;
    }
    .quiz-answer-input {
        font-size: 1.1rem;
        padding: 12px;
    }
    /* 【新增】調整小螢幕下的底線寬度 */
    .quiz-blank {
        width: 70px;
    }
}

 
        /* =================================================================== */
/* ====== 【全新設計】所有彈出視窗的統一風格 (Clean HUD Theme) ====== */
/* =================================================================== */


/* ====== 1. 通知視窗 (Notification Modal) - 用於解鎖成功/失敗等提示 ====== */
.notification-modal .notification-content {
    /* 【核心】設定寬度為 90%，並有最大寬度限制 */
    width: 90%;
    max-width: 400px; 
    box-sizing: border-box; /* 確保 padding 不會撐大寬度 */
    
    /* 【設計】改為乾淨明亮的淺灰色背景 */
    background: #f0f4f8; 
    color: #334155; /* 使用深石板灰，確保文字清晰易讀 */
    
    /* 【設計】更柔和的圓角與陰影 */
    border-radius: 16px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15); 
    
    padding: 25px 30px;
    border-left: 5px solid #64748b; /* 預設的側邊強調色 */

    /* 【動畫】流暢的彈出動畫 */
    transform: scale(0.8) translateY(20px);
    opacity: 0;
    transition: transform 0.4s cubic-bezier(0.18, 0.89, 0.32, 1.28), opacity 0.4s ease;
}

.notification-modal.active .notification-content {
    transform: scale(1) translateY(0);
    opacity: 1;
}

.notification-title {
    font-size: 1.6rem;
    font-weight: 700;
    margin-bottom: 8px;
}

.notification-message {
    font-size: 1rem;
    color: #64748b; /* 使用較柔和的灰色 */
    line-height: 1.6;
}

.notification-message strong {
    font-weight: 700;
    color: #334155;
}

/* --- 成功樣式 (綠色) --- */
.notification-content.success {
    border-left-color: #10b981; 
}
.notification-content.success .notification-icon {
    color: #10b981;
}
.notification-content.success .notification-title {
    color: #059669;
}

/* --- 資訊/失敗樣式 (藍色) --- */
.notification-content.info {
    border-left-color: #3b82f6; 
}
.notification-content.info .notification-icon {
    color: #3b82f6;
}
.notification-content.info .notification-title {
    color: #2563eb;
}


        /* 在對戰模式下隱藏遊戲結束標題 */
.online-mode .game-over-title-online {
    display: none;
}

/* ====== 【修訂】Game Over Modal - 淡雅低調主題 ====== */
.game-over-modal {
    position: fixed; /* 全屏定位 */
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.6); /* 柔和黑半透明，覆蓋全屏 */
    backdrop-filter: blur(6px); /* 輕毛玻璃，提升優雅 */
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.5s ease;
}

.game-over-modal.active {
    opacity: 1;
    pointer-events: all;
}

/* 內容區：全寬、淡灰漸變背景、輕陰影 */
.game-over-content {
    background: linear-gradient(135deg, #f0f4f8, #e0e0e0); /* 淡灰漸變，低調優雅 */
    width: 90%; /* 手機適應 */
    max-width: 600px; /* 電腦限制寬度 */
    padding: 40px 30px; /* 適中 padding */
    border-radius: 15px; /* 柔圓角 */
    text-align: center;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15); /* 輕柔陰影，低調立體 */
    transform: scale(0.95);
    opacity: 0;
    transition: transform 0.4s ease, opacity 0.4s ease;
    font-family: 'Noto Serif TC', serif; /* 中文字體，優雅 */
    color: #666; /* 柔灰文字 */
}

.game-over-modal.active .game-over-content {
    transform: scale(1);
    opacity: 1;
}

.game-over-title {
    font-size: 2.5rem; /* 大標題 */
    margin-bottom: 25px;
    color: #ffcc00; /* 金黃，預設「勝利」 */
    font-weight: 700;
    text-shadow: 0 1px 4px rgba(0, 0, 0, 0.2); /* 輕陰影，提升質感 */
}

.game-over-title.defeat {
    color: #ff3366; /*  紅色，「惜敗」專用 */ !important
} /* 新增 class，由 JS 動態加 */

.game-over-stats {
    display: flex;
    flex-direction: column; /* 垂直堆疊 */
    width: 100%;
    background: none; /* 無背景 */
    padding: 0;
    gap: 15px; /* 輕間隙 */
}

/* 成績文字：無卡片、顏色區分 */
.player-stats-column { /* 簡化成 div */
    width: 100%;
    padding: 0; /* 無 padding */
    background: none; /* 無背景 */
    border: none; /* 無邊框 */
    box-shadow: none; /* 無陰影 */
}

.player-stats-title {
    font-size: 1.5rem; /* 中大標題 */
    font-weight: 600;
    margin-bottom: 10px;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); /* 輕陰影 */
}

.your-title {
    color: #00c9ff; /* 己方藍 */
}

.opponent-title {
    color: #f96666; /* 對手紅 */
}

.stats-data-container {
    display: flex;
    flex-direction: column; /* 垂直顯示 */
    align-items: center;
    gap: 8px; /* 小間隙 */
}

.stats-data-item {
    text-align: center;
}

.stats-data-label {
    font-size: 1rem;
    color: #888; /* 淡灰標籤 */
    margin-bottom: 4px;
}

.stats-data-value {
    font-size: 2.2rem; /* 大數字 */
    font-weight: 700;
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.2); /* 輕陰影 */
}

.your-card .stats-data-value {
    color: #1d976c; /* 己方深綠藍 */
}

.opponent-card .stats-data-value {
    color: #00c9ff; /* 修改為藍色 */
}

/* 按鈕：淡綠藍漸變、低調陰影 */
.restart-btn {
    background: linear-gradient(45deg, #a3e635, #68d391); /* 淡綠藍，低飽和 */
    color: #fff;
    border: none;
    padding: 14px 35px;
    border-radius: 50px; /* 圓潤 */
    font-size: 1.2rem;
    font-weight: bold;
    cursor: pointer;
    margin-top: 25px; /* 間距 */
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); /* 輕陰影 */
}

.restart-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 18px rgba(0, 0, 0, 0.15); /* 懸浮輕陰影 */
}

#rematchBtn {
    background: linear-gradient(45deg, #A5D6A7, #81C784); /* 柔和綠色漸層，配合現有綠調但降低明亮度 */
    color: #333; /* 深灰文字，保持易讀 */
    border: none;
    padding: 14px 35px;
    border-radius: 50px;
    font-size: 1.2rem;
    font-weight: bold;
    cursor: pointer;
    margin-top: 10px;
    transition: transform 0.2s ease;
}

#rematchBtn:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 20px rgba(0, 128, 0, 0.2); /* 柔和綠色陰影，避免明亮光暈 */
}


        

/* 響應式：小螢幕調整 */
@media (max-width: 480px) {
    .game-over-content {
        padding: 30px 20px;
    }
    .game-over-title {
        font-size: 2.2rem;
    }
    .stats-data-value {
        font-size: 1.8rem;
    }
    .restart-btn {
        padding: 12px 30px;
        font-size: 1.1rem;
    }
}

    


/* ====== 3. 歌詞填充測驗視窗 (Lyrics Quiz Modal) ====== */
.lyrics-quiz-modal .quiz-content {
    /* 【核心】設定寬度 */
    width: 90%;
    max-width: 500px;
    box-sizing: border-box;

    /* 【設計】採用與通知視窗一致的明亮風格，讓使用者專注於作答 */
    background: linear-gradient(145deg, #f8f9fa, #e9ecef);
    color: #343a40;
    padding: 30px 40px;
    border-radius: 20px;
    border: 1px solid rgba(0, 0, 0, 0.1);
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);

    /* 【動畫】彈出動畫 */
    transform: scale(0.9);
    opacity: 0;
    transition: transform 0.4s cubic-bezier(0.18, 0.89, 0.32, 1.28), opacity 0.4s ease;
}

.lyrics-quiz-modal.active .quiz-content {
    transform: scale(1);
    opacity: 1;
}

.quiz-title {
    font-size: 2.2rem;
    color: #17a2b8; /* 使用清爽的青色作為主題色 */
    margin-bottom: 10px;
    font-weight: 700;
}

.quiz-instructions {
    font-size: 1rem;
    color: #6c757d;
    margin-bottom: 20px;
}

.quiz-answer-input {
    width: 100%; /* 輸入框填滿容器 */
    box-sizing: border-box; /* 確保 padding 不會使其溢出 */
}

.quiz-submit-btn {
    width: 100%;
    box-sizing: border-box;
}

/* 修正小螢幕下的 quiz-blank 底線位置 */
#quizQuestionText {
    font-size: 1.6rem;
    line-height: 1.6;
}
.quiz-blank {
    display: inline-block;
    width: 100px; 
    border-bottom: 2px solid #6c757d;
    margin: 0 4px;
    /* 關鍵修正：讓底線與文字基線對齊 */
    vertical-align: baseline; 
}


/* ====== 4. 通用設定類型視窗 (Settings, Leaderboard, etc.) ====== */
/* 讓所有設定相關的視窗都採用新的深色主題 */
.settings-modal .settings-content,
.personal-high-score-modal .personal-high-score-content {
    /* 【核心】設定寬度 */
    width: 90%;
    max-width: 500px;
    box-sizing: border-box;

    /* 【設計】使用精緻的深藍色主題，並帶有光暈效果 */
    background: linear-gradient(135deg, #1a1a2e, #16213e);
    padding: 30px;
    border-radius: 15px;
    box-shadow: 0 0 40px rgba(0, 190, 255, 0.3); /* 改為科技感的藍色光暈 */
    border: 1px solid rgba(0, 190, 255, 0.2);

    /* 【動畫】彈出動畫 */
    transform: scale(0.9);
    opacity: 0;
    transition: transform 0.4s ease, opacity 0.3s ease;
}

.settings-modal.active .settings-content,
.personal-high-score-modal.active .personal-high-score-content {
    transform: scale(1);
    opacity: 1;
}

.settings-title, .personal-high-score-title {
    color: #00c9ff; /* 標題顏色改為亮藍色 */
}

/* 讓按鈕樣式更統一 */
.setting-group .restart-btn {
    background: linear-gradient(45deg, #00c9ff, #92fe9d);
}

/* ====== 5. 解鎖提示視窗 (Unlock Modal) ====== */
.unlock-modal .unlock-content {
    /* 【核心】設定寬度 */
    width: 90%;
    max-width: 400px;
    box-sizing: border-box;

    /* 【設計】與設定視窗共享深色主題 */
    background: linear-gradient(135deg, #2c1a2e, #161e3e);
    padding: 40px;
    border-radius: 15px;
    box-shadow: 0 0 40px rgba(255, 204, 0, 0.5);
    border: 1px solid rgba(255, 204, 0, 0.3);

    /* 【動畫】彈出動畫 */
    transform: scale(0.9);
    opacity: 0;
    transition: transform 0.4s ease, opacity 0.3s ease;
}

.unlock-modal.active .unlock-content {
    transform: scale(1);
    opacity: 1;
}

        /* =================================================================== */
/* ====== 【新增】彈出視窗響應式設計 (Mobile-First Adaptation) ====== */
/* =================================================================== */

/* 當螢幕寬度小於等於 480px 時 (適用於大多數手機直立模式)，套用以下樣式 */
@media (max-width: 480px) {

    /* --- 統一調整所有視窗的內邊距，減少留白，爭取更多內容空間 --- */
    .notification-content,
    .game-over-content,
    .quiz-content,
    .settings-content,
    .personal-high-score-content,
    .unlock-content {
        padding: 20px 15px; /* 上下 20px, 左右 15px */
    }

    /* --- 統一縮小所有視窗的標題字體大小 --- */
    .notification-title,
    .game-over-title,
    .quiz-title,
    .settings-title,
    .personal-high-score-title,
    .unlock-message { /* .unlock-message 在這裡是作為標題使用 */
        font-size: 1.8rem; /* 從 2.2rem 或 2.8rem 縮小 */
    }
    
    .game-over-title {
        font-size: 2.2rem; /* 遊戲結束標題可以稍微大一點，以示強調 */
    }

    /* --- 統一縮小內文/訊息的字體大小 --- */
    .notification-message,
    .quiz-instructions,
    .stat-label {
        font-size: 0.95rem;
    }

   

    /* ====== 針對「歌詞測驗」畫面的特別調整 ====== */
    #quizQuestionText {
        font-size: 1.3rem; /* 縮小題目文字 */
        line-height: 1.5;
    }
    .quiz-answer-input, .quiz-submit-btn {
        font-size: 1.1rem;
        padding: 12px;
    }
    /* 縮小題目中的填空底線，避免因寬度不足而換行 */
    .quiz-blank {
        width: 70px;
    }
}

        /* ======================================================================== */
/* ====== 【全新獨立設計】"星光殿堂" 主題視窗 (Starlight Hall Theme) ====== */
/* ======================================================================== */

/* --- 1. 為主題定義一組顏色變數，方便未來統一修改 --- */
:root {
    --starlight-bg: linear-gradient(145deg, #fdfbfb 0%, #ebedee 100%); /* 溫暖的象牙白漸層背景 */
    --starlight-accent: #b48f5a;         /* 精緻、不刺眼的啞光金色，用於標題和重點 */
    --starlight-accent-glow: rgba(180, 143, 90, 0.35); /* 金色的柔和光暈效果 */
    --starlight-text-primary: #3a332a;   /* 溫暖的深棕黑色，比純黑更柔和且易讀 */
    --starlight-text-secondary: #8c7d6b; /* 用於次要說明的淺棕灰色 */
    --starlight-border: rgba(180, 143, 90, 0.4); /* 半透明的金色邊框 */
    --starlight-item-bg: rgba(255, 255, 255, 0.6); /* 列表項目的半透明背景 */
    --starlight-item-hover-bg: #ffffff;  /* 滑鼠懸停時變為不透明白色 */
}

/* --- 2. 應用新樣式到所有目標視窗的容器上 --- */
.settings-modal .settings-content,
.personal-high-score-modal .personal-high-score-content,
.unlock-modal .unlock-content {
    /* 【核心】寬度設定 */
    width: 90%;
    max-width: 500px;
    box-sizing: border-box;

    /* 【設計】套用全新的顏色和背景 */
    background: var(--starlight-bg);
    color: var(--starlight-text-primary);
    
    border-radius: 16px; /* 更大的圓角，顯得更現代 */
    border: 1px solid var(--starlight-border);
    /* 精緻的陰影：外部柔和陰影 + 內部金色光暈，營造高級感 */
    box-shadow: 0 10px 35px rgba(0, 0, 0, 0.08), 0 0 20px var(--starlight-accent-glow) inset;
    
    padding: 30px;
    
    /* 【動畫】保留流暢的彈出效果 */
    transform: scale(0.9);
    opacity: 0;
    transition: transform 0.4s cubic-bezier(0.18, 0.89, 0.32, 1.28), opacity 0.4s ease;
}

/* 視窗啟動時的動畫 */
.settings-modal.active .settings-content,
.personal-high-score-modal.active .personal-high-score-content,
.unlock-modal.active .unlock-content {
    transform: scale(1);
    opacity: 1;
}

/* --- 3. 美化視窗內部的元素 --- */

/* 標題樣式 */
.settings-title,
.personal-high-score-title,
.unlock-message { /* unlock-message 在此作為標題 */
    font-size: 2rem;
    color: var(--starlight-accent);
    font-weight: 700;
    /* 為標題文字添加細微的亮色陰影，使其更具立體感 */
    text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.8);
    margin-bottom: 25px;
}

/* 解鎖視窗的圖示也套用主題色 */
.unlock-icon {
    color: var(--starlight-accent);
}

/* 表單元素 (設定頁) */
.setting-label {
    color: var(--starlight-text-secondary);
    font-weight: bold;
    font-size: 1.1rem;
}
.setting-control {
    background: #f0f2f5; /* 淺灰色背景，與主背景區分 */
    border: 1px solid #dde0e4;
    color: var(--starlight-text-primary);
    border-radius: 8px;
}
.setting-control::placeholder {
    color: #a0a8b1;
}

/* 列表樣式 (排行榜、個人分數) */
.personal-high-score-item, .leaderboard-item {
    background: var(--starlight-item-bg);
    border-left: 4px solid var(--starlight-accent);
    margin-bottom: 10px;
    border-radius: 8px;
    transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
}
.personal-high-score-item:hover, .leaderboard-item:hover {
    background: var(--starlight-item-hover-bg);
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
}

/* 列表內的文字顏色 */
.personal-high-score-label, .leaderboard-rank, .leaderboard-name {
    color: var(--starlight-text-primary);
    font-weight: 500;
}
.personal-high-score-value, .leaderboard-score {
    color: var(--starlight-accent);
    font-weight: bold;
}
.leaderboard-rank {
    color: var(--starlight-text-secondary);
}

/* 按鈕樣式 (儲存名稱、關閉解鎖提示等) */
.setting-group .restart-btn, .close-unlock {
    background: var(--starlight-accent);
    color: white;
    border-radius: 50px; /* 圓潤的藥丸形狀 */
    border: none;
    text-shadow: none;
    box-shadow: 0 4px 15px var(--starlight-accent-glow);
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}
.setting-group .restart-btn:hover, .close-unlock:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 20px var(--starlight-accent-glow);
}

/* --- 4. 響應式設計：確保在小螢幕上同樣出色 --- */
@media (max-width: 480px) {
    .settings-modal .settings-content,
    .personal-high-score-modal .personal-high-score-content,
    .unlock-modal .unlock-content {
        padding: 25px 15px; /* 在手機上使用更緊湊的邊距 */
    }
    
    .settings-title,
    .personal-high-score-title,
    .unlock-message {
        font-size: 1.8rem; /* 縮小標題以適應螢幕寬度 */
    }

    .leaderboard-name, .personal-high-score-label {
        font-size: 0.9rem; /* 縮小列表文字 */
    }
}

        /* =================================================================== */
/* ====== 【新增修訂】修正所有彈出視窗的關閉按鈕樣式 ====== */
/* =================================================================== */

/* --- 1. 為所有使用 '×' 的關閉按鈕，設定統一、清晰的基礎樣式 --- */
.close-settings,
.close-personal-high-score,
.close-disclaimer,
.close-notification,
.quiz-close-btn {
    position: absolute;
    top: 15px; /* 統一與頂部的距離 */
    right: 20px; /* 統一與右側的距離 */

    /* 移除不必要的背景和邊框 */
    background: transparent;
    border: none;
    
    /* 調整字體和大小，使其更清晰、更像一個圖標 */
    font-size: 2.2rem; 
    font-weight: 400; /* 使用適中的字重，避免 '×' 看起來太粗 */
    line-height: 1; /* 確保 '×' 垂直居中 */

    /* 【核心修正】設定一個在淺色背景下清晰可見的預設顏色 */
    /* 我們直接使用 "星光殿堂" 主題的次要文字顏色，這是一個溫和的棕灰色 */
    color: var(--starlight-text-secondary, #8c7d6b); 
    
    cursor: pointer;
    
    /* 【互動效果】為顏色和變換效果添加流暢的過渡動畫 */
    transition: color 0.3s ease, transform 0.3s ease;
}

/* --- 2. 設定統一的滑鼠懸停 (hover) 效果 --- */
.close-settings:hover,
.close-personal-high-score:hover,
.close-disclaimer:hover,
.close-notification:hover,
.quiz-close-btn:hover {
    /* 【核心修正】懸停時變為更深的主題文字顏色，提供明確反饋 */
    color: var(--starlight-text-primary, #3a332a);

    /* 【互動效果】添加一個優雅的90度旋轉動畫 */
    transform: rotate(90deg);
}

        /* ======================================================================== */
/* ====== 【全新獨立設計】"星塵榮耀" 排行榜主題 ========================== */
/* ======================================================================== */

/* --- 1. 定義排行榜專屬的顏色變數，方便未來統一修改 --- */
:root {
    --rank-gold: #D4AF37;   /* 榮耀金 (第一名) */
    --rank-silver: #C0C0C0; /* 典雅銀 (第二名) */
    --rank-bronze: #CD7F32; /* 沉穩銅 (第三名) */
    --rank-item-bg: rgba(235, 237, 238, 0.5); /* 列表項目背景，帶有輕微透明感 */
    --rank-item-hover-bg: rgba(255, 255, 255, 0.9); /* 懸停時的背景 */
    --rank-icon-shadow: 0 2px 4px rgba(0, 0, 0, 0.15); /* 圖示陰影 */
}

/* --- 2. 玩家名稱設定區域的宏觀佈局 --- */
#playerNameGroup {
    display: flex; /* 使用 Flexbox 佈局 */
    align-items: center; /* 垂直居中對齊 */
    gap: 12px; /* 元素之間的間距 */
    border: 1px solid var(--starlight-border); /* 沿用星光殿堂主題邊框 */
    padding: 10px;
    border-radius: 50px; /* 圓潤的膠囊形狀 */
    background: rgba(255, 255, 255, 0.5);
    margin-bottom: 25px; /* 與下方列表的間距 */
}

#playerNameGroup .setting-label {
    display: none; /* 隱藏文字標籤 "你的顯示名稱:"，讓版面更簡潔 */
}

#playerNameGroup .setting-control {
    flex-grow: 1; /* 讓輸入框佔據所有可用空間 */
    border: none; /* 移除內部輸入框的邊框 */
    background: transparent; /* 背景透明 */
    padding: 8px 15px; /* 調整內邊距 */
    font-size: 1.1rem;
    color: var(--starlight-text-primary);
}
#playerNameGroup .setting-control:focus {
    outline: none; /* 移除獲取焦點時的輪廓 */
}

/* --- 3. 【核心改造】圖示化的「儲存名稱」按鈕 --- */
#savePlayerNameBtn {
    /* 尺寸與形狀 */
    width: 48px;
    height: 48px;
    padding: 0;
    flex-shrink: 0; /* 防止按鈕被壓縮 */
    border-radius: 50%; /* 正圓形 */

    /* 顏色與外觀 */
    background: var(--starlight-accent); /* 沿用主題金色 */
    color: white;
    font-size: 1.5rem; /* 控制圖示大小 */
    border: none;
    box-shadow: 0 4px 12px var(--starlight-accent-glow);
    
    /* 佈局與過渡 */
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease;
}

/* 使用 ::before 偽元素來創建圖示，完全取代文字 */
#savePlayerNameBtn::before {
    content: '✔'; /* 使用一個簡單的勾號作為圖示 */
    font-weight: bold;
}

#savePlayerNameBtn:hover {
    transform: translateY(-3px) scale(1.05);
    box-shadow: 0 8px 18px var(--starlight-accent-glow);
}

#savePlayerNameBtn:disabled {
    background: #ccc;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}
/* 當按鈕處於讀取狀態時，顯示載入動畫 */
#savePlayerNameBtn.loading::before {
    content: '';
    width: 20px;
    height: 20px;
    border: 3px solid rgba(255, 255, 255, 0.3);
    border-top-color: white;
    border-radius: 50%;
    animation: spin 1s linear infinite;
}
@keyframes spin {
    to { transform: rotate(360deg); }
}


/* --- 4. 排行榜列表的整體美化 --- */
.leaderboard-display {
    margin-top: 20px;
}

.personal-high-score-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

/* --- 5. 【核心改造】列表項目設計 (分層次感) --- */
.leaderboard-item {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    margin-bottom: 12px;
    border-radius: 12px;
    background: var(--rank-item-bg);
    border: 1px solid transparent;
    border-left-width: 5px; /* 左側邊框加粗 */
    transition: all 0.3s ease;
    gap: 15px; /* 內部元素間距 */
}

.leaderboard-item:hover {
    background: var(--rank-item-hover-bg);
    transform: scale(1.03);
    border-color: var(--starlight-border);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08);
}

/* --- 6. 【核心改造】排名顯示優化 --- */
.leaderboard-rank {
    flex-basis: 50px; /* 固定寬度 */
    flex-shrink: 0;
    font-size: 1.5rem;
    font-weight: 700;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    color: var(--starlight-text-secondary);
}

/* 玩家名稱 */
.leaderboard-name {
    flex-grow: 1; /* 佔據剩餘空間 */
    font-size: 1.1rem;
    color: var(--starlight-text-primary);
    font-weight: 500;
    text-align: left;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* 分數 */
.leaderboard-score {
    flex-basis: 100px; /* 固定寬度 */
    flex-shrink: 0;
    font-size: 1.4rem;
    font-weight: bold;
    color: var(--starlight-accent);
    text-align: right;
}

/* --- 7. 前三名特殊樣式，增加變化與榮譽感 --- */

/* 第一名：榮耀金 */
.leaderboard-item:nth-child(1) {
    background: linear-gradient(100deg, rgba(212, 175, 55, 0.15), transparent 70%);
    border-color: var(--rank-gold);
    box-shadow: 0 4px 15px rgba(212, 175, 55, 0.2);
}
.leaderboard-item:nth-child(1) .leaderboard-rank {
    color: var(--rank-gold);
    text-shadow: 0 0 8px rgba(212, 175, 55, 0.7);
}
/* 使用偽元素添加皇冠圖示 */
.leaderboard-item:nth-child(1) .leaderboard-rank::before {
    content: '👑'; /* 皇冠 Emoji */
    position: absolute;
    font-size: 1.8rem;
    opacity: 0.9;
    filter: drop-shadow(var(--rank-icon-shadow));
}
.leaderboard-item:nth-child(1) .leaderboard-rank {
    font-size: 0; /* 隱藏原本的數字 #1 */
}


/* 第二名：典雅銀 */
.leaderboard-item:nth-child(2) {
    background: linear-gradient(100deg, rgba(192, 192, 192, 0.15), transparent 70%);
    border-color: var(--rank-silver);
}
.leaderboard-item:nth-child(2) .leaderboard-rank {
    color: var(--rank-silver);
    text-shadow: 0 0 6px rgba(192, 192, 192, 0.7);
}
/* 使用偽元素添加銀牌圖示 */
.leaderboard-item:nth-child(2) .leaderboard-rank::before {
    content: '🥈'; /* 銀牌 Emoji */
    position: absolute;
    font-size: 1.6rem;
    filter: drop-shadow(var(--rank-icon-shadow));
}
.leaderboard-item:nth-child(2) .leaderboard-rank {
    font-size: 0; /* 隱藏原本的數字 #2 */
}


/* 第三名：沉穩銅 */
.leaderboard-item:nth-child(3) {
    background: linear-gradient(100deg, rgba(205, 127, 50, 0.15), transparent 70%);
    border-color: var(--rank-bronze);
}
.leaderboard-item:nth-child(3) .leaderboard-rank {
    color: var(--rank-bronze);
    text-shadow: 0 0 5px rgba(205, 127, 50, 0.7);
}
/* 使用偽元素添加銅牌圖示 */
.leaderboard-item:nth-child(3) .leaderboard-rank::before {
    content: '🥉'; /* 銅牌 Emoji */
    position: absolute;
    font-size: 1.6rem;
    filter: drop-shadow(var(--rank-icon-shadow));
}
.leaderboard-item:nth-child(3) .leaderboard-rank {
    font-size: 0; /* 隱藏原本的數字 #3 */
}


/* --- 8. 響應式設計，確保小螢幕上同樣美觀 --- */
@media (max-width: 480px) {
    .leaderboard-item {
        padding: 10px;
        gap: 10px;
    }
    .leaderboard-rank {
        flex-basis: 40px;
        font-size: 1.2rem;
    }
    .leaderboard-name {
        font-size: 1rem;
    }
    .leaderboard-score {
        flex-basis: 80px;
        font-size: 1.2rem;
    }
    #playerNameGroup {
        flex-direction: column; /* 垂直堆疊 */
        border-radius: 20px;
        padding: 15px;
    }
    #playerNameInput {
        width: 100%;
        text-align: center;
    }
    #savePlayerNameBtn {
        width: 100%;
        border-radius: 25px; /* 膠囊形狀 */
    }
    #savePlayerNameBtn::before {
        content: '儲存'; /* 在小螢幕上恢復文字，因為按鈕變大了 */
    }
}

        /* ======================================================= */
/* ====== 【新增修訂】排行榜按鈕與標題顏色變更 ====== */
/* ======================================================= */

/* --- 1. 更改「儲存名稱」按鈕的顏色 --- */
#savePlayerNameBtn {
    background: #8db592; /* 新的顏色：淡雅的鼠尾草綠 */
    /* 同步更新按鈕光暈效果的顏色 */
    box-shadow: 0 4px 12px rgba(141, 181, 146, 0.4); 
}

#savePlayerNameBtn:hover {
    /* 同步更新滑鼠懸停時的光暈效果 */
    box-shadow: 0 8px 18px rgba(141, 181, 146, 0.4);
}

#savePlayerNameBtn:hover {
    /* 同步更新滑鼠懸停時的光暈效果 */
    box-shadow: 0 8px 18px rgba(106, 142, 174, 0.4);
}

/* --- 2. 更改排行榜標題 (歌曲名稱) 的顏色 --- */
#leaderboardTitle {
    color: #6a8eae; /* 與按鈕使用相同的新顏色，保持視覺統一 */
}

        /* ================================================= */
/* ====== 【全新】遊戲中垂直歌詞樣式 ====== */
/* ================================================= */

/* 1. 歌詞的外部容器 */
.vertical-lyrics-container {
    position: absolute;
    /* 讓容器填滿整個 .tracks 軌道區域 */
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    
    /* 使用 Flexbox 來實現完美的垂直和水平置中 */
    display: flex;
    justify-content: center; /* 水平置中 */
    align-items: center;     /* 垂直置中 */
    
    /* 確保歌詞容器不會擋住下方的音符點擊 */
    pointer-events: none;
    
    /* 確保歌詞在軌道背景之上，但在音符之下 */
    z-index: 2; 

    /* 添加一些內邊距，避免文字完全貼邊 */
    padding: 20px;
    box-sizing: border-box; /* 確保 padding 不會讓容器超出範圍 */
}

/* 2. 顯示歌詞的文字元素本身 */
#game-lyric-text {
    /* 【核心】設置為垂直文字模式，由右至左書寫 */
    writing-mode: vertical-rl;
    text-orientation: mixed; /* 確保所有字符（英文、數字）保持直立 */

    /* 【核心】文字高度絕不能超過父容器（軌道區域）的高度 */
    max-height: 95%;
    
    /* 防止文字寬度過度擴張，保持美觀 */
    max-width: 100%;

    /* 文字樣式 */
    color: rgba(255, 255, 255, 0.75);
    font-weight: bold;
    text-shadow: 0 0 8px rgba(0, 0, 0, 0.7);

    /* 【核心】使用 clamp() 實現響應式字體大小 */
    /* 說明：字體最小 1rem，最大 1.8rem，理想大小為螢幕寬度的 2vw */
     font-size: clamp(1.2rem, 2.5vw, 2.2rem); /* 提高了最小、理想和最大值 */
    line-height: 1.7; /* 稍微增加行距以容納更大的字體 */

    /* 【核心】自動換行功能 */
    /* writing-mode 會自動處理換行，當一行文字高度超出 max-height 時，會自動換到新的一列（左邊） */
    text-align: center; /* 讓多行垂直文字之間對齊 */
    overflow: hidden;   /* 隱藏因極端情況下可能溢出的文字 */
    margin: 0;
    padding: 0;
}

/* 3. 響應式調整：在小螢幕（如手機）上進一步縮小字體 */
@media (max-width: 768px) {
    #game-lyric-text {
        font-size: clamp(1.1rem, 3vw, 1.5rem); /* 同樣提高了手機版的字體大小 */
        line-height: 1.6; /* 同樣增加行距 */
    }
    .vertical-lyrics-container {
        padding: 10px; /* 在手機上減少邊距 */
    }
}

/* ======================================================================== */
/* ====== 【全新獨立設計】"溫潤白玉" 遊戲結束視窗 (Warm Jade Theme) ====== */
/* ======================================================================== */

/* --- 1. 定義主題顏色變數，方便統一管理 --- */
:root {
    --jade-bg: linear-gradient(145deg, #fdfaf6 0%, #f4f1ec 100%); /* 溫暖、柔和的米白漸層背景 */
    --jade-text-primary: #5c554a;   /* 溫暖的深棕灰色，比純黑更柔和且易讀 */
    --jade-text-secondary: #a19685; /* 用於次要說明的淺棕灰色 */
    --jade-accent: #b48f5a;         /* 精緻、不刺眼的啞光金色，用於分數和重點 */
    --jade-border-color: rgba(180, 143, 90, 0.3); /* 半透明的金色邊框 */
    --jade-shadow-color: rgba(110, 95, 75, 0.15); /* 更柔和的棕色陰影 */
}



.copyright-footer {
position: fixed;
bottom: 0;
right: 0;
padding: 5px 10px;
background-color: #f1f1f1;
}

.copyright-footer p {
margin: 0;
font-size: 14px;
}

@media (max-width: 600px) {
.copyright-footer p {
font-size: 12px;
}
     #onlineRematchControls {
        /* 核心：將按鈕的排列方向從水平 (row) 改為垂直 (column) */
        flex-direction: column;
        
        /* 讓容器寬度延展至 100%，以容納全寬按鈕 */
        width: 100%;
        
        /* 確保按鈕之間有適當的垂直間距 */
        gap: 15px;
    }

    /* 讓容器內的每個按鈕都佔滿寬度 */
    #onlineRematchControls .restart-btn {
        width: 100%;
        margin: 0; /* 移除可能存在的左右 margin */
    }
}  

        /* ====== 響應式微調：針對螢幕較高的裝置，給予播放列表更多空間 ====== */
@media (min-height: 800px) and (min-width: 769px) {
    .lyrics-container {
        /* 在高螢幕上，讓歌詞區可以收縮，但不要無限增長 */
        flex-grow: 1;
        flex-shrink: 1;
    }
    .playlist {
        /* 在高螢幕上，讓播放列表優先佔據固定高度，最高可達 350px */
        flex-grow: 0;  /* 不允許增長 */
        flex-shrink: 0; /* 不允許收縮 */
        height: 350px;
    }
}

   /* ================================================= */
/* ====== 【全新】遊戲開始倒數計時畫面樣式 ====== */
/* ================================================= */

#countdown-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: none; /* 預設隱藏 */
    justify-content: center;
    align-items: center;
    font-size: 15vw; /* 字體大小會根據螢幕寬度變化 */
    font-weight: bold;
    color: white;
    background-color: rgba(0, 0, 0, 0.5); /* 半透明黑色背景 */
    z-index: 100; /* 確保在最上層 */
    text-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
    -webkit-user-select: none;
    user-select: none;
}     

        /* 【修訂三】修正線上對戰房間輸入框寬度 */
#onlineMatchModal .setting-control {
    box-sizing: border-box;
}

/* ====== 第一項修訂：調整房間號碼輸入框 ====== */
#roomIdInput {
    /* 1. 將 letter-spacing 恢復正常，解決字距太寬問題 */
    letter-spacing: normal;
    
    /* 2. 【核心修訂】增加最大寬度至 300px，使其更寬一些 */
    max-width: 300px;

    /* 3. 讓寬度縮小後的輸入框在容器內水平置中 */
    margin-left: auto;
    margin-right: auto;

    /* 4. 【核心修訂】確保元素為塊級，使 margin: auto 生效 */
    display: block;
}

/* ====== 【第四項修訂】線上對戰按鈕淡雅風格 ====== */

/* 1. 「創建房間」: 改為柔和的天空藍 */
#createRoomBtn {
    background: linear-gradient(45deg, #6E9ACF, #547AB2);
    box-shadow: 0 4px 15px rgba(84, 122, 178, 0.3);
}
#createRoomBtn:hover {
    box-shadow: 0 6px 20px rgba(84, 122, 178, 0.4);
}

/* 2. 「加入房間」: 改為沉穩的鼠尾草綠 */
#joinRoomBtn {
    background: linear-gradient(45deg, #a5d6a7, #81c784);
    box-shadow: 0 4px 15px rgba(129, 199, 132, 0.3);
}
#joinRoomBtn:hover {
    box-shadow: 0 6px 20px rgba(129, 199, 132, 0.4);
}

/* ====== 【全新修訂】對戰排行榜按鈕 - 煙波藍主題 ====== */
#showBattleRankingsBtn {
    /* 使用從淺到深的煙波藍漸變，營造層次感 */
    background: linear-gradient(45deg, #8baaaa, #6a8eae);
    
    /* 白色文字在這種背景下非常清晰 */
    color: white; 
    
    /* 搭配一個柔和的藍色光暈效果 */
    box-shadow: 0 4px 15px rgba(106, 142, 174, 0.35);
    border: none;
    transition: all 0.2s ease; /* 為滑鼠懸停效果添加過渡動畫 */
}

#showBattleRankingsBtn:hover {
    /* 滑鼠懸停時，光暈更強，按鈕輕微上浮 */
    box-shadow: 0 6px 20px rgba(106, 142, 174, 0.45);
    transform: translateY(-2px);
}

/* ====== 【全新修訂】對手分數部件 "赤色對手" 主題 ====== */

/* 1. 【核心】為對手部件容器設定一個獨特的深紅色漸層背景 */
#opponentStats {
    /* 使用從深紅到暗紅的漸層，並保持半透明，增加層次感 */
    background: linear-gradient(135deg, rgba(120, 20, 30, 0.5), rgba(80, 15, 20, 0.6));
    
    /* 使用一個更銳利、更明亮的紅色邊框來勾勒輪廓 */
    border: 1px solid rgba(229, 57, 53, 0.6);
    
    /* 添加一個柔和的紅色光暈，使其在背景中更突出 */
    box-shadow: 0 0 12px rgba(200, 40, 50, 0.3);

    /* 移除之前可能存在的左側邊框樣式 */
    border-left: 1px solid rgba(229, 57, 53, 0.6); /* 確保四邊邊框統一 */
    
    /* 確保圓角與您的分數部件一致 */
    border-radius: 8px;
    
    /* 移除可能殘留的毛玻璃效果 */
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

/* 2. 【對比】將對手的分數文字改為淺灰色，確保在深紅背景上清晰可見 */
#opponentScore {
    color: #e0e0e0; /* 使用柔和的淺灰色，而不是刺眼的純白 */
    
    /* 添加細微的黑色陰影，讓數字更具立體感 */
    text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
}

/* 3. 【協調】將標籤文字改為半透明的白色，使其比分數稍暗 */
#opponentNameLabel {
    color: rgba(255, 255, 255, 0.7);
    
    /* 移除舊有的白色輪廓陰影，因為現在的背景是深色 */
    text-shadow: none;
}
        /* ====== 第四項修訂：為線上對戰按鈕添加發光效果 ====== */
/* 1. 定義一個名為 "pulseGlow" 的光暈動畫 */
@keyframes pulseGlow {
    0% {
        box-shadow: 0 0 8px rgba(70, 130, 180, 0.5);
    }
    50% {
        box-shadow: 0 0 18px 5px rgba(70, 130, 180, 0.8);
    }
    100% {
        box-shadow: 0 0 8px rgba(70, 130, 180, 0.5);
    }
}

/* 2. 將動畫應用到「線上對戰」按鈕 (#onlineMatchBtn) 上 */
#onlineMatchBtn {
    /* 添加一個與光暈顏色匹配的半透明背景 */
    background: rgba(70, 130, 180, 0.2);
    
    /* 應用上面定義的動畫，設定為 2.5 秒一次循環，無限重複 */
    animation: pulseGlow 2.5s infinite;
}

/* 3. (可選) 讓按鈕內的 SVG 圖示顏色與光暈匹配 */
#onlineMatchBtn .personal-high-score-icon {
    fill: #e0f7fa; /* 一個非常淺的藍色，接近白色 */
}

        /* ====== 【第一項修訂】對戰模式結算畫面雙欄樣式 ====== */

/* 1. 讓主容器變為 Flexbox 佈局，並改為垂直堆疊 */
.game-over-stats.dual-view {
    display: flex;
    /* 【核心修訂】將排列方向改為垂直 */
    flex-direction: column; 
    /* 【核心修訂】讓卡片在容器中水平居中 */
    align-items: center; 
    gap: 20px; /* 項目之間的垂直間距 */
    width: 100%;
}

/* 2. 設計每一欄的統一樣式 */
.player-stats-column {
    flex-basis: 45%; /* 每欄佔據大約 45% 的寬度 */
    text-align: center;
    padding: 15px;
    border-radius: 12px;
    background: rgba(255, 255, 255, 0.1); /* 給一個淡淡的背景以示區分 */
}

/* 3. 設計欄目標題 (您的成績 / 對手成績) */
.player-stats-title {
    font-size: 1.4rem;
    font-weight: 600;
    margin-bottom: 20px;
    padding-bottom: 10px;
    border-bottom: 1px solid var(--jade-border-color);
}

/* 4. 為「您的成績」標題設定特殊顏色 (沿用主題金色) */
.your-title {
    color: var(--jade-accent, #b48f5a);
}

/* 5. 為「對手成績」標題設定對比色 (赤色) */
.opponent-title {
    color: #c62828; /* 一個沉穩的深紅色 */
}

/* 6. 設計每一條數據的樣式 (例如 "最終分數: 12345") */
.stat-item {
    margin-bottom: 15px;
}

/* 7. 覆蓋並調整舊的標籤和數字樣式以適應新佈局 */
.dual-view .stat-label {
    display: block; /* 讓標籤和數字分行顯示 */
    font-size: 1rem;
    margin-bottom: 5px;
    color: var(--jade-text-secondary, #a19685);
}

.dual-view .stat-number {
    font-size: 2.2rem; /* 適當調整數字大小 */
}

/* 8. 響應式設計：在手機等小螢幕上，將雙欄改為垂直堆疊 */
@media (max-width: 480px) {
    .game-over-stats.dual-view {
        flex-direction: column; /* 垂直堆疊 */
        align-items: center;
        gap: 15px;
    }
    .player-stats-column {
        width: 100%;
        flex-basis: auto;
    }
}


        /* ====== 【第二項修訂】對戰排行榜「我的排名」樣式 ====== */
/* ====== 【第一項修訂】修正個人排名區塊寬度 ====== */
.my-rank-display {
    width: 100%;
    padding: 15px 20px;
    margin-bottom: 25px;
    border-radius: 12px;
    background: linear-gradient(135deg, rgba(180, 143, 90, 0.1), rgba(180, 143, 90, 0.05));
    border: 1px solid var(--starlight-accent, #b48f5a);
    text-align: center;
    font-size: 1.1rem;
    color: var(--starlight-text-primary, #3a332a);
    
    /* ▼▼▼ 請在這裡加入下面這一行 ▼▼▼ */
    box-sizing: border-box; /* 確保 padding 不會撐大元素的總寬度 */
}

.my-rank-display strong {
    color: var(--starlight-accent, #b48f5a);
    font-size: 1.5rem;
    margin: 0 8px;
}

/* ======================================================================== */
/* ====== 【全新統一設計】"星塵榮耀" 排行榜主題 ========================== */
/* ======================================================================== */

/* --- 1. 定義主題顏色變數，方便未來統一修改 --- */
:root {
    --rank-gold: #D4AF37;   /* 榮耀金 (第一名) */
    --rank-silver: #C0C0C0; /* 典雅銀 (第二名) */
    --rank-bronze: #CD7F32; /* 沉穩銅 (第三名) */
    --rank-item-bg: rgba(235, 237, 238, 0.5); /* 列表項目背景，帶有輕微透明感 */
    --rank-item-hover-bg: rgba(255, 255, 255, 0.9); /* 懸停時的背景 */
    --rank-icon-shadow: 0 2px 4px rgba(0, 0, 0, 0.15); /* 圖示陰影 */
}


/* --- 2. 列表項目的統一樣式 --- */
/* 核心：同時為 .leaderboard-item 和 .battle-rank-item 套用此樣式 */
.leaderboard-item,
.battle-rank-item {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    margin-bottom: 12px;
    border-radius: 12px;
    background: var(--rank-item-bg);
    border: 1px solid transparent;
    border-left-width: 5px; /* 左側邊框加粗 */
    transition: all 0.3s ease;
    gap: 15px; /* 內部元素間距 */
}

.leaderboard-item:hover,
.battle-rank-item:hover {
    background: var(--rank-item-hover-bg);
    transform: scale(1.03);
    border-color: var(--starlight-border);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08);
}

/* --- 3. 排名顯示的統一樣式 (使用圖示) --- */
/* 核心：同時選取 .leaderboard-rank 和 .battle-rank-item::before */
.leaderboard-rank,
.battle-rank-item::before {
    flex-basis: 50px; /* 固定寬度 */
    flex-shrink: 0;
    font-size: 1.5rem;
    font-weight: 700;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--starlight-text-secondary);
    /* 移除 battle-rank-item 的數字計數器 */
    content: '' !important; 
}

/* --- 4. 玩家名稱與分數的統一樣式 --- */
.leaderboard-name,
.battle-rank-name {
    flex-grow: 1; /* 佔據剩餘空間 */
    font-size: 1.1rem;
    color: var(--starlight-text-primary);
    font-weight: 500;
    text-align: left;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.leaderboard-score,
.battle-rank-score {
    flex-basis: 100px; /* 固定寬度 */
    flex-shrink: 0;
    font-size: 1.4rem;
    font-weight: bold;
    color: var(--starlight-accent);
    text-align: right;
}

/* --- 5. 前三名特殊樣式，增加榮譽感 --- */

/* 第一名：榮耀金 + 皇冠 */
.leaderboard-item:nth-child(1),
.battle-rank-item:nth-child(1) {
    background: linear-gradient(100deg, rgba(212, 175, 55, 0.15), transparent 70%);
    border-color: var(--rank-gold);
    box-shadow: 0 4px 15px rgba(212, 175, 55, 0.2);
}
.leaderboard-item:nth-child(1) .leaderboard-rank,
.battle-rank-item:nth-child(1)::before {
    content: '👑' !important; /* 強制使用皇冠圖示 */
    font-size: 1.8rem;
    filter: drop-shadow(var(--rank-icon-shadow));
    color: var(--rank-gold);
}

/* 第二名：典雅銀 + 銀牌 */
.leaderboard-item:nth-child(2),
.battle-rank-item:nth-child(2) {
    background: linear-gradient(100deg, rgba(192, 192, 192, 0.15), transparent 70%);
    border-color: var(--rank-silver);
}
.leaderboard-item:nth-child(2) .leaderboard-rank,
.battle-rank-item:nth-child(2)::before {
    content: '🥈' !important; /* 強制使用銀牌圖示 */
    font-size: 1.6rem;
    filter: drop-shadow(var(--rank-icon-shadow));
    color: var(--rank-silver);
}

/* 第三名：沉穩銅 + 銅牌 */
.leaderboard-item:nth-child(3),
.battle-rank-item:nth-child(3) {
    background: linear-gradient(100deg, rgba(205, 127, 50, 0.15), transparent 70%);
    border-color: var(--rank-bronze);
}
.leaderboard-item:nth-child(3) .leaderboard-rank,
.battle-rank-item:nth-child(3)::before {
    content: '🥉' !important; /* 強制使用銅牌圖示 */
    font-size: 1.6rem;
    filter: drop-shadow(var(--rank-icon-shadow));
    color: var(--rank-bronze);
}

/* --- 6. 第四名及以後的排名數字樣式 --- */
/* 為 battle-rank-item 恢復數字計數器 */
#battleRankingsList {
    counter-reset: rank-counter 3; /* 從 3 開始計數 */
}
.battle-rank-item:nth-child(n+4)::before {
    counter-increment: rank-counter;
    content: "#" counter(rank-counter) !important;
    font-size: 1.2rem;
}
/* 為 leaderboard-item 恢復數字 */
.leaderboard-item:nth-child(n+4) .leaderboard-rank::after {
    counter-increment: rank-counter;
    content: "#" counter(rank-counter);
    font-size: 1.2rem;
}

/* --- 7. 「我的排名」高亮樣式 --- */
.battle-rank-item.is-me {
    border-color: #ffc107; /* 使用更鮮明的金色高亮邊框 */
    box-shadow: 0 0 15px rgba(255, 193, 7, 0.4);
}


/* --- 8. 響應式設計，確保小螢幕上同樣美觀 --- */
@media (max-width: 480px) {
    .leaderboard-item,
    .battle-rank-item {
        padding: 10px;
        gap: 10px;
    }

    .leaderboard-rank,
    .battle-rank-item::before {
        flex-basis: 40px;
    }

    .leaderboard-name,
    .battle-rank-name {
        font-size: 1rem;
    }

    .leaderboard-score,
    .battle-rank-score {
        flex-basis: 80px;
        font-size: 1.2rem;
    }
}
        
    </style>

<!-- Firebase SDKs -->
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
    
</head>
<body>
 
    <!-- Background Image -->
    <div class="background-image"></div>
    <div class="container">
        <div class="main-game-container" id="mainGameContainer">
            <div class="game-container">
                <div class="game-ui">
                    <div class="stats">
                        <div class="stat-box">
                            <div class="stat-value" id="score">0</div>
                            <div class="stat-label">分數</div>
                        </div>

                      <!-- ▼▼▼ 【修訂】為對手標籤新增 ID ▼▼▼ -->
<div class="stat-box" id="opponentStats" style="display: none;">
    <div class="stat-value" id="opponentScore">0</div>
    <!-- 修改這一行，為其加上 id="opponentNameLabel" -->
    <div class="stat-label" id="opponentNameLabel">對手分數</div>
</div>
<!-- ▲▲▲ 修訂結束 ▲▲▲ -->


<!-- ▼▼▼ 【修訂】將原有的單一標記線改為兩個獨立的標記線 ▼▼▼ -->
<div id="unlockProgressContainer" class="unlock-progress-container">
    <!-- 歌曲解鎖線 (黃色) -->
    <div id="songUnlockMarker" class="unlock-progress-marker song-marker"></div>
    <!-- 難度解鎖線 (紅色) -->
    <div id="difficultyUnlockMarker" class="unlock-progress-marker difficulty-marker"></div>
    
    <div id="unlockProgressBar" class="unlock-progress-bar"></div>

</div>
<!-- ▲▲▲ 修訂結束 ▲▲▲ -->

                        <!-- ▼▼▼ 【新增】對手分數進度條的 HTML 結構 (請加在這裡) ▼▼▼ -->
<div id="opponentProgressContainer" class="opponent-progress-container">
    <div id="opponentProgressBar" class="opponent-progress-bar"></div>
</div>
<!-- ▲▲▲ 新增結束 ▲▲▲ -->

                         <div class="progress-container">
                        <div class="progress-bar" id="progressBar"></div>
                    </div>
                    


                    </div>




                    <div class="controls">
                        <button class="svg-button" id="startBtn" title="開始遊戲">
                            <svg class="start-button-svg" viewBox="0 0 80 40">
                                <defs>
                                    <linearGradient id="startButtonGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                                        <stop offset="0%" style="stop-color:#ff8a00;stop-opacity:1" />
                                        <stop offset="100%" style="stop-color:#e52e71;stop-opacity:1" />
                                    </linearGradient>
                                </defs>
                                <rect x="0" y="0" width="80" height="40" rx="20" ry="20" fill="url(#startButtonGradient)" />
                                <path d="M30 12 L30 28 L50 20 Z" fill="white"/>
                            </svg>
                        </button>
                        <button class="settings-btn" id="settingsBtn" title="設定">
                            <svg class="settings-icon" viewBox="0 0 24 24">
                                <path d="M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.21,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.21,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.67 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z" />
                            </svg>
                        </button>


                        
                        <button class="music-player-btn" id="musicPlayerBtn" title="音樂播放器">
                             <svg class="music-player-icon" viewBox="0 0 24 24">
                                <path d="M12,3V13.55C11.41,13.21 10.73,13 10,13C7.79,13 6,14.79 6,17C6,19.21 7.79,21 10,21C12.21,21 14,19.21 14,17V7H18V3H12Z" />
                            </svg>
                        </button>
                    </div>
                   <!-- ▼▼▼ 【修訂】請用這段完整的程式碼取代舊的 .music-selector 和 .difficulty-selector 區塊 ▼▼▼ -->
<div class="music-selector">
    <!-- 歌曲選擇 -->
    <div class="music-select-wrapper">
        <select id="musicSelect">
            <option value="白影.mp3">白影</option>
            <option value="等待.mp3">等待</option>
            <option value="下一枝的惆悵.mp3">下一枝的惆悵</option>
            <option value="餘燼落入虛無.mp3">餘燼落入虛無</option>
            <option value="老屋回憶.mp3">老屋回憶</option>
            <option value="生命之書.mp3">生命之書</option>
            <option value="不完美的共生.mp3">不完美的共生</option>
            <option value="不會太悲傷.mp3">不會太悲傷</option>
            <option value="背著你說再見.mp3">背著你說再見</option>
            <option value="開始懂了.mp3">開始懂了</option>
            <option value="就在你身旁.mp3">就在你身旁</option> 
            <option value="阿公的海.mp3">阿公的海</option>
            <option value="貝殼的夢囈.mp3">貝殼的夢囈</option>
            <option value="被翻開的日記.mp3">被翻開的日記</option>
            <option value="畫顏.mp3">畫顏</option>
            <option value="玻璃盞.mp3">玻璃盞</option>
            <option value="善意的謊言.mp3">善意的謊言</option>
        </select>
        <svg class="music-icon" viewBox="0 0 24 24">
            <path d="M12,3V13.55C11.41,13.21 10.73,13 10,13C7.79,13 6,14.79 6,17C6,19.21 7.79,21 10,21C12.21,21 14,19.21 14,17V7H18V3H12Z" />
        </svg>
    </div>
    <!-- 難度選擇 (已移至此處) -->
    <div class="difficulty-selector">
        <select id="difficultySelect">
            <option value="easy">簡單</option>
            <option value="normal" selected>普通</option>
            <option value="hard">困難</option>
            <option value="hell">地獄</option>
        </select>
    </div>
    <!-- 其他按鈕 -->
    <button class="personal-high-score-btn" id="personalHighScoreBtn" title="查看個人最高分數">
        <svg class="personal-high-score-icon" viewBox="0 0 24 24">
            <path d="M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z" />
        </svg>
    </button>
    <button class="personal-high-score-btn" id="leaderboardBtn" title="歌曲排行榜">
        <svg class="personal-high-score-icon" viewBox="0 0 24 24">
            <path d="M16 11V3H8V11H2V21H22V11H16M14 5H10V9H14V5M20 13H18V15H20V13M20 17H18V19H20V17M12 13H4V19H12V13Z" />
        </svg>
    </button>
    <button class="personal-high-score-btn" id="onlineMatchBtn" title="線上對戰">
        <svg class="personal-high-score-icon" viewBox="0 0 24 24">
            <path d="M16.5,9C15.67,9 15,8.33 15,7.5C15,6.67 15.67,6 16.5,6C17.33,6 18,6.67 18,7.5C18,8.33 17.33,9 16.5,9M7.5,9C6.67,9 6,8.33 6,7.5C6,6.67 6.67,6 7.5,6C8.33,6 9,6.67 9,7.5C9,8.33 8.33,9 7.5,9M12,16C14.67,16 17.17,14.42 18.5,12C17.17,9.58 14.67,8 12,8C9.33,8 6.83,9.58 5.5,12C6.83,14.42 9.33,16 12,16M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20Z" />
        </svg>
    </button>
</div>
<!-- ▲▲▲ 修訂結束 ▲▲▲ -->



                        
                    </div>
                  
                   
                </div>
               <div class="game-area">
    <div class="tracks" id="tracksContainer"></div>

<!-- ▼▼▼ 請將這段新的 HTML 加在這裡 ▼▼▼ -->
<div id="countdown-overlay"></div>
<!-- ▲▲▲ 新增結束 ▲▲▲ -->

                   
                    <!-- ▼▼▼ 請將這段新的 HTML 加在這裡 ▼▼▼ -->
    <div class="vertical-lyrics-container">
        <p id="game-lyric-text"></p>
    </div>
    <!-- ▲▲▲ 新增結束 ▲▲▲ -->
   
    
    <!-- 觸控按鍵 (僅在觸控裝置上顯示) -->
    <div class="touch-controls" id="touchControls">
        <div class="touch-key" data-key="65">A</div>
        <div class="touch-key" data-key="83">S</div>
        <div class="touch-key" data-key="68">D</div>
        <div class="touch-key" data-key="70">F</div>
    </div>
</div>
            </div>
        </div>
    </div>

<!-- Notification Modal -->
    <div class="notification-modal" id="notificationModal">
        <div class="notification-content">
            <button class="close-notification" id="closeNotification">&times;</button>
            <div class="notification-icon" id="notificationIcon"></div>
            <h2 class="notification-title" id="notificationTitle"></h2>
            <p class="notification-message" id="notificationMessage"></p>
        </div>
    </div>


    
  <!-- ▼▼▼ 【修訂】遊戲結束畫面，增加重賽按鈕 ▼▼▼ -->
<div class="game-over-modal" id="gameOverModal">
    <div class="game-over-content">
        <h2 class="game-over-title" id="gameOverTitle"></h2>
        <!-- ▼▼▼ 請用這段新的程式碼，取代舊的 game-over-stats 區塊 ▼▼▼ -->
<div class="game-over-content">
    <h2 class="game-over-title" id="gameOverTitle"></h2>
    <div class="game-over-stats">  <!-- 移除 'dual-view' class，讓它垂直排列 -->
        <div id="myFinalStats">  <!-- 移除 class="player-stats-column" -->
            <h3 class="player-stats-title your-title">您的成績</h3>
            <div class="stats-data-container">
                <div class="stats-data-item">
                    <span class="stats-data-label">最終分數</span>
                    <span class="stats-data-value" id="myFinalScore">0</span>
                </div>
                <div class="stats-data-item">
                    <span class="stats-data-label">最高連擊</span>
                    <span class="stats-data-value" id="myFinalCombo">0</span>
                </div>
                <!-- ▼▼▼ 新增这一行，用于显示积分变化 ▼▼▼ -->
        <div class="stats-data-item">
            <span class="stats-data-label">積分變化</span>
            <span class="stats-data-value" id="myScoreChange">0</span>
        </div>
            </div>
        </div>
        <div id="opponentFinalStats">  <!-- 移除 class="player-stats-column" -->
            <h3 class="player-stats-title opponent-title">對手成績</h3>
            <div class="stats-data-container">
                <div class="stats-data-item">
                    <span class="stats-data-label">最終分數</span>
                    <span class="stats-data-value" id="opponentFinalScore">0</span>
                </div>
                <div class="stats-data-item">
                    <span class="stats-data-label">最高連擊</span>
                    <span class="stats-data-value" id="opponentFinalCombo">0</span>
                </div>
            </div>
        </div>
    </div>
    <!-- 按鈕保持原樣 -->
</div>

        
        <!-- 單機模式按鈕 -->
        <button class="restart-btn" id="restartBtn">再玩一次</button>
        <!-- 多人模式按鈕 (預設隱藏) -->
        <div id="onlineRematchControls" style="display: none; display: flex; justify-content: center; gap: 20px; margin-top: 20px;">
            <button class="restart-btn" id="rematchBtn">重開遊戲</button>
            <button class="restart-btn" id="endGameBtn" style="background: linear-gradient(45deg, #6c757d, #343a40);">結束遊戲</button>
        </div>
        <p id="rematchStatus" style="color: #ffcc00; margin-top: 15px; min-height: 20px;"></p>
    </div>
</div>
<!-- ▲▲▲ 修訂結束 ▲▲▲ -->
    <div class="settings-modal" id="settingsModal">
        <div class="settings-content">
            <button class="close-settings" id="closeSettings">&times;</button>
            <h2 class="settings-title">遊戲設定</h2>
           
            <div class="setting-group">
                <label class="setting-label" for="volumeControlModal">音樂音量:</label>
                <input type="range" class="setting-control setting-slider" id="volumeControlModal" min="0" max="1" step="0.01" value="0.7">
            </div>
            <div class="setting-group">
                <label class="setting-label" for="sfxVolumeControl">音效音量:</label>
                <input type="range" class="setting-control setting-slider" id="sfxVolumeControl" min="0" max="1" step="0.01" value="0.5">
            </div>

<div class="setting-group">
    <button class="setting-control" id="showDisclaimerBtn">查看音樂版權聲明</button>
</div>




        </div>
    </div>

    <!-- Personal High Score Modal -->
    <div class="personal-high-score-modal" id="personalHighScoreModal">
        <div class="personal-high-score-content">
            <button class="close-personal-high-score" id="closePersonalHighScore">&times;</button>
            <h2 class="personal-high-score-title">個人最高分數</h2>
            <ul class="personal-high-score-list" id="personalHighScoreList">
                <!-- Scores will be populated here -->
            </ul>
        </div>
    </div>

    <!-- Music Player Modal -->
    <div class="music-player-modal" id="musicPlayerModal">
        <div class="music-player-content">
            <div class="music-player-header">
                <!-- Removed <h1 class="music-player-title">音樂播放器</h1> -->
                <button class="close-music-player" id="closeMusicPlayer" title="返回">
                    <svg class="close-music-player-icon" viewBox="0 0 24 24">
                        <path d="M20,11V13H8L13.5,18.5L12.08,19.92L4.16,12L12.08,4.08L13.5,5.5L8,11H20Z" />
                    </svg>
                </button>
            </div>


<!-- CD Cover Container -->
<div class="cd-cover-container">
    <div class="cd-cover-wrapper">
        <img id="cdCoverImage" src="https://i.ibb.co/G4Rmgzjt/image.png" alt="CD Cover" class="cd-cover-img">
        <div class="cd-cover-overlay"></div>
    </div>
</div>


            <div class="now-playing" id="nowPlaying">正在播放: 無</div>
            <div class="lyrics-container" id="lyricsContainer">
                <div class="no-lyrics">無歌詞</div>
            </div>
            <div class="player-controls">

<!-- ▼▼▼ 【新增】循環按鈕 ▼▼▼ -->
    <button class="player-btn" id="loopBtn" title="關閉循環">
        <!-- 圖示會由 JS 動態填入 -->
    </button>
    <!-- ▲▲▲ 新增結束 ▲▲▲ -->


                <!-- ▼▼▼ 【新增】播放模式 (循序/隨機) 按鈕 ▼▼▼ -->
<button class="player-btn" id="playbackModeBtn" title="循序播放">
    <!-- 圖示會由 JS 動態填入 -->
</button>
<!-- ▲▲▲ 新增結束 ▲▲▲ -->

                
                <button class="player-btn" id="prevBtn" title="上一首" disabled>&#9664;&#9664;</button>
                <button class="player-btn play-pause-btn" id="playPauseBtn" title="播放/暫停">&#9658;</button>
                <button class="player-btn" id="nextBtn" title="下一首" disabled>&#9654;&#9654;</button>
            </div>
            <div class="progress-slider-container">
                <input type="range" class="progress-slider" id="progressSlider" min="0" max="100" value="0">
            </div>
            <div class="time-display">
                <span id="currentTime">0:00</span>
                <span id="duration">0:00</span>
            </div>
            <div class="volume-control-player">
                <label for="volumeSliderPlayer">音量:</label>
                <input type="range" class="setting-slider" id="volumeSliderPlayer" min="0" max="1" step="0.01" value="0.7">
            </div>
            <ul class="playlist" id="playlist">
                <!-- Playlist items will be populated here -->
            </ul>
        </div>
    </div>

    <!-- Unlock Modal -->
    <div class="unlock-modal" id="unlockModal">
        <div class="unlock-content">
            <div class="unlock-icon">&#128274;</div> <!-- Lock Emoji -->
            <h2 class="unlock-message">此項目尚未解鎖</h2>
            <p class="unlock-requirement" id="unlockRequirement">在普通模式下達到 40000 分以解鎖。</p>
            <button class="close-unlock" id="closeUnlock">我知道了</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

// ==========================================================
// ====== 【新增】線上對戰相關的全域變數與DOM元素 ======
// ==========================================================
            // ==========================================================
// ====== 【新增】對戰歌詞測驗專用變數 ======
// ==========================================================
let battleQuizTimer = null;           // 用於儲存每題 20 秒的計時器
let battleQuizScore = 0;            // 測驗期間的本地分數
let battleQuizQuestions = [];       // 本次測驗的 5 道題目
let battleQuizCurrentIndex = 0;     // 當前作答到第幾題
let isBattleQuizActive = false;     // 標記對戰測驗是否正在進行中
// ==========================================================
let gameMode = 'single'; // 'single' 或 'online'
let playerId = localStorage.getItem('musicGamePlayerId');
if (!playerId) {
    playerId = 'player_' + Date.now() + Math.random().toString(36).substring(2, 9);
    localStorage.setItem('musicGamePlayerId', playerId);
}
let currentRoomId = null;
let isHost = false;
let roomListener = null; // 用於儲存Firebase的監聽器，方便移除
    

const onlineMatchBtn = document.getElementById('onlineMatchBtn');
const onlineMatchModal = document.getElementById('onlineMatchModal');
const closeOnlineMatchModal = document.getElementById('closeOnlineMatchModal');
const matchStatusText = document.getElementById('matchStatusText');
const roomIdInput = document.getElementById('roomIdInput');
const createRoomBtn = document.getElementById('createRoomBtn');
const joinRoomBtn = document.getElementById('joinRoomBtn');
const randomMatchBtn = document.getElementById('randomMatchBtn');

const opponentStats = document.getElementById('opponentStats');
const opponentScoreDisplay = document.getElementById('opponentScore');
            // --- ▼▼▼ 請在此處新增下面這一行 ▼▼▼ ---
const opponentNameLabel = document.getElementById('opponentNameLabel');
            // ▼▼▼ 【新增】請在此處加入這兩行 ▼▼▼
const opponentProgressContainer = document.getElementById('opponentProgressContainer');
const opponentProgressBar = document.getElementById('opponentProgressBar');
// ▲▲▲ 新增結束 ▲▲▲

const gameOverTitle = document.getElementById('gameOverTitle');
const restartBtnSingle = document.getElementById('restartBtn'); // 單機模式按鈕
const onlineRematchControls = document.getElementById('onlineRematchControls');
const rematchBtn = document.getElementById('rematchBtn');
const endGameBtn = document.getElementById('endGameBtn');
const rematchStatus = document.getElementById('rematchStatus');
            const showBattleRankingsBtn = document.getElementById('showBattleRankingsBtn');
const battleRankingsModal = document.getElementById('battleRankingsModal');
const closeBattleRankingsModal = document.getElementById('closeBattleRankingsModal');
const battleRankingsList = document.getElementById('battleRankingsList');
const battleRankingsLoading = document.getElementById('battleRankingsLoading');
            const myBattleRankDisplay = document.getElementById('myBattleRankDisplay');


            
            
// ==========================================================
// ====== 【新增結束】 ========================================
// ==========================================================

            

// ==========================================================
// ====== 【新增】Firebase 初始化與排行榜相關設定 ======
// ==========================================================

// 你的 Firebase 設定物件
const firebaseConfig = {
  apiKey: "AIzaSyCzIWqCC47PJAKtvW2PoALA_QETz5JysfY",
  authDomain: "musictest-15e9c.firebaseapp.com",
  databaseURL: "https://musictest-15e9c-default-rtdb.firebaseio.com",
  projectId: "musictest-15e9c",
  storageBucket: "musictest-15e9c.firebasestorage.app",
  messagingSenderId: "800604129840",
  appId: "1:800604129840:web:ddd3ca5f5d4d5ff81a3bf5"
};


// 初始化 Firebase
firebase.initializeApp(firebaseConfig);
const database = firebase.database();

// 髒話過濾列表 (可持續擴充)
const profanityList = [
    // 粵語
    "屌", "屌你", "仆街", "冚家剷", "on9", "撚", "鳩", "柒", "onL9",
    // 普通話
    "操", "草泥马", "傻逼", "肏", "媽的", "他媽的", "我靠", "尼玛"
];

// 玩家狀態變數
let playerName = localStorage.getItem('musicGamePlayerName') || '';

// ==========================================================
// ====== 【新增結束】 ========================================
// ==========================================================

            
           // --- Constants and Configuration ---
// [修訂] 歌曲解鎖條件：需要達到普通難度最高分的 80%
const SONG_UNLOCK_PERCENTAGE = 0.75; 
// [修訂] 難度解鎖條件：需要達到當前難度最高分的 100%
const DIFFICULTY_UNLOCK_PERCENTAGE = 0.85;

const difficultySettings = {
    // Easy 難度：長音符較長，音符間距大，遊玩體驗輕鬆
    easy: { 
        speedMultiplier: 0.9, longNoteChance: 0.2, noteDensity: 2.0, maxSimultaneous: 3, cooldown: 400,
        longNoteMinMultiplier: 2.5, // 長音符最短是 2.5 倍基礎間隔
        longNoteMaxMultiplier: 8,   // 長音符最長是 8 倍基礎間隔
        visualGap: 70               // 物理間隙 70 像素
    },
    // Normal 難度：標準設定
    normal: { 
        speedMultiplier: 1.1, longNoteChance: 0.25, noteDensity: 3.5, maxSimultaneous: 8, cooldown: 150,
        longNoteMinMultiplier: 2,
        longNoteMaxMultiplier: 6,
        visualGap: 50
    },
    // 【修訂】Hard 難度：進一步縮短長音符最大長度
    hard: { 
        speedMultiplier: 1.6, longNoteChance: 0.30, noteDensity: 4.5, maxSimultaneous: 4, cooldown: 100,
        longNoteMinMultiplier: 2,
        longNoteMaxMultiplier: 3.5,   // 從 4 縮短至 3.5
        visualGap: 25               
    },
    // 【修訂】Hell 難度：大幅縮短長音符最大長度，使其更像一個「稍長的短音符」
    hell: { 
        speedMultiplier: 2.2, longNoteChance: 0.35, noteDensity: 5.0, maxSimultaneous: 4, cooldown: 50,
        longNoteMinMultiplier: 1.5, 
        longNoteMaxMultiplier: 2.5,   // 從 3 大幅縮短至 2.5，接近您提到的 baseInterval * 2
        visualGap: 10               
    }
};
            // Max possible scores for each song and difficulty (for display purposes)
            const maxPossibleScores = {
                "Battle-Abysswalker.mp3": {
                    easy: 150000, normal: 300000, hard: 450000, hell: 600000
                },
                "Battle-Rosemoon.mp3": {
                    easy: 150000, normal: 300000, hard: 450000, hell: 600000
                },
                "Battle-deadly.mp3": {
                    easy: 150000, normal: 300000, hard: 450000, hell: 600000
                },
                "Battle-rapier.mp3": {
                    easy: 150000, normal: 300000, hard: 450000, hell: 600000
                },
                "Ariadne-Battle.mp3": {
                    easy: 150000, normal: 300000, hard: 450000, hell: 600000
                },
                "battle-arms.mp3": {
                    easy: 150000, normal: 300000, hard: 450000, hell: 600000
                },
                "Battle.mp3": {
                    easy: 150000, normal: 300000, hard: 450000, hell: 600000
                },
                "Wanderers-City.mp3": {
                    easy: 150000, normal: 300000, hard: 450000, hell: 600000
                },
                "Remotest-Liblary.mp3": {
                    easy: 150000, normal: 300000, hard: 450000, hell: 600000
                },
                "Nostalgia.mp3": {
                    easy: 150000, normal: 300000, hard: 450000, hell: 600000
                },
                "sunbeams.mp3": {
                    easy: 150000, normal: 300000, hard: 450000, hell: 600000
                },
                "village.mp3": {
                    easy: 150000, normal: 300000, hard: 450000, hell: 600000
                },
                "Take-a-Rest.mp3": {
                    easy: 150000, normal: 300000, hard: 450000, hell: 600000
                },
                "winter-snow.mp3": {
                    easy: 150000, normal: 300000, hard: 450000, hell: 600000
                },
                "Forgotten-Place.mp3": {
                    easy: 150000, normal: 300000, hard: 450000, hell: 600000
                },
                "Rest-in-Peace.mp3": {
                    easy: 150000, normal: 300000, hard: 450000, hell: 600000
                },
                "Farewell.mp3": {
                    easy: 150000, normal: 300000, hard: 450000, hell: 600000
                },
                "reminiscence.mp3": {
                    easy: 150000, normal: 300000, hard: 450000, hell: 600000
                },
                "starry-night.mp3": {
                    easy: 150000, normal: 300000, hard: 450000, hell: 600000
                },
                "last-wish.mp3": {
                    easy: 150000, normal: 300000, hard: 450000, hell: 600000
                },
                "sorrow.mp3": {
                    easy: 150000, normal: 300000, hard: 450000, hell: 600000
                },
                "hotarumichi.mp3": {
                    easy: 150000, normal: 300000, hard: 450000, hell: 600000
                },
                "Sky-Airship.mp3": {
                    easy: 150000, normal: 300000, hard: 450000, hell: 600000
                },
                "Voyage_SE.mp3": {
                    easy: 150000, normal: 300000, hard: 450000, hell: 600000
                },
                "main-theme01.mp3": {
                    easy: 150000, normal: 300000, hard: 450000, hell: 600000
                },
                "saikai637.mp3": {
                    easy: 150000, normal: 300000, hard: 450000, hell: 600000
                }
            };

           // 請用這段程式碼完整替換舊的 songLyrics 物件
// 請用下面這段擴充後的 songData 物件，完整替換掉您原本的 songData 物件
const songData = {
    "等待.mp3": {
        lyrics: [
            { "time": 9, "text": "月亮高掛在夜空之上" },
            { "time": 13, "text": "宛如不眠的眼睛一樣" },
            { "time": 17, "text": "靜靜注視著喧囂的人間" },
            { "time": 21, "text": "有多少悲歡離合在上演" },
            { "time": 27, "text": "它守望著夜的蒼茫" },
            { "time": 29, "text": "也守望著黎明的曙光" },
            { "time": 33, "text": "在漫長歲月裡等待著" },
            { "time": 36, "text": "等待著某個人的出現" },
            { "time": 49, "text": "她已經記不清你的模樣" },
            { "time": 54, "text": "卻依然在原地默默守望" },
            { "time": 58, "text": "那是一種怎樣的深情" },
            { "time": 61, "text": "才能如此執著又漫長" },
            { "time": 67, "text": "也許你早已把它遺忘" },
            { "time": 72, "text": "而她卻還在為你照亮" },
            { "time": 76, "text": "在這城市的喧囂之中" },
            { "time": 80, "text": "還有多少人在等待著" }
        ],
        quiz: [
            { "line": "月亮高掛在__之上", "answer": "夜空" },
            { "line": "宛如不眠的__一樣", "answer": "眼睛" },
            { "line": "靜靜注視著喧囂的__", "answer": "人間" },
            { "line": "有多少__在上演", "answer": "悲歡離合" },
            { "line": "也守望著黎明的__", "answer": "曙光" },
            { "line": "在漫長__裡等待著", "answer": "歲月" },
            { "line": "她已經記不清你的__", "answer": "模樣" },
            { "line": "卻依然在原地默默__", "answer": "守望" },
            { "line": "才能如此執著又__", "answer": "漫長" },
            { "line": "也許你早已把它__", "answer": "遺忘" },
            { "line": "在這城市的__之中", "answer": "喧囂" }
        ]
    },
    "白影.mp3": {
        lyrics: [
            { "time": 12, "text": "他走進了一個荒誕的夢境" },
            { "time": 18, "text": "夢裡有個重複出現的白影" },
            { "time": 24, "text": "白影微笑著準備登上" },
            { "time": 30, "text": "有獠牙的火車廂頂" },
            { "time": 35, "text": "黃昏一次次的把白影擄走" },
            { "time": 41, "text": "他一次次的站在原地目送" },
            { "time": 47, "text": "他沒有辦法挽留" },
            { "time": 51, "text": "他沒有辦法伸出手" },
            { "time": 71, "text": "多年後他還是會常常驚醒" },
            { "time": 77, "text": "枕邊總是濕潤的一片狼藉" },
            { "time": 83, "text": "白影像餃子皮一樣包裹著他" },
            { "time": 90, "text": "越掙扎越陷進去" },
            { "time": 95, "text": "黃昏一次次的把白影擄走" },
            { "time": 101, "text": "他一次次的站在原地目送" },
            { "time": 107, "text": "他只能默默地看" },
            { "time": 112, "text": "他只能默默地吐" }
        ],
        quiz: [
            { "line": "他走進了一個荒誕的__", "answer": "夢境" },
            { "line": "夢裡有個重複出現的__", "answer": "白影" },
            { "line": "有__的火車廂頂", "answer": "獠牙" },
            { "line": "__一次次的把白影擄走", "answer": "黃昏" },
            { "line": "他一次次的站在原地__", "answer": "目送" },
            { "line": "他沒有辦法__", "answer": "挽留" },
            { "line": "多年後他還是會常常__", "answer": "驚醒" },
            { "line": "枕邊總是濕潤的一片__", "answer": "狼藉" },
            { "line": "__像餃子皮一樣包裹著他", "answer": "白影" },
            { "line": "越__越陷進去", "answer": "掙扎" },
            { "line": "他只能__地吐", "answer": "默默" }
        ]
    },
    "下一枝的惆悵.mp3": {
        lyrics: [
            { "time": 16, "text": "北京的雨是" },
            { "time": 18, "text": "四月未停歇的傾訴" },
            { "time": 23, "text": "胡同的路是我" },
            { "time": 26, "text": "無法忘卻的孤獨" },
            { "time": 31, "text": "拆遷的通知" },
            { "time": 34, "text": "是我還未收拾的包袱" },
            { "time": 39, "text": "騎行的外賣" },
            { "time": 42, "text": "是我唯一能做的救贖" },
            { "time": 46, "text": "有那麼一刻我以為我" },
            { "time": 50, "text": "忘記了哭" },
            { "time": 53, "text": "直到又聞到香煙的溫度" },
            { "time": 59, "text": "有那麼一刻我以為我" },
            { "time": 62, "text": "習慣了哭" },
            { "time": 65, "text": "直到又看到香煙的閃爍" },
            { "time": 82, "text": "你說歲月漫長" },
            { "time": 86, "text": "八年風塵僕僕卻也轉眼一晃" },
            { "time": 89, "text": "我說光陰匆忙" },
            { "time": 91, "text": "我只是忘了我是誰的兒郎" },
            { "time": 97, "text": "你說未來長河" },
            { "time": 101, "text": "你又點起了下一支的惆悵" },
            { "time": 104, "text": "我說人生匆忙" },
            { "time": 106, "text": "可我又躲不過" },
            { "time": 108, "text": "歲月的蒼茫" }
        ],
        quiz: [
            { "line": "北京的雨是四月未停歇的__", "answer": "傾訴" },
            { "line": "__的路是我無法忘卻的孤獨", "answer": "胡同" },
            { "line": "拆遷的通知是我還未收拾的__", "answer": "包袱" },
            { "line": "騎行的__是我唯一能做的救贖", "answer": "外賣" },
            { "line": "直到又聞到香煙的__", "answer": "溫度" },
            { "line": "你說__漫長", "answer": "歲月" },
            { "line": "八年__卻也轉眼一晃", "answer": "風塵僕僕" },
            { "line": "我說__匆忙", "answer": "光陰" },
            { "line": "我只是忘了我是誰的__", "answer": "兒郎" },
            { "line": "你又點起了下一支的__", "answer": "惆悵" },
            { "line": "可我又躲不過歲月的__", "answer": "蒼茫" }
        ]
    },
    "餘燼落入虛無.mp3": {
        lyrics: [
            { "time": 11, "text": "火焰跳著靈動的舞蹈" },
            { "time": 16, "text": "灰燼飄落最後一遭" },
            { "time": 20, "text": "燒化的紙錢開始飛向雲霄" },
            { "time": 25, "text": "地獄的大門即將來到" },
            { "time": 30, "text": "就像那風中飄零的草" },
            { "time": 34, "text": "沒有根基只能隨風起" },
            { "time": 39, "text": "落飄搖你看那天空中瀰漫的煙" },
            { "time": 44, "text": "那是你我生命最終的樣貌" },
            { "time": 58, "text": "火焰跳著靈動的舞蹈" },
            { "time": 61, "text": "灰燼飄落最後一遭" },
            { "time": 67, "text": "燒化的紙錢開始飛向雲霄" },
            { "time": 70, "text": "一切似乎就要結束了" },
            { "time": 76, "text": "就像那風中飄零的草" },
            { "time": 81, "text": "沒有根基只能隨風起" },
            { "time": 86, "text": "若飄搖你看那天空中瀰漫的煙" },
            { "time": 91, "text": "那是你我生命最終的樣貌" }
        ],
        quiz: [
            { "line": "火焰跳著靈動的__", "answer": "舞蹈" },
            { "line": "__飄落最後一遭", "answer": "灰燼" },
            { "line": "燒化的紙錢__開始飛向__", "answer": "雲霄" },
            { "line": "__的大門即將來到", "answer": "地獄" },
            { "line": "就像那風中__的草", "answer": "飄零" },
            { "line": "沒有__只能隨風起", "answer": "根基" },
            { "line": "你看那天空中__的煙", "answer": "瀰漫" },
            { "line": "那是你我生命最終的__", "answer": "樣貌" },
            { "line": "一切似乎就要__了", "answer": "結束" }
        ]
    },
    "老屋回憶.mp3": {
        lyrics: [
            { "time": 16, "text": "老屋的木門常年虛掩" }, { "time": 22, "text": "門外種着一棵桂花樹" }, { "time": 28, "text": "秋深時節 花瓣零散一地" }, { "time": 35, "text": "我與爺爺用竹箕收集" }, { "time": 42, "text": "回憶的碎片" }, { "time": 44, "text": "那時的快樂" }, { "time": 46, "text": "是被捕捉後又放生的小魚" }, { "time": 55, "text": "是桂花糕出鍋時的蒸汽" }, { "time": 62, "text": "是一串串銀鈴般的蟲鳴鳥囀" }, { "time": 69, "text": "然而後來" }, { "time": 71, "text": "鈴聲中斷了我所邂逅的花鳥蟲魚" }, { "time": 79, "text": "已是活生生的標本" }
        ],
        quiz: [
            { "line": "老屋的木門常年__", "answer": "虛掩" },
            { "line": "門外種着一棵__樹", "answer": "桂花" },
            { "line": "__時節 花瓣零散一地", "answer": "秋深" },
            { "line": "我與爺爺用__收集", "answer": "竹箕" },
            { "line": "回憶的__", "answer": "碎片" },
            { "line": "是被捕捉後又放生的__", "answer": "小魚" },
            { "line": "是__出鍋時的蒸汽", "answer": "桂花糕" },
            { "line": "是一串串銀鈴般的__", "answer": "蟲鳴鳥囀" },
            { "line": "鈴聲中斷了我所__的花鳥蟲魚", "answer": "鈴聲" },
            { "line": "已是活生生的__", "answer": "標本" }
        ]
    },
    "生命之書.mp3": {
        "lyrics": [
            { "time": 11, "text": "是夢的腳步匆匆沒了回顧" },
  { "time": 16, "text": "是電話裡你問我最近是否忙碌" },
  { "time": 21, "text": "是我說著還好卻藏起了孤獨" },
  { "time": 26, "text": "是你擔憂的目光我假裝不在乎" },
  { "time": 31, "text": "是想為你多付出卻不知怎麼傾訴" },
  { "time": 36, "text": "是想多些陪伴卻總被現實攔住" },
  { "time": 41, "text": "是你慢慢的習慣了獨自守候" },
  { "time": 46, "text": "是我想回頭卻已踏上了遠途" },
  { "time": 51, "text": "我翻開生命之書卻只看到你的忙碌" },
  { "time": 57, "text": "你把所有的愛都默默藏在深處" },
  { "time": 62, "text": "你說只要我好你就心滿意足" },
  { "time": 67, "text": "可是孩子啊媽" },
  { "time": 70, "text": "你是我一生的守護" },
  { "time": 84, "text": "是有多久沒和你一起漫步" },
  { "time": 88, "text": "是有多久沒撫摸你的紋路" },
  { "time": 94, "text": "是你一個人坐在門口盼著我歸途" },
  { "time": 100, "text": "是我把忙碌當作了忽略你的藉口" },
  { "time": 106, "text": "我停下忙碌腳步開始用心去領悟" },
  { "time": 111, "text": "我聽見了你心裡深藏的牽掛" },
  { "time": 116, "text": "你說孩子啊我不要你太辛苦" },
  { "time": 122, "text": "只要你快樂我怎樣都可以" },
  { "time": 129, "text": "我看見你的臉上已經寫滿了孤獨" },
  { "time": 134, "text": "我看見你的眼裡泛著無奈和幸福" },
  { "time": 139, "text": "我看見生命之書裡你的付出" },
  { "time": 144, "text": "是我寫不好的一封家書" }
],
        "quiz": [
            { "line": "是忙碌的腳步匆匆沒了__", "answer": "回顧" },
            { "line": "是電話裡你問我最近是否__", "answer": "忙碌" },
            { "line": "是我說著還好卻藏起了__", "answer": "孤獨" },
            { "line": "是你擔憂的目光我__不在乎", "answer": "假裝" },
            { "line": "是想為你多付出卻不知怎麼__", "answer": "傾訴" },
            { "line": "是想多些__卻總被現實攔住", "answer": "陪伴" },
            { "line": "是你慢慢地習慣了獨自__", "answer": "守候" },
            { "line": "是我想回頭卻已踏上了__", "answer": "遠途" },
            { "line": "我翻開__之書卻只看到你的忙碌", "answer": "生命" },
            { "line": "你把所有的愛都默默藏在__", "answer": "深處" },
            { "line": "你說只要我好你就__", "answer": "心滿意足" },
            { "line": "可是孩子啊家你是我一生的__", "answer": "守護" },
            { "line": "是有多久沒和你一起__", "answer": "漫步" },
            { "line": "是有多久沒撫摸你的__", "answer": "紋路" },
            { "line": "是你一個人坐在門口盼著我__", "answer": "歸途" },
            { "line": "是我把忙碌當做了忽略你的__", "answer": "藉口" },
            { "line": "我停下忙碌腳步開始用心去__", "answer": "聆聽" },
            { "line": "我聽見了你心裡深藏的__", "answer": "牽掛" },
            { "line": "我看見你的臉上已經__了孤獨", "answer": "寫滿" },
            { "line": "是我寫不好的一封__", "answer": "家書" }
        ]
    },
    
    "不完美的共生.mp3": {
        "lyrics": [
            { "time": 5, "text": "暗房裡紅燈閃爍" },
            { "time": 7, "text": "他在寂靜中清洗器具" },
            { "time": 10, "text": "曾以為影像會永恆銘記" },
            { "time": 16, "text": "窗外暴雨傾盆" },
            { "time": 17, "text": "他欣賞著水流的光暈" },
            { "time": 21, "text": "思緒漫過心底的回憶" },
            { "time": 27, "text": "窗外雨落如注" },
            { "time": 30, "text": "他失了意般坐在顯影液旁" },
            { "time": 34, "text": "他曾說過攝影是夢想" },
            { "time": 38, "text": "如今現實把他的心敲打" },
            { "time": 43, "text": "他感慨時光匆忙" },
            { "time": 45, "text": "歲月把一切變得滄桑" },
            { "time": 48, "text": "後來他時常對著舊照片凝望" },
            { "time": 53, "text": "那是他逝去的過往" },
            { "time": 57, "text": "照片裡的妻子笑靨如花" },
            { "time": 63, "text": "那時的兒子還未長大" },
            { "time": 85, "text": "暗房裡紅燈閃爍" },
            { "time": 87, "text": "他在寂靜中清洗器具" },
            { "time": 91, "text": "曾以為影像會永恆銘記" },
            { "time": 95, "text": "窗外暴雨傾盆" },
            { "time": 97, "text": "他欣賞著水流的光暈" },
            { "time": 101, "text": "思緒漫過心底的回憶" },
            { "time": 107, "text": "後來他終於懂得攝影的意義" },
            { "time": 112, "text": "不是追求完美的複" },
            { "time": 116, "text": "製，他看到光影，斑駁照片已" },
            { "time": 121, "text": "被他乾透，接受不完美的過往" }
        ],
        "quiz": [
            { "line": "暗房裡紅燈__", "answer": "閃爍" },
            { "line": "他在寂靜中清洗__", "answer": "器具" },
            { "line": "曾以為影像會永恆__", "answer": "銘記" },
            { "line": "窗外暴雨__", "answer": "傾盆" },
            { "line": "他欣賞著水流的__", "answer": "光暈" },
            { "line": "思緒漫過心底的__", "answer": "回憶" },
            { "line": "窗外雨落__", "answer": "如注" },
            { "line": "他失了意般坐在__旁", "answer": "顯影液" },
            { "line": "他曾說過攝影是__", "answer": "夢想" },
            { "line": "如今現實把他的心__", "answer": "敲門" },
            { "line": "他感慨時光__", "answer": "匆忙" },
            { "line": "歲月把一切變得__", "answer": "滄桑" },
            { "line": "後來他時常對著舊照片__", "answer": "凝望" },
            { "line": "那是他逝去的__", "answer": "過往" },
            { "line": "照片裡的妻子__如花", "answer": "笑靨" },
            { "line": "那時的兒子還未__", "answer": "長大" },
            { "line": "後來他終於懂得攝影的__", "answer": "意義" },
            { "line": "不是追求完美的__", "answer": "複製" },
            { "line": "他看到光影， __照片裡", "answer": "斑駁" },
            { "line": "被他親手接受不完美的__", "answer": "過往" }
        ]
    },
    "不會太悲傷.mp3": {
        "lyrics": [
            { "time": 8, "text": "他騎車載我海邊的那天" },
            { "time": 12, "text": "我坐在後座看他的襯衫" },
            { "time": 16, "text": "夕陽下他的背影很偉岸" },
            { "time": 19, "text": "他說孩子你要快樂平安" },
            { "time": 25, "text": "我想我不會太悲傷" },
            { "time": 28, "text": "他教會我生命的真相" },
            { "time": 33, "text": "生命來自於星辰和海洋" },
            { "time": 37, "text": "歸於塵土也很輝煌" },
            { "time": 51, "text": "他製作蝴蝶標本的那天" },
            { "time": 55, "text": "專注的眼神比平時更溫暖" },
            { "time": 59, "text": "他說孩子你要記住每種生命的模樣" },
            { "time": 64, "text": "他說孩子你要熱愛自然" },
            { "time": 68, "text": "我想我不會太悲傷" },
            { "time": 72, "text": "他教會我生命的真相" },
            { "time": 76, "text": "生命來自於星辰和海洋" },
            { "time": 80, "text": "歸於塵土也很輝煌" },
            { "time": 85, "text": "我想我不會太悲傷" },
            { "time": 89, "text": "他教會我生命的真相" },
            { "time": 93, "text": "生命來自於星辰和海洋" },
            { "time": 98, "text": "歸於塵土也很輝煌" }
        ],
        "quiz": [
            { "line": "他騎車載我__的那天", "answer": "海邊" },
            { "line": "我坐在後座看他的__", "answer": "襯衫" },
            { "line": "夕陽下他的背影很__", "answer": "偉岸" },
            { "line": "他說孩子你要快樂__", "answer": "平安" },
            { "line": "他製作__標本的那天", "answer": "蝴蝶" },
            { "line": "專注的眼神比平時更__", "answer": "溫暖" },
            { "line": "他說孩子你要記住每種生命的__", "answer": "模樣" },
            { "line": "他說孩子你要熱愛__", "answer": "自然" },
            { "line": "我想我不會太__", "answer": "悲傷" },
            { "line": "他教會我生命的__", "answer": "真相" },
            { "line": "生命來自於__和海洋", "answer": "星辰" },
            { "line": "歸於__也很輝煌", "answer": "塵土" }
        ]
 },

    "背著你說再見.mp3": {
        "lyrics": [
            { "time": 13,
                "text": "海邊的浪花還在翻湧"
            },
            {
                "time": 18,
                "text": "逝去的你我還在懷想"
            },
            {
                "time": 24,
                "text": "有一些難過 有一些惆悵"
            },
            {
                "time": 31,
                "text": "你怎麼捨得我獨自神傷"
            },
            {
                "time": 37,
                "text": "我想我還是選擇記住你的笑臉"
            },
            {
                "time": 43,
                "text": "就像你從前總是愛揚起臉"
            },
            {
                "time": 48,
                "text": "也許你的一生如流星般"
            },
            {
                "time": 52,
                "text": "劃落，卻是我"
            },
            {
                "time": 56,
                "text": "生命中最完整的畫面"
            },
            {
                "time": 76,
                "text": "如今啊我終於能理解"
            },
            {
                "time": 82,
                "text": "生命啊不該有太多掛礙"
            },
            {
                "time": 87,
                "text": "你給我的愛 我一生深領會"
            },
            {
                "time": 94,
                "text": "就像你希望的那樣樂觀純粹"
            },
            {
                "time": 100,
                "text": "我想我還是選擇記住你的笑臉"
            },
            {
                "time": 106,
                "text": "就像你從前總是愛揚起臉"
            },
            {
                "time": 111,
                "text": "也許你的一生如流星般"
            },
            {
                "time": 115,
                "text": "劃落，卻是我"
            },
            {
                "time": 119,
                "text": "生命中最完整的畫面"
            }
        ],
        "quiz": [
            {
                "line": "海邊的__還在翻湧",
                "answer": "浪花"
            },
            {
                "line": "__的你我還在懷想",
                "answer": "逝去"
            },
            {
                "line": "有一些難過 有一些__",
                "answer": "惆悵"
            },
            {
                "line": "你怎麼捨得我獨自__",
                "answer": "神傷"
            },
            {
                "line": "我想我還是選擇記住你的__",
                "answer": "笑臉"
            },
            {
                "line": "就像你從前總是愛揚起__",
                "answer": "臉"
            },
            {
                "line": "也許你的一生如__般",
                "answer": "流星"
            },
            {
                "line": "劃落卻是我生命中最完整的__",
                "answer": "畫面"
            },
            {
                "line": "如今啊我終於能__",
                "answer": "理解"
            },
            {
                "line": "生命啊不該有太多__",
                "answer": "掛礙"
            },
            {
                "line": "你給我的愛 我一生深__",
                "answer": "領會"
            },
            {
                "line": "就像你希望的那樣樂觀__",
                "answer": "純粹"
            }
        ]
    },

     "開始懂了.mp3": {
        "lyrics": [
            { "time": 10, "text": "我們肩併肩坐在醫院長廊" },
            { "time": 14, "text": "陪伴是這段時光的模樣" },
            { "time": 17, "text": "看著點滴在靜靜流淌" },
            { "time": 21, "text": "我的心充滿擔憂和感傷" },
            { "time": 28, "text": "媽媽你一定要堅強" },
            { "time": 32, "text": "我會守在你的身旁" },
            { "time": 37, "text": "這句話雖然沒有出口卻是我最真的願望" },
            { "time": 65, "text": "我們沉默著坐在醫院長廊" },
            { "time": 69, "text": "想找些話來打破這寂靜" },
            { "time": 73, "text": "可話到嘴邊卻又嚥下" },
            { "time": 77, "text": "也許這是最好的交流吧" },
            { "time": 83, "text": "媽媽我開始懂你了" },
            { "time": 87, "text": "你有太多的苦埋在心底" },
            { "time": 92, "text": "這句話雖然沒有出口卻讓我更加心疼你" },
            { "time": 102, "text": "媽媽我開始懂你了" },
            { "time": 106, "text": "你有太多的苦埋在心底" },
            { "time": 111, "text": "這句話雖然沒有出口卻讓我更加心疼你" }
        ],
        "quiz": [
            { "line": "我們肩併肩坐在__長廊", "answer": "醫院" },
            { "line": "陪伴是這段__的模樣", "answer": "時光" },
            { "line": "看著點滴在靜靜__", "answer": "流淌" },
            { "line": "我的心充滿擔憂和__", "answer": "感傷" },
            { "line": "媽媽你一定要__", "answer": "堅強" },
            { "line": "我會守在你的__", "answer": "身旁" },
            { "line": "這句話雖然沒有__卻是我最真的願望", "answer": "出口" },
            { "line": "想找些話來打破這__", "answer": "寂靜" },
            { "line": "可話到嘴邊卻又__", "answer": "嚥下" },
            { "line": "也許這是最好的__吧", "answer": "交流" },
            { "line": "你有太多的苦埋在__", "answer": "心底" },
            { "line": "卻讓我更加__你", "answer": "心疼" }
        ]
    },

    "就在你身旁.mp3": {
    "lyrics": [
      { "time": 16, "text": "獨自坐在醫院的長廊" },
      { "time": 19, "text": "看著點滴在靜靜流淌" },
      { "time": 23, "text": "母親就躺在那病床上" },
      { "time": 27, "text": "我坐在她的身旁" },
      { "time": 31, "text": "我想告訴她我有多堅強" },
      { "time": 35, "text": "也想告訴她有我在身旁" },
      { "time": 39, "text": "可是話未出口已哽咽在嗓" },
      { "time": 43, "text": "最終只握住她的手輕輕搖晃" },
      { "time": 49, "text": "你知道就算黑暗讓整個世界無光" },
      { "time": 55, "text": "我會為你把路照亮" },
      { "time": 57, "text": "受不了看到你無助的模樣" },
      { "time": 61, "text": "寫下我分秒必爭的願望" },
      { "time": 65, "text": "就算整個世界被寂寞捆綁" },
      { "time": 69, "text": "我也不會讓你心傷" },
      { "time": 73, "text": "到不了幸福曾許下的遠方" },
      { "time": 78, "text": "寫下我歲月依舊的守望" },
      { "time": 100, "text": "我想告訴她我有多堅強" },
      { "time": 104, "text": "也想告訴她有我在身旁" },
      { "time": 108, "text": "可是話未出口已哽咽在嗓" },
      { "time": 112, "text": "最終只握住她的手輕輕搖晃" },
      { "time": 118, "text": "你知道就算黑暗讓整個世界無光" },
      { "time": 124, "text": "我會為你把路照亮" },
      { "time": 126, "text": "受不了看到你無助的模樣" },
      { "time": 130, "text": "寫下我分秒必爭的願望" },
      { "time": 134, "text": "就算整個世界被寂寞捆綁" },
      { "time": 138, "text": "我也不會讓你心傷" },
      { "time": 142, "text": "到不了幸福曾許下的遠方" },
      { "time": 147, "text": "寫下我歲月依舊的守望" }
    ],
    "quiz": [
      { "line": "獨自坐在__的長廊", "answer": "醫院" },
      { "line": "看著__在靜靜流淌", "answer": "點滴" },
      { "line": "__就躺在那病床上", "answer": "母親" },
      { "line": "我坐在她的__", "answer": "身旁" },
      { "line": "我想告訴她我有多__", "answer": "堅強" },
      { "line": "可是話未出口已__在嗓", "answer": "哽咽" },
      { "line": "最終只握住她的手輕輕__", "answer": "搖晃" },
      { "line": "你知道就算__讓整個世界無光", "answer": "黑暗" },
      { "line": "我會為你把路__", "answer": "照亮" },
      { "line": "受不了看到你__的模樣", "answer": "無助" },
      { "line": "寫下我__的願望", "answer": "分秒必爭" },
      { "line": "就算整個世界被__捆綁", "answer": "寂寞" },
      { "line": "我也不會讓你__", "answer": "心傷" },
      { "line": "到不了__曾許下的遠方", "answer": "幸福" },
      { "line": "寫下我__依舊的守望", "answer": "歲月" }
    ]
  },

 "阿公的海.mp3": {
    "lyrics": [
      { "time": 3, "text": "阿公說的海啊" },
      { "time": 5, "text": "總充滿神秘色彩" },
      { "time": 8, "text": "為什麼那大海我一直都沒見到" },
      { "time": 14, "text": "直到現在我還是" },
      { "time": 17, "text": "喜歡望著那片海" },
      { "time": 20, "text": "我和阿公一起默默等待" },
      { "time": 29, "text": "海邊的沙灘上矗立著古老的燈塔" },
      { "time": 35, "text": "我站在岸邊上想感受海龜的氣息啊" },
      { "time": 41, "text": "那些過往的人們" },
      { "time": 44, "text": "好像也在盼著它" },
      { "time": 47, "text": "他們是否也和我一樣" },
      { "time": 55, "text": "院子裡的柚子樹" },
      { "time": 58, "text": "何時才會開花" },
      { "time": 60, "text": "那個嚮往的大海" },
      { "time": 63, "text": "我何時才能抵達" },
      { "time": 67, "text": "曾經的那艘船兒" },
      { "time": 70, "text": "它是否已經啟航" },
      { "time": 73, "text": "它是否還記得我和它" },
      { "time": 106, "text": "阿公說的海啊" },
      { "time": 109, "text": "總充滿神秘色彩" },
      { "time": 112, "text": "為什麼那大海我一直都沒見到" },
      { "time": 119, "text": "直到現在我還是" },
      { "time": 125, "text": "喜歡望著那片海" },
      { "time": 130, "text": "我和阿公一起默默等待" },
      { "time": 131, "text": "阿公說的海啊" },
      { "time": 134, "text": "它真的讓人著迷" },
      { "time": 137, "text": "如果有一天我去了" },
      { "time": 140, "text": "它會不會想我" },
      { "time": 142, "text": "如果有機會我要問問它" },
      { "time": 148, "text": "問問它" },
      { "time": 150, "text": "什麼時候" },
      { "time": 152, "text": "會回來" }
    ],
    "quiz": [
      { "line": "阿公說的__啊", "answer": "海" },
      { "line": "總充滿__色彩", "answer": "神秘" },
      { "line": "我和阿公一起默默__", "answer": "等待" },
      { "line": "海邊的沙灘上矗立著古老的__", "answer": "燈塔" },
      { "line": "我站在岸邊上想感受__的氣息啊", "answer": "海龜" },
      { "line": "那些__的人們", "answer": "過往" },
      { "line": "院子裡的__樹", "answer": "柚子" },
      { "line": "何時才會__", "answer": "開花" },
      { "line": "那個嚮往的大海我何時才能__", "answer": "抵達" },
      { "line": "曾經的那艘__", "answer": "船兒" },
      { "line": "它是否已經__", "answer": "啟航" },
      { "line": "它真的讓人__", "answer": "著迷" },
      { "line": "如果有機會我要__它", "answer": "問問" },
      { "line": "什麼時候會__", "answer": "回來" }
    ]
  },

    "貝殼的夢囈.mp3": {

        "lyrics": [
      { "time": 7, "text": "她曾有一個心願" },
      { "time": 9, "text": "渴望看海" },
      { "time": 13, "text": "無法親身體驗" },
      { "time": 15, "text": "只能心潮澎湃" },
      { "time": 19, "text": "貝殼的聲音在耳邊輕擺" },
      { "time": 25, "text": "她想那是海的溫柔姿態" },
      { "time": 30, "text": "歲月畫中的老婦微揚著唇角" },
      { "time": 36, "text": "滿是褶皺的臉上透著希望" },
      { "time": 42, "text": "坐在海邊的她望向遠方的霞光" },
      { "time": 48, "text": "臉上的細紋像波浪" },
      { "time": 80, "text": "她也曾有一個心願" },
      { "time": 84, "text": "渴望看海" },
      { "time": 86, "text": "期望與海相伴" },
      { "time": 88, "text": "哪怕歲月等待" },
      { "time": 91, "text": "孫女的話像在唇邊鋪開" },
      { "time": 96, "text": "她想那是海的溫柔和愛" },
      { "time": 103, "text": "夢中的海擁抱著她輕聲告白" },
      { "time": 109, "text": "眼裡的光芒像燈塔一樣亮采" },
      { "time": 115, "text": "躺在海邊的他沐浴溫暖的陽光" },
      { "time": 121, "text": "毋須人攙扶 臨終她終於看到了海" }
    ],
    "quiz": [
      { "line": "她曾有一個心願 渴望看__", "answer": "海" },
      { "line": "無法親身體驗 只能心潮__", "answer": "澎湃" },
      { "line": "貝殼的聲音在耳邊輕__", "answer": "擺" },
      { "line": "她想那是海的溫柔__", "answer": "姿態" },
      { "line": "歲月畫中的老婦__著唇角", "answer": "微揚" },
      { "line": "滿是__的臉上透著希望", "answer": "褶皺" },
      { "line": "坐在海邊的她望向遠方的__", "answer": "霞光" },
      { "line": "臉上的細紋像__", "answer": "波浪" },
      { "line": "期望與海相伴 哪怕歲月__", "answer": "等待" },
      { "line": "她想那是海的溫柔和__", "answer": "愛" },
      { "line": "夢中的海擁抱著他輕聲__", "answer": "告白" },
      { "line": "眼裡的光芒像__一樣亮采", "answer": "燈塔" },
      { "line": "躺在海邊的她沐浴溫暖的__", "answer": "陽光" },
      { "line": "臨終他終於看到了__", "answer": "海" }
    ]
  },

     "被翻開的日記.mp3": {
    "lyrics": [
{ "time": 19, "text": "深夜歸家的門被輕輕推開" },
{ "time": 23, "text": "桌上的燈照亮疲憊的臉" },
{ "time": 27, "text": "父親坐在沙發上沉默發呆" },
{ "time": 31, "text": "手中緊握著那本舊日記" },
{ "time": 36, "text": "曾以為我們的關係會疏遠" },
{ "time": 40, "text": "彼此的內心充滿了傷感" },
{ "time": 44, "text": "時間如流水沖淡了矛盾" },
{ "time": 49, "text": "溫馨的回憶又浮上心間" },
{ "time": 55, "text": "日記裡的秘密被一點點揭開" },
{ "time": 59, "text": "才發現我們都曾用心去愛" },
{ "time": 64, "text": "往日的爭吵和冷戰化作了淚水" },
{ "time": 69, "text": "在心底流淌" },
{ "time": 72, "text": "那本日記成了我們的和解信" },
{ "time": 77, "text": "讓彼此的心重新緊相依" },
{ "time": 80, "text": "曾經的倔強和誤解" },
{ "time": 83, "text": "如今已變成了美好的回憶" },
{ "time": 107, "text": "曾以為我們的關係會疏遠" },
{ "time": 112, "text": "彼此的內心充滿了傷感" },
{ "time": 116, "text": "時間如流水沖淡了矛盾" },
{ "time": 120, "text": "溫馨的回憶又浮上心間" },
{ "time": 126, "text": "日記裡的秘密被一點點揭開" },
{ "time": 131, "text": "才發現我們都曾用心去愛" },
{ "time": 136, "text": "往日的爭吵和冷戰化作了淚水" },
{ "time": 140, "text": "在心底流淌" },
{ "time": 144, "text": "那本日記成了我們的和解信" },
{ "time": 149, "text": "讓彼此的心重新緊相依" },
{ "time": 153, "text": "曾經的倔強和誤解" },
{ "time": 155, "text": "如今已變成了美好的回憶" }
],
"quiz": [
{ "line": "桌上的燈照亮__的臉", "answer": "疲憊" },
{ "line": "父親坐在沙發上__發呆", "answer": "沉默" },
{ "line": "手中緊握著那本舊__", "answer": "日記" },
{ "line": "曾以為我們的關係會__", "answer": "疏遠" },
{ "line": "彼此的內心充滿了__", "answer": "傷感" },
{ "line": "時間如流水沖淡了__", "answer": "矛盾" },
{ "line": "溫馨的__又浮上心間", "answer": "回憶" },
{ "line": "日記裡的__被一點點揭開", "answer": "秘密" },
{ "line": "才發現我們都曾用心去__", "answer": "愛" },
{ "line": "往日的爭吵和__化作了淚水", "answer": "冷戰" },
{ "line": "那本日記成了我們的__信", "answer": "和解" },
{ "line": "曾經的__和誤解", "answer": "倔強" },
{ "line": "如今已變成了美好的__", "answer": "回憶" }
]
},

     "畫顏.mp3": {
    "lyrics": [
      { "time": 12, "text": "夢裡又回到那間熟悉的病房" },
      { "time": 18, "text": "守在病床邊母親她氣息奄奄" },
      { "time": 23, "text": "握著她的手" },
      { "time": 26, "text": "已佈滿皺紋的臉" },
      { "time": 29, "text": "讓我再看看妳 讓我再摸摸" },
      { "time": 33, "text": "妳的眼" },
      { "time": 35, "text": "畫框中是妳一直未完成的卷" },
      { "time": 41, "text": "我們曾經一起度過多少時間" },
      { "time": 47, "text": "一滴淚落在畫上暈開一片藍" },
      { "time": 52, "text": "這是妳的畫 這是妳的遺憾" },
      { "time": 69, "text": "妳走後我把悲傷悄悄隱藏" },
      { "time": 75, "text": "害怕回憶起妳那慈祥的模樣" },
      { "time": 81, "text": "永遠留在畫中寫下妳的名字" },
      { "time": 87, "text": "讓我再呼喚妳 讓我再抱抱" },
      { "time": 91, "text": "妳肩膀" },
      { "time": 94, "text": "修復好那幅妳未完成的畫卷" },
      { "time": 99, "text": "把妳畫得更美麗比原來好看" },
      { "time": 105, "text": "把我們的故事寫進每一筆顏" },
      { "time": 111, "text": "讓我再懷念妳 讓我再貼近" },
      { "time": 115, "text": "妳耳畔" }
    ],
    "quiz": [
      { "line": "夢裡又回到那間熟悉的__", "answer": "病房" },
      { "line": "守在病床邊母親氣息__", "answer": "奄奄" },
      { "line": "已佈滿__的臉", "answer": "皺紋" },
      { "line": "畫框中是妳一直未完成的__", "answer": "卷" },
      { "line": "我們曾經一起度過多少__", "answer": "時間" },
      { "line": "一滴淚落在畫上暈開一片__", "answer": "藍" },
      { "line": "這是妳的畫 這是妳的__", "answer": "遺憾" },
      { "line": "妳走後我把悲傷悄悄__", "answer": "隱藏" },
      { "line": "害怕回憶起妳那__的模樣", "answer": "慈祥" },
      { "line": "永遠留在畫中寫下妳的__", "answer": "名字" },
      { "line": "修復好那幅妳未完成的__", "answer": "畫卷" },
      { "line": "把妳畫得更美麗比原來__", "answer": "好看" },
      { "line": "把我們的故事寫進每一筆__", "answer": "顏" },
      { "line": "讓我再懷念妳 讓我再貼近妳__", "answer": "耳畔" }
    ]
  },

     "玻璃盞.mp3": {
    "lyrics": [
      { "time": 17, "text": "有時爭吵後沈默的夜晚" },
      { "time": 22, "text": "你摔門而去淚濕了一衫" },
      { "time": 26, "text": "獨坐沙發心冷如冰寒" },
      { "time": 30, "text": "這場婚姻已千瘡百孔不堪" },
      { "time": 35, "text": "回想從前我們也曾幸福美滿" },
      { "time": 40, "text": "怎麼如今變成互相傷害的局面" },
      { "time": 44, "text": "是我太倔強 還是你太善變" },
      { "time": 48, "text": "一次次的爭吵讓愛漸行漸遠" },
      { "time": 52, "text": "我們的婚姻像破碎的玻璃盞" },
      { "time": 57, "text": "憤怒之下被丟棄再找碎片" },
      { "time": 60, "text": "傷痕清晰可見" },
      { "time": 64, "text": "心全迷失走遠" },
      { "time": 66, "text": "誰能來救救我們" },
      { "time": 68, "text": "這破碎的原因" },
      { "time": 70, "text": "像破碎的玻璃盞" },
      { "time": 74, "text": "憤怒之下被丟棄再找碎片" },
      { "time": 77, "text": "傷痕清晰可見" },
      { "time": 81, "text": "心全迷失走遠" },
      { "time": 83, "text": "誰能來救救我們" },
      { "time": 85, "text": "這破碎的緣" },
      { "time": 104, "text": "回想從前我們也曾幸福美滿" },
      { "time": 108, "text": "怎麼如今變成互相傷害的局面" },
      { "time": 112, "text": "是我太倔強 還是你太善變" },
      { "time": 117, "text": "一次次的爭吵讓愛漸行漸遠" },
      { "time": 121, "text": "我們的婚姻像破碎的玻璃盞" },
      { "time": 125, "text": "憤怒之下被丟棄再找碎片" },
      { "time": 129, "text": "傷痕清晰可見" },
      { "time": 132, "text": "心全迷失走遠" },
      { "time": 135, "text": "誰能來救救我們" },
      { "time": 137, "text": "這破碎的原因" },
      { "time": 139, "text": "像破碎的玻璃盞" },
      { "time": 142, "text": "憤怒之下被丟棄再找碎片" },
      { "time": 146, "text": "傷痕清晰可見" },
      { "time": 149, "text": "心全迷失走遠" },
      { "time": 152, "text": "誰能來救救我們" },
      { "time": 154, "text": "這破碎的緣" }
    ],
    "quiz": [
      { "line": "有時爭吵後__的夜晚", "answer": "沈默" },
      { "line": "你甩門而去__了一衫", "answer": "淚濕" },
      { "line": "獨坐沙發心冷如__", "answer": "冰寒" },
      { "line": "唇上回憶已__不堪", "answer": "千瘡百孔" },
      { "line": "回想從前我們也曾__美滿", "answer": "幸福" },
      { "line": "怎麼如今變成互相__的局面", "answer": "傷害" },
      { "line": "是我太倔強 還是你太__", "answer": "善變" },
      { "line": "一次次的爭吵讓愛__", "answer": "漸行漸遠" },
      { "line": "我們的情感像破碎的__", "answer": "玻璃盞" },
      { "line": "__之下被丟棄再找不著碎片", "answer": "憤怒" },
      { "line": "__清晰可見", "answer": "傷痕" },
      { "line": "心全__走遠", "answer": "迷失" },
      { "line": "誰能來__我們", "answer": "救救" },
      { "line": "這破碎的__", "answer": "情緣" }
    ]
  },

     "善意的謊言.mp3": {
    "lyrics": [
      { "time": 18, "text": "你說我講的故事都太淒涼" },
      { "time": 23, "text": "沒有一絲快樂或歡暢" },
      { "time": 27, "text": "但你卻來聽我講的每一章" },
      { "time": 32, "text": "甚至重複了好多遍" },
      { "time": 37, "text": "你不知道其實我也很徬徨" },
      { "time": 41, "text": "害怕故事結局太悲傷" },
      { "time": 46, "text": "可我更害怕你會失去希望" },
      { "time": 51, "text": "所以我只能編下去啊" },
      { "time": 54, "text": "編下去" },
      { "time": 55, "text": "我給你講的故事裡總有熱湯" },
      { "time": 60, "text": "就像我想給你的人生一樣有暖陽" },
      { "time": 64, "text": "你顫抖的雙手和那濕潤的眼眶" },
      { "time": 69, "text": "是我見過最心碎的模樣" },
      { "time": 74, "text": "我給你講的故事裡總有熱湯" },
      { "time": 78, "text": "就像我想給你的人生裡一直有燭光" },
      { "time": 83, "text": "可你不知道那些故事都不是真的" },
      { "time": 88, "text": "只是我用善意的謊言編織的真相" },
      { "time": 98, "text": "你不知道其實我也很徬徨" },
      { "time": 102, "text": "害怕故事結局太悲傷" },
      { "time": 107, "text": "可我更害怕你會失去希望" },
      { "time": 112, "text": "所以我只能編下去啊" },
      { "time": 116, "text": "編下去" },
      { "time": 118, "text": "我給你講的故事裡總有熱湯" },
      { "time": 122, "text": "就像我想給你的人生一直有燭光" },
      { "time": 126, "text": "可你不知道那些故事都不是真的" },
      { "time": 132, "text": "只是我用善意的謊言編織的真相" },
      { "time": 141, "text": "我給你講的故事裡總有熱湯" },
      { "time": 145, "text": "就像我想給你的人生一直有燭光" },
      { "time": 150, "text": "可你不知道那些故事都不是真的" },
      { "time": 155, "text": "只是我用善意的謊言編織的真相" }
    ],
    "quiz": [
      { "line": "你說我講的故事都太__", "answer": "淒涼" },
      { "line": "沒有一絲快樂或__", "answer": "歡暢" },
      { "line": "甚至重複了好多__", "answer": "遍" },
      { "line": "你不知道其實我也很__", "answer": "徬徨" },
      { "line": "害怕故事結局太__", "answer": "悲傷" },
      { "line": "可我更害怕你會失去__", "answer": "希望" },
      { "line": "所以我只能__下去啊", "answer": "編" },
      { "line": "我給你講的故事裡總有__", "answer": "熱湯" },
      { "line": "你__的雙手和那濕潤的眼眶", "answer": "顫抖" },
      { "line": "是我見過最__的模樣", "answer": "心碎" },
      { "line": "就像我想給你的人生裡一直有__", "answer": "燭光" },
      { "line": "可你不知道那些故事都不是__", "answer": "真的" },
      { "line": "只是我用善意的謊言__的真相", "answer": "編織" },
      { "line": "只是我用善意的__編織的真相", "answer": "謊言" }
    ]
  }

};


// --- CD Cover Images ---
const songCovers = {

    "白影.mp3": "白影.png",
    "等待.mp3": "等待.png",
   "餘燼落入虛無.mp3": "餘燼落入虛無.png",
    "下一枝的惆然.mp3": "下一枝的惆悵.png",
    "老屋回憶.mp3": "老屋回憶.png",
    "生命之書.mp3": "生命之書.png",
    "不完美的共生.mp3": "不完美的共生.png",
    "不會太悲傷.mp3": "不會太悲傷.png",
    "背著你說再見.mp3": "背著你說再見.png",
    "開始懂了.mp3": "開始懂了.png",
    "就在你身旁.mp3": "就在你身旁.png",
    "擁抱風.mp3": "擁抱風.png",
    "阿公的海.mp3": "阿公的海.png",
    "貝殼的夢囈.mp3": "貝殼的夢囈.png",
    "被翻開的日記.mp3": "被翻開的日記.png",
    "畫顏.mp3": "畫顏.png",
    "玻璃盞.mp3": "玻璃盞.png",
    "善意的謊言.mp3": "善意的謊言.png",
    // 為其他歌曲添加封面，格式為 "歌曲文件名.mp3": "圖片URL"
    // 如果沒有特定封面，可以使用一個通用的默認封面
    "default": "標準.png" // 默認封面
};



            // --- DOM Elements ---

            const mainGameContainer = document.getElementById('mainGameContainer');
            const tracksContainer = document.getElementById('tracksContainer');
            const scoreDisplay = document.getElementById('score');
            const startBtn = document.getElementById('startBtn');
            const musicSelect = document.getElementById('musicSelect');
            const progressBar = document.getElementById('progressBar');
            const gameOverModal = document.getElementById('gameOverModal');
            const finalScoreDisplay = document.getElementById('finalScore');
            const finalComboDisplay = document.getElementById('finalCombo');
            const restartBtn = document.getElementById('restartBtn');
            const settingsModal = document.getElementById('settingsModal');
            const settingsBtn = document.getElementById('settingsBtn');
            const closeSettings = document.getElementById('closeSettings');
    
            const volumeControlModal = document.getElementById('volumeControlModal');
            const sfxVolumeControl = document.getElementById('sfxVolumeControl');
            const touchKeys = document.querySelectorAll('.touch-key');
            const difficultySelect = document.getElementById('difficultySelect');
            const audio = new Audio();
            audio.volume = 1.0;
            // --- 【新增】排行榜相關的 DOM 元素 ---
const leaderboardBtn = document.getElementById('leaderboardBtn');
const leaderboardModal = document.getElementById('leaderboardModal');
const closeLeaderboard = document.getElementById('closeLeaderboard');
const playerNameGroup = document.getElementById('playerNameGroup');
const playerNameInput = document.getElementById('playerNameInput');
const savePlayerNameBtn = document.getElementById('savePlayerNameBtn');
const leaderboardTitle = document.getElementById('leaderboardTitle');
const leaderboardList = document.getElementById('leaderboardList');
const leaderboardLoading = document.getElementById('leaderboardLoading');

            // New DOM Elements
            const personalHighScoreBtn = document.getElementById('personalHighScoreBtn');
            const personalHighScoreModal = document.getElementById('personalHighScoreModal');
            const closePersonalHighScore = document.getElementById('closePersonalHighScore');
            const personalHighScoreList = document.getElementById('personalHighScoreList');
            const musicPlayerBtn = document.getElementById('musicPlayerBtn');
            const musicPlayerModal = document.getElementById('musicPlayerModal');
            const closeMusicPlayer = document.getElementById('closeMusicPlayer');
            const nowPlaying = document.getElementById('nowPlaying');
            const lyricsContainer = document.getElementById('lyricsContainer');
            const prevBtn = document.getElementById('prevBtn');
            const playPauseBtn = document.getElementById('playPauseBtn');
            const nextBtn = document.getElementById('nextBtn');
            const progressSlider = document.getElementById('progressSlider');
            const currentTimeDisplay = document.getElementById('currentTime');
            const durationDisplay = document.getElementById('duration');
            const volumeSliderPlayer = document.getElementById('volumeSliderPlayer');
            const playlist = document.getElementById('playlist');
//【新增】獲取循環按鈕的 DOM 元素
            const loopBtn = document.getElementById('loopBtn');
            // ▼▼▼ 【新增】獲取播放模式按鈕的 DOM 元素 ▼▼▼
const playbackModeBtn = document.getElementById('playbackModeBtn');
// ▲▲▲ 新增結束 ▲▲▲

            
            const unlockModal = document.getElementById('unlockModal');
            const closeUnlock = document.getElementById('closeUnlock');
            const unlockRequirement = document.getElementById('unlockRequirement');
             // ▼▼▼ 新增通知視窗的 DOM 元素 ▼▼▼
            const notificationModal = document.getElementById('notificationModal');
            const notificationIcon = document.getElementById('notificationIcon');
            const notificationTitle = document.getElementById('notificationTitle');
            const notificationMessage = document.getElementById('notificationMessage');
            const closeNotification = document.getElementById('closeNotification');

            // ▼▼▼ 新增的 DOM 元素 ▼▼▼
            const unlockProgressContainer = document.getElementById('unlockProgressContainer');
            const unlockProgressBar = document.getElementById('unlockProgressBar');
           // ▼▼▼ 【修訂】改為選取兩個新的標記線元素 ▼▼▼
            const songUnlockMarker = document.getElementById('songUnlockMarker');
            const difficultyUnlockMarker = document.getElementById('difficultyUnlockMarker');
            // ▲▲▲ 修訂結束 ▲▲▲
            // ▲▲▲ 新增結束 ▲▲▲


// ▼▼▼ 【修訂】測驗相關的狀態變數 ▼▼▼
let isQuizActive = false;
let quizQuestions = []; // 將儲存當前測驗的所有題目
let currentQuizQuestion = null; // 儲存當前的問題物件
let questionsAnsweredCorrectly = 0; // 追蹤已答對的題數
let totalQuestionsInQuiz = 0; // 測驗開始時的總題數
let quizRewardsQueue = []; // 【修改】用於儲存所有待處理的獎勵

// --- 【新增】獲取測驗視窗的 DOM 元素 ---
const lyricsQuizModal = document.getElementById('lyricsQuizModal');
const quizProgress = document.getElementById('quizProgress');
const quizQuestionText = document.getElementById('quizQuestionText');
const quizAnswerInput = document.getElementById('quizAnswerInput');
const quizSubmitBtn = document.getElementById('quizSubmitBtn');
const quizCloseBtn = document.getElementById('quizCloseBtn');

            // --- 請在此處新增以下兩行 ---
let scoreUpdateTimeout = null;
let isScoreDirty = false;
            
            // --- Game State Variables ---

// ▼▼▼ 【新增】文字回饋的物件池變數 ▼▼▼
let judgmentPool = [];
let comboPool = [];
let currentJudgmentIndex = 0;
let currentComboIndex = 0;
// ▲▲▲ 新增結束 ▲▲▲
            
            let gameActive = false;
let maxScoreForCurrentLevel = 0; // ▼▼▼ 新增狀態變數
            let unlockThresholdPercentage = 0; // ▼▼▼ 新增狀態變數
            let score = 0; // 總分，包含連擊獎勵
let pureHitScore = 0; // 新增：純擊打分數，用於解鎖計算
            let combo = 0;
            let notificationQueue = [];      // 我們的通知「待辦清單」
let isNotificationActive = false; // 一個旗標，用來判斷是否已有通知正在顯示
            let currentNotificationObject = null; // <--- 請將這一行加在這裡
            let maxCombo = 0;
            let notes = [];
            let noteSpeed = 3000;
            let animationFrame;
            let gameStartTime = 0;
            let currentSongDuration = 0;
            let noteQueue = [];
            let generateNotesTimer = null;
            let progressInterval = null;
            const musicSelectorDiv = document.querySelector('.music-selector');
            const progressContainerDiv = document.querySelector('.progress-container');
            const tracks = 4;
            const keys = ['A', 'S', 'D', 'F'];
            const keyCodes = [65, 83, 68, 70];
            const keyStates = { 65: false, 83: false, 68: false, 70: false };
            let trackCooldownUntil = new Array(tracks).fill(0);
            let sfxVolume = 0.5;
            // ▼▼▼ 【新增】粒子池相關變數 ▼▼▼
const PARTICLE_POOL_SIZE = 100; // 池的大小，可以根據需要調整
let hitParticlePool = [];
let noteParticlePool = [];
let currentHitParticleIndex = 0;
let currentNoteParticleIndex = 0;
// ▲▲▲ 新增結束 ▲▲▲

            // Music Player State
            let playerAudio = new Audio();
            playerAudio.volume = 1.0;
            let playerIsPlaying = false;
            let playlistItems = [];
            let currentPlaylistIndex = 0;
            let lyrics = [];
            let lyricsInterval = null;
            let isUpdatingSlider = false; // Flag to prevent slider update conflicts

            // ▼▼▼ 【新增】播放模式相關變數與圖示 ▼▼▼
let playbackMode = 'sequential'; // 預設為 'sequential' (循序播放)

// 定義兩種模式的 SVG 圖示
const sequentialIcon = `<svg viewBox="0 0 24 24" fill="currentColor" style="width: 24px; height: 24px;"><path d="M4 6H20V8H4V6M4 11H20V13H4V11M4 16H20V18H4V16Z"></path></svg>`;
const shuffleIcon = `<svg viewBox="0 0 24 24" fill="currentColor" style="width: 24px; height: 24px;"><path d="M10.59 9.17L5.41 4L4 5.41L9.17 10.59L10.59 9.17M14.83 13.41L13.41 14.83L18.59 20L20 18.59L14.83 13.41M5.41 20L4 18.59L18.59 4L20 5.41L5.41 20Z"></path></svg>`;
// ▲▲▲ 新增結束 ▲▲▲


//【新增】循環播放的狀態變數
            let loopMode = 'list';

            //【新增】三個狀態對應的 SVG 圖示
            const loopIconList = `<svg viewBox="0 0 24 24" fill="currentColor" style="width: 24px; height: 24px;"><path d="M7 7H17V10L21 6L17 2V5H5V12H7V7M17 17H7V14L3 18L7 22V19H19V12H17V17Z"></path></svg>`;
const loopIconSingle = `<svg viewBox="0 0 24 24" fill="currentColor" style="width: 24px; height: 24px;"><path d="M7 7H17V10L21 6L17 2V5H5V12H7V7M17 17H7V14L3 18L7 22V19H19V12H17V17Z M13 15V9H12L10 10V11H11.5V15H13Z"></path></svg>`;
const loopIconNone = `<svg viewBox="0 0 24 24" fill="currentColor" style="width: 24px; height: 24px; opacity: 0.4;"><path d="M7 7H17V10L21 6L17 2V5H5V12H7V7M17 17H7V14L3 18L7 22V19H19V12H17V17Z"></path></svg>`;
            

            // --- Audio Context for SFX ---
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            let isAudioContextStarted = false;
            function startAudioContext() {
                if (!isAudioContextStarted) {
                    audioContext.resume().then(() => {
                        isAudioContextStarted = true;
                        console.log("AudioContext started");
                    }).catch(e => console.error("Failed to start AudioContext:", e));
                }
            }
            document.body.addEventListener('click', startAudioContext, { once: true });
            document.body.addEventListener('touchstart', startAudioContext, { once: true });


// ▼▼▼ 【新增】更新播放模式按鈕外觀的函數 ▼▼▼
function updatePlaybackModeButtonUI() {
    if (playbackMode === 'shuffle') {
        playbackModeBtn.innerHTML = shuffleIcon;
        playbackModeBtn.classList.add('active');
        playbackModeBtn.title = '隨機播放';
    } else { // sequential
        playbackModeBtn.innerHTML = sequentialIcon;
        playbackModeBtn.classList.remove('active');
        playbackModeBtn.title = '循序播放';
    }
}

// ▼▼▼ 【新增】為新按鈕綁定點擊事件 ▼▼▼
playbackModeBtn.addEventListener('click', () => {
    // 切換模式
    playbackMode = (playbackMode === 'sequential') ? 'shuffle' : 'sequential';
    // 更新按鈕外觀
    updatePlaybackModeButtonUI();
    // 保存設定
    savePlayerSettings();
});


            
// ▼▼▼ 【新增】設定粒子池的函數 ▼▼▼
function setupParticlePools() {
    // 清空並重建 hitParticlePool
    hitParticlePool.forEach(p => p.remove());
    hitParticlePool = [];
    for (let i = 0; i < PARTICLE_POOL_SIZE; i++) {
        const particle = document.createElement('div');
        particle.className = 'hit-particle'; // 預設 class
        // 先將粒子附加到一個不會影響佈局的地方
        tracksContainer.appendChild(particle);
        hitParticlePool.push(particle);
    }
    currentHitParticleIndex = 0;

    // 清空並重建 noteParticlePool
    noteParticlePool.forEach(p => p.remove());
    noteParticlePool = [];
    for (let i = 0; i < PARTICLE_POOL_SIZE; i++) {
        const particle = document.createElement('div');
        particle.className = 'note-particle'; // 預設 class
        tracksContainer.appendChild(particle);
        noteParticlePool.push(particle);
    }
    currentNoteParticleIndex = 0;
}
// ▲▲▲ 新增結束 ▲▲▲


// ▼▼▼ 【新增】設定文字回饋物件池的函數 ▼▼▼
function setupFeedbackPools() {
    // 建立判定文字池 (e.g., PERFECT, GREAT)
    judgmentPool.forEach(p => p.remove()); // 清理舊的
    judgmentPool = [];
    for (let i = 0; i < 10; i++) { // 預先創建10個，通常足夠用了
        const el = document.createElement('div');
        el.className = 'judgment';
        // 預先附加到軌道容器中，設為隱藏
        el.style.opacity = '0'; 
        el.style.pointerEvents = 'none';
        tracksContainer.appendChild(el);
        judgmentPool.push(el);
    }
    currentJudgmentIndex = 0;

    // 建立 COMBO 文字池
    comboPool.forEach(p => p.remove()); // 清理舊的
    comboPool = [];
    for (let i = 0; i < 5; i++) { // COMBO 文字同時出現的機率不高，5個足夠
        const el = document.createElement('div');
        el.className = 'combo-display';
        el.style.opacity = '0';
        el.style.pointerEvents = 'none';
        tracksContainer.appendChild(el);
        comboPool.push(el);
    }
    currentComboIndex = 0;
}
// ▲▲▲ 新增結束 ▲▲▲
            

            
            function createSound(frequency, type = 'sine', duration = 0.1, baseVolume = 0.2) {
                return function() {
                    if (!isAudioContextStarted) return;
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    oscillator.type = type;
                    oscillator.frequency.value = frequency;
                    gainNode.gain.value = baseVolume * sfxVolume;
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                };
            }
           const sounds = {
                perfect: createSound(523.25, 'sine', 0.15, 1.2), // 原為 0.7，強力放大
                great: createSound(392.00, 'sine', 0.15, 1.2),  // 原為 0.6，強力放大
                good: createSound(329.63, 'sine', 0.15, 1.2),   // 原為 0.5，放大至標準音量
                miss: createSound(220.00, 'square', 0.2, 1.2),  // 原為 0.4，顯著放大
                combo: createSound(659.25, 'triangle', 0.1, 1.2) // 原為 0.5，放大至標準音量
            };

            // --- Local Storage Management ---
           const STORAGE_KEY = 'musicGameSaveData';
const PLAYER_STORAGE_KEY = 'musicPlayerSettings';

let saveData = JSON.parse(localStorage.getItem(STORAGE_KEY)) || {
    unlockedSongs: ["白影.mp3"],
    unlockedDifficulties: {}, 
    personalHighScores: {} 
};

// 新增播放器設定的儲存結構
let playerSettings = JSON.parse(localStorage.getItem(PLAYER_STORAGE_KEY)) || {
    currentSong: null,
    currentTime: 0,
    volume: 0.7,
    isPlaying: false,
    playlistStates: {}, // 記錄每首歌的啟用/停用狀態
    currentPlaylistIndex: 0
};

            // Initialize unlocked difficulties for existing unlocked songs
            saveData.unlockedSongs.forEach(song => {
                if (!saveData.unlockedDifficulties[song]) {
                    saveData.unlockedDifficulties[song] = { normal: true, hard: false, hell: false };
                }
            });

          function saveGame() {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(saveData));
}

// 【修正版】請用這段程式碼完整替換舊的 checkAndApplyAdminUnlocks 函數
async function checkAndApplyAdminUnlocks() {
    const allSongs = Array.from(musicSelect.options).map(opt => opt.value);

    // 情況一：玩家已經擁有永久解鎖權限 (本地已有標記)
    if (saveData.adminUnlockApplied === true) {
        const allSongsAreUnlocked = allSongs.every(song => saveData.unlockedSongs.includes(song));

        // 僅當發現有新歌時，才執行靜默更新
        if (!allSongsAreUnlocked) {
            console.log("偵測到新歌曲，為已授權玩家靜默解鎖...");
            
            // 直接用最新的歌曲列表覆蓋存檔
            saveData.unlockedSongs = [...allSongs];
            allSongs.forEach(songUrl => {
                if (!saveData.unlockedDifficulties[songUrl]) {
                    saveData.unlockedDifficulties[songUrl] = {};
                }
                saveData.unlockedDifficulties[songUrl] = { normal: true, hard: true, hell: true };
            });
            
            saveGame();
            updateSongOptions();
            if (musicPlayerModal.classList.contains('active')) {
                initMusicPlayer();
            }
        }
        
        // 【核心修正】靜默同步完成後，直接返回，不再執行後續的 Firebase 檢查。
        // 這能確保通知不會被重複觸發。
        return;
    }

    // 情況二：玩家尚未被授權，此時才需要檢查 Firebase 是否有一次性指令
    const currentPlayerName = localStorage.getItem('musicGamePlayerName');
    if (!currentPlayerName) return;

    try {
        const unlockRef = database.ref(`admin/unlockOverrides/${currentPlayerName}`);
        const snapshot = await unlockRef.once('value');

        if (snapshot.exists() && snapshot.val() === true) {
            console.log(`偵測到玩家 ${currentPlayerName} 的管理員解鎖指令，正在執行一次性覆寫...`);
            
            // 執行解鎖
            saveData.unlockedSongs = [...allSongs];
            allSongs.forEach(songUrl => {
                 if (!saveData.unlockedDifficulties[songUrl]) {
                    saveData.unlockedDifficulties[songUrl] = {};
                }
                saveData.unlockedDifficulties[songUrl] = { normal: true, hard: true, hell: true };
            });

            // 在本地存檔中打上永久標記
            saveData.adminUnlockApplied = true;
            saveGame();

            // 彈出【僅此一次】的通知
            showNotification('success', '管理員權限', '開發者已為您解鎖所有歌曲和難度！');

            // 更新介面
            updateSongOptions();
            if (musicPlayerModal.classList.contains('active')) {
                initMusicPlayer();
            }
            
            // 刪除 Firebase 上的指令
            await unlockRef.remove();
        }
    } catch (error) {
        console.error("檢查管理員解鎖時發生錯誤:", error);
    }
}

// 新增播放器設定保存函數
function savePlayerSettings() {
    // 更新當前播放狀態
    if (playlistItems.length > 0 && currentPlaylistIndex >= 0) {
        playerSettings.currentSong = playlistItems[currentPlaylistIndex]?.url || null;
        playerSettings.currentTime = playerAudio.currentTime || 0;
        playerSettings.volume = playerAudio.volume || 0.7;
        playerSettings.isPlaying = playerIsPlaying;
        playerSettings.currentPlaylistIndex = currentPlaylistIndex;
         // ▼▼▼ 在函數末尾加入這行 ▼▼▼
    playerSettings.playbackMode = playbackMode; // 保存當前的播放模式
    // ▲▲▲ 新增結束 ▲▲▲

    localStorage.setItem(PLAYER_STORAGE_KEY, JSON.stringify(playerSettings));
    }
    
    // 保存播放清單狀態
    const playlistElements = document.querySelectorAll('.playlist-item');
    playerSettings.playlistStates = {};
    playlistElements.forEach((item, index) => {
        if (playlistItems[index]) {
            playerSettings.playlistStates[playlistItems[index].url] = {
                enabled: item.dataset.enabled === 'true',
                index: index
            };
        }
    });
    
    localStorage.setItem(PLAYER_STORAGE_KEY, JSON.stringify(playerSettings));
}

// 載入播放器設定
// 【修訂後】的 loadPlayerSettings 函數
function loadPlayerSettings() {
    if (playerSettings.volume !== undefined) {
        playerAudio.volume = playerSettings.volume;
        volumeSliderPlayer.value = playerSettings.volume;
    }

     // ▼▼▼ 在函數開頭加入這段 ▼▼▼
    // 載入儲存的播放模式，如果沒有就用預設的 'sequential'
    playbackMode = playerSettings.playbackMode || 'sequential'; 
    updatePlaybackModeButtonUI(); // 根據載入的模式更新按鈕外觀
    // ▲▲▲ 新增結束 ▲▲▲

    // 當播放器打開時，準備好上次播放的歌曲畫面，但先不播放
    if (playerSettings.currentSong && playlistItems.length > 0) {
        const songIndex = playlistItems.findIndex(item => item.url === playerSettings.currentSong);
        if (songIndex !== -1) {
            // 呼叫主函數來更新所有畫面
            setupSongUI(songIndex);
            // 恢復上次的播放進度
            playerAudio.currentTime = playerSettings.currentTime || 0;
            
            // 如果上次是正在播放的狀態，則自動繼續播放
            if (playerSettings.isPlaying) {
                playerAudio.play().catch(e => console.error("自動播放失敗:", e));
            }
        }
    }
}

            // --- Unlock System ---
            function isSongUnlocked(songUrl) {
                return saveData.unlockedSongs.includes(songUrl);
            }

            function isDifficultyUnlocked(songUrl, difficulty) {
                if (difficulty === 'easy' || difficulty === 'normal') return true; // Easy/Normal always unlocked for unlocked songs
                return saveData.unlockedDifficulties[songUrl] && saveData.unlockedDifficulties[songUrl][difficulty];
            }

         function unlockNextSong(songJustPlayed) {
                const allSongs = Array.from(musicSelect.options).map(opt => opt.value);
                const lastUnlockedSong = saveData.unlockedSongs[saveData.unlockedSongs.length - 1];

                if (songJustPlayed === lastUnlockedSong) {
                    const currentIndex = allSongs.indexOf(lastUnlockedSong);
                    if (currentIndex >= 0 && currentIndex < allSongs.length - 1) {
                        const nextSong = allSongs[currentIndex + 1];
                        if (!isSongUnlocked(nextSong)) {
                            saveData.unlockedSongs.push(nextSong);
                            saveData.unlockedDifficulties[nextSong] = { normal: true, hard: false, hell: false };
                            saveGame();
                            updateSongOptions();

                            const songDisplayName = Array.from(musicSelect.options).find(opt => opt.value === nextSong)?.textContent || nextSong;
                            showNotification('success', '新歌曲已解鎖！', `恭喜您！歌曲 <strong>${songDisplayName}</strong> 現在可以在播放清單中選擇了。`);
                            
                            return true; // 【新增】成功解鎖，回傳 true
                        }
                    }
                }
                return false; // 【新增】沒有發生解鎖，回傳 false
            }

           function unlockDifficulty(songUrl, difficulty) {
                if (!saveData.unlockedDifficulties[songUrl]) {
                    saveData.unlockedDifficulties[songUrl] = { normal: true, hard: false, hell: false };
                }
                if (!saveData.unlockedDifficulties[songUrl][difficulty]) {
                    saveData.unlockedDifficulties[songUrl][difficulty] = true;
                    saveGame();
                    updateSongOptions();
                    
                    const songTitle = Array.from(musicSelect.options).find(opt => opt.value === songUrl)?.textContent || songUrl;
                    const difficultyText = difficultySelect.querySelector(`option[value="${difficulty}"]`).textContent.replace(' (未解鎖)', '');
                    showNotification('success', '新難度已解鎖！', `<strong>${songTitle}</strong> 的 <strong>${difficultyText}</strong> 難度現已開放挑戰！`);

                    return true; // 【新增】成功解鎖，回傳 true
                }
                return false; // 【新增】沒有發生解鎖，回傳 false
            }

          // 修訂後的 checkAndUnlockDifficulties 函數
// 【修正後的版本】請用這段程式碼完整替換舊的 checkAndUnlockDifficulties 函數

function checkAndUnlockDifficulties(songUrl, difficulty, pureHitScore) {
    // 檢查是否可以從 "普通" 解鎖 "困難"
    if (difficulty === 'normal' && !isDifficultyUnlocked(songUrl, 'hard')) {
        // 使用與進度條完全相同的、準確的理論最高分來計算門檻
        const requiredScore = maxScoreForCurrentLevel * DIFFICULTY_UNLOCK_PERCENTAGE;
        
        // 使用與進度條完全相同的純粹打擊分數來進行比較
        if (pureHitScore >= requiredScore) {
            unlockDifficulty(songUrl, 'hard');
        }
    }

    // 檢查是否可以從 "困難" 解鎖 "地獄"
    if (difficulty === 'hard' && !isDifficultyUnlocked(songUrl, 'hell')) {
        // 同樣，使用準確的理論最高分來計算門檻
        const requiredScore = maxScoreForCurrentLevel * DIFFICULTY_UNLOCK_PERCENTAGE;
        
        // 同樣，使用純粹打擊分數來進行比較
        if (pureHitScore >= requiredScore) {
            unlockDifficulty(songUrl, 'hell');
        }
    }
}

            function showUnlockModal(message) {
                unlockRequirement.textContent = message;
                unlockModal.classList.add('active');
            }

            // --- UI Updates ---



function processNotificationQueue() {
    if (isNotificationActive || notificationQueue.length === 0) {
        return;
    }

    isNotificationActive = true;
    const notification = notificationQueue.shift();
    currentNotificationObject = notification;

    const content = notificationModal.querySelector('.notification-content');
    notificationTitle.textContent = notification.title;
    notificationMessage.innerHTML = notification.message;

    content.classList.remove('success', 'info');
    if (notification.type === 'success') {
        content.classList.add('success');
        notificationIcon.innerHTML = '&#127881;'; // 🎉
    } else {
        content.classList.add('info');
        notificationIcon.innerHTML = '&#128220;'; // 📌
    }
    
    notificationModal.classList.add('active');

    // 【修訂】只在 duration 有限且不是 Infinity 時才設定計時器
    if (notification.duration && notification.duration !== Infinity) {
        notificationTimer = setTimeout(() => {
            notificationModal.classList.remove('active');
            isNotificationActive = false;
            
            if (notification.callback) {
                notification.callback();
            }

            processNotificationQueue();
        }, notification.duration);
    } else {
        // 如果是持久通知 (duration = Infinity)，不設計時器，讓它持續顯示
        notificationTimer = null;
    }
}


            function closeCurrentNotification() {
    if (notificationTimer) {
        clearTimeout(notificationTimer);
        notificationTimer = null;
    }
    notificationModal.classList.remove('active');
    isNotificationActive = false;
    
    // 如果有回呼函式，也執行它
    if (currentNotificationObject && currentNotificationObject.callback) {
        currentNotificationObject.callback();
    }
    
    currentNotificationObject = null;
    processNotificationQueue(); // 繼續處理下一個通知（如果有）
}


// ================================================================
// ====== 【全新增】強制清理所有通知的函數 ======
// ================================================================
/**
 * 強制關閉並清空所有通知，解決UI覆蓋問題。
 */
function clearAllNotifications() {
    if (notificationTimer) {
        clearTimeout(notificationTimer);
    }
    notificationModal.classList.remove('active');
    isNotificationActive = false;
    notificationQueue = []; // 清空待辦隊列，防止舊通知再次弹出
    currentNotificationObject = null;
}
// ================================================================
// ====== 【新增結束】 ==============================================
// ================================================================

            
// 【修改後的版本】請用這段程式碼完整替換舊的 showNotification 函數

let notificationTimer = null;

function showNotification(type, title, message, duration = 5000, onCloseCallback = null) {
    // 步驟 1: 將通知任務（包含回呼函式）打包，添加到隊列的末尾
    notificationQueue.push({
        type: type,
        title: title,
        message: message,
        duration: duration,
        callback: onCloseCallback // 【新增】將回呼函式儲存起來
    });

    // 步驟 2: 呼叫我們的「經理」來處理隊列
    processNotificationQueue();
}

            

            // 為通知視窗的關閉按鈕添加點擊事件
           // 【修改後的樣子】
closeNotification.addEventListener('click', () => {
    if (notificationTimer) {
        clearTimeout(notificationTimer);
    }
    notificationModal.classList.remove('active');
    isNotificationActive = false;
    
    // 【新增】玩家手動關閉時，同樣檢查並執行回呼函式
    if (currentNotificationObject && currentNotificationObject.callback) {
        currentNotificationObject.callback();
    }
    
    processNotificationQueue();
});


            
            function updateSongOptions() {
                const selectedSong = musicSelect.value;
                const selectedDifficulty = difficultySelect.value;

                Array.from(musicSelect.options).forEach(option => {
                    const songUrl = option.value;
                    if (isSongUnlocked(songUrl)) {
                        option.disabled = false;
                        option.text = option.text.replace(' (未解鎖)', ''); // Remove unlock tag if present
                    } else {
                        option.disabled = true;
                        if (!option.text.includes('(未解鎖)')) {
                            option.text += ' (未解鎖)';
                        }
                    }
                });

                // Update difficulty options based on selected song
                updateDifficultyOptions(selectedSong);

                // Restore selection if it's still valid
                if (isSongUnlocked(selectedSong)) {
                    musicSelect.value = selectedSong;
                } else {
                    // Select the first unlocked song if current is locked
                    const firstUnlocked = saveData.unlockedSongs[0];
                    if (firstUnlocked) musicSelect.value = firstUnlocked;
                }
                if (!isDifficultyUnlocked(musicSelect.value, selectedDifficulty)) {
                    difficultySelect.value = 'normal'; // Default to normal if selected is locked
                }
            }

            function updateDifficultyOptions(songUrl) {
                const difficulties = ['easy', 'normal', 'hard', 'hell'];
                difficulties.forEach(diff => {
                    const option = difficultySelect.querySelector(`option[value="${diff}"]`);
                    if (isDifficultyUnlocked(songUrl, diff)) {
                        option.disabled = false;
                        option.text = option.text.replace(' (未解鎖)', '');
                    } else {
                        option.disabled = true;
                        if (!option.text.includes('(未解鎖)')) {
                            option.text += ' (未解鎖)';
                        }
                    }
                });
            }

            function updatePersonalHighScore(songUrl, difficulty, newScore) {
                 if (!saveData.personalHighScores[songUrl]) {
                    saveData.personalHighScores[songUrl] = {};
                 }
                 const currentHigh = saveData.personalHighScores[songUrl][difficulty] || 0;
                 if (newScore > currentHigh) {
                    saveData.personalHighScores[songUrl][difficulty] = newScore;
                    saveGame();
                 }
            }

            function populatePersonalHighScoreList(songUrl) {
                personalHighScoreList.innerHTML = '';
                const difficulties = ['easy', 'normal', 'hard', 'hell'];
                difficulties.forEach(diff => {
                    const li = document.createElement('li');
                    li.className = 'personal-high-score-item';

                    const labelSpan = document.createElement('span');
                    labelSpan.className = 'personal-high-score-label';
                    labelSpan.textContent = `${diff.toUpperCase()}:`;

                    const valueSpan = document.createElement('span');
                    valueSpan.className = 'personal-high-score-value';
                    const score = saveData.personalHighScores[songUrl] ? saveData.personalHighScores[songUrl][diff] : 0;
                    valueSpan.textContent = score ? score.toLocaleString() : '0';

                    li.appendChild(labelSpan);
                    li.appendChild(valueSpan);
                    personalHighScoreList.appendChild(li);
                });
            }

            function initGame() {
 
    tracksContainer.innerHTML = '';
    for (let i = 0; i < tracks; i++) {
        const track = document.createElement('div');
        track.className = 'track';
        track.dataset.track = i;
        const hitLine = document.createElement('div');
        hitLine.className = 'hit-line';
        track.appendChild(hitLine);
        const keyHint = document.createElement('div');
        keyHint.className = 'key-hint';
        keyHint.textContent = keys[i];
        track.appendChild(keyHint);
        tracksContainer.appendChild(track);
    }
                  setupParticlePools();
                setupFeedbackPools();
    score = 0;
    combo = 0;
    maxCombo = 0;
    // 新增：重設 pureHitScore 以確保每次遊戲開始時從0開始（避免累積BUG）
    pureHitScore = 0;
    notes = [];
    noteQueue = [];
    progressBar.style.width = '0%';
    updateUI();
    tracksContainer.className = 'tracks';
    const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
    if (isMobile) {
        document.getElementById('touchControls').style.display = 'flex';
        document.querySelectorAll('.key-hint').forEach(hint => hint.style.display = 'none');
    }
}

            function updateUI() {
                scoreDisplay.textContent = score;
            }

           function updateProgress() {
    if (gameActive && currentSongDuration > 0) {
        const elapsed = (Date.now() - gameStartTime) / 1000;
        const progress = Math.min(100, (elapsed / currentSongDuration) * 100);
        progressBar.style.width = `${progress}%`;

        // 新增：呼叫遊戲歌詞更新邏輯
        updateGameLyrics(elapsed);
    }
}

            // ==============================================================
// ====== 【新增】排行榜核心功能函數 ==========================
// ==============================================================

/**
 * 將歌曲文件名轉換為可用於 Firebase key 的安全字串
 * @param {string} filename - 例如 "白影.mp3"
 * @returns {string} - 例如 "白影_mp3"
 */
function sanitizeFirebaseKey(filename) {
    return filename.replace(/\./g, '_').replace(/[#$\[\]]/g, '');
}

/**
 * 檢查名稱是否包含髒話
 * @param {string} name - 要檢查的名稱
 * @returns {boolean} - 如果包含髒話則回傳 true
 */
function isProfane(name) {
    const lowerCaseName = name.toLowerCase();
    return profanityList.some(word => lowerCaseName.includes(word));
}

// ====================================================================
// ====== 【請用此函數完整替換舊的 handlePlayerName 函數】 ======
// ====================================================================
/**
 * 處理玩家名稱的設定與儲存（修訂後版本）
 * - 增加 Firebase 全域名稱唯一性檢查
 * - 修正了儲存後 UI 未正確鎖定的問題
 */
async function handlePlayerName() {
    // 步驟 1: 檢查 localStorage 中是否已存在名稱
    const existingPlayerName = localStorage.getItem('musicGamePlayerName') || '';

    // 情況 A: 名稱已存在，直接進入「顯示模式」
    if (existingPlayerName) {
        playerNameInput.value = existingPlayerName;
        playerNameInput.disabled = true; // 鎖定輸入框，不允許修改
        savePlayerNameBtn.style.display = 'none'; // 隱藏儲存按鈕

        // 讓輸入框填滿空間，使其看起來更像一個顯示標籤
        const playerNameGroup = document.getElementById('playerNameGroup');
        if (playerNameGroup) {
            playerNameInput.style.flexGrow = '1';
        }
        return; // 結束函數，因為不需要再綁定儲存事件
    }

    // 情況 B: 名稱不存在，進入「首次設定模式」
    // 清理並確保 UI 處於可編輯狀態
    playerNameInput.value = '';
    playerNameInput.disabled = false;
    savePlayerNameBtn.style.display = 'flex'; // 確保儲存按鈕可見
    savePlayerNameBtn.disabled = false;
    savePlayerNameBtn.classList.remove('loading'); // 移除可能的載入狀態
    savePlayerNameBtn.innerHTML = '✔'; // 恢復按鈕圖示

    // 提示玩家需要設定名稱
    showNotification('info', '設定名稱', '為了登上排行榜，請先設定你的專屬名稱！');

    // 為儲存按鈕綁定一次性的點擊事件
    savePlayerNameBtn.onclick = async () => {
        const newName = playerNameInput.value.trim();

        // 步驟 2: 前端基本驗證
        if (newName.length === 0) {
            showNotification('info', '名稱無效', '名稱不能為空！');
            return;
        }
        if (newName.length > 10) {
            showNotification('info', '名稱過長', '名稱長度不能超過 10 個字元。');
            return;
        }
        if (isProfane(newName)) {
            showNotification('info', '名稱不雅', '請勿使用不雅詞彙作為名稱。');
            return;
        }
        
        // 步驟 3: 與 Firebase 互動前，鎖定按鈕並顯示載入動畫
        savePlayerNameBtn.disabled = true;
        savePlayerNameBtn.classList.add('loading');

        try {
            // 步驟 4: 查詢 Firebase Database，檢查名稱是否已被佔用
            const nameRef = database.ref(`playerNames/${newName}`);
            const snapshot = await nameRef.once('value');

            if (snapshot.exists()) {
                // 情況 B-1: 名稱已存在
                showNotification('info', '名稱已被使用', `「<strong>${newName}</strong>」這個名稱已經被其他玩家使用了，請換一個吧！`);
                savePlayerNameBtn.disabled = false; // 重新啟用按鈕讓玩家重試
            } else {
                // 情況 B-2: 名稱可用，執行儲存操作
                
                // 使用原子更新來同時寫入，確保資料一致性
                const updates = {};
                updates[`/playerNames/${newName}`] = true; // 在中央名稱庫中註冊此名稱
                
                await database.ref().update(updates);

                // Firebase 寫入成功後，才更新本地狀態
                playerName = newName;
                localStorage.setItem('musicGamePlayerName', playerName);
                
                showNotification('success', '儲存成功', `你的新名稱「<strong>${playerName}</strong>」已成功設定！此後將無法更改。`);
                
                // 儲存成功後，立刻鎖定 UI
                playerNameInput.disabled = true;
                savePlayerNameBtn.style.display = 'none';
                 const playerNameGroup = document.getElementById('playerNameGroup');
                 if (playerNameGroup) {
                     playerNameInput.style.flexGrow = '1';
                 }
            }
        } catch (error) {
            console.error("儲存名稱時發生 Firebase 錯誤:", error);
            showNotification('info', '連線錯誤', '無法連接到伺服器，請檢查您的網路連線後再試。');
            savePlayerNameBtn.disabled = false; // 發生錯誤時，也要讓玩家可以重試
        } finally {
            // 無論成功或失敗，最後都要移除載入動畫
            savePlayerNameBtn.classList.remove('loading');
        }
    };
}

/**
 * 顯示對戰模式總排行榜 (增強版：同時顯示個人排名)
 */
async function displayBattleRankings() {
    battleRankingsLoading.style.display = 'block';
    battleRankingsList.innerHTML = '';
    myBattleRankDisplay.style.display = 'none'; // 先隱藏個人排名區

    // --- 任務 1: 獲取並顯示個人排名 ---
    if (playerId) {
        const myRankRef = database.ref('battleRankings/' + playerId);
        myRankRef.once('value').then(snapshot => {
            if (snapshot.exists()) {
                const myData = snapshot.val();
                myBattleRankDisplay.innerHTML = `
                    <span>你的積分: </span><strong>${myData.battleScore.toLocaleString()}</strong>
                `;
                myBattleRankDisplay.style.display = 'block'; // 找到數據後顯示
            }
        });
    }

    // --- 任務 2: 獲取並顯示 Top 10 排行榜 (與任務 1 並行) ---
    const rankingsRef = database.ref('battleRankings');
    try {
        const snapshot = await rankingsRef.orderByChild('battleScore').limitToLast(10).once('value');
        
        if (snapshot.exists()) {
            const rankingsData = [];
            snapshot.forEach(childSnapshot => {
                rankingsData.push({ id: childSnapshot.key, ...childSnapshot.val() });
            });

            rankingsData.reverse();

            battleRankingsList.innerHTML = '';
            rankingsData.forEach(player => {
                const li = document.createElement('li');
                li.className = 'battle-rank-item';
                // 如果上榜玩家是自己，給予一個特殊高亮 class
                if (player.id === playerId) {
                    li.classList.add('is-me');
                }
                li.innerHTML = `
                    <span class="battle-rank-name">${player.playerName}</span>
                    <span class="battle-rank-score">${player.battleScore.toLocaleString()} 分</span>
                `;
                battleRankingsList.appendChild(li);
            });

        } else {
            battleRankingsList.innerHTML = '<li><p style="text-align: center; color: #aaa;">排行榜尚無玩家，快來挑戰吧！</p></li>';
        }
    } catch (error) {
        console.error("讀取對戰排行榜失敗:", error);
        battleRankingsList.innerHTML = '<li><p style="text-align: center; color: #f00;">讀取失敗，請檢查網路連線。</p></li>';
    } finally {
        battleRankingsLoading.style.display = 'none';
    }
}

/**
 * 安全地更新玩家的對戰總分 (增強版：分數不為負)
 * @param {string} pId - 玩家的唯一 ID
 * @param {string} pName - 玩家的名稱
 * @param {number} scoreChange - 分數變化 (+1000, -500, or 0)
 */
function updateBattleScore(pId, pName, scoreChange) {
    if (!pId || scoreChange === 0) return;

    const playerRef = database.ref(`battleRankings/${pId}`);

    playerRef.transaction(currentData => {
        if (currentData === null) {
            // 如果玩家是第一次上榜，初始分數絕不為負
            return { playerName: pName, battleScore: Math.max(0, scoreChange) };
        } else {
            // 更新現有分數
            const newScore = currentData.battleScore + scoreChange;
            // 核心修改：確保新分數不會低於 0
            currentData.battleScore = Math.max(0, newScore);
            currentData.playerName = pName;
            return currentData;
        }
    }).catch(error => {
        console.error(`更新玩家 ${pName} 分數失敗:`, error);
    });
}

            
/**
 * 顯示指定歌曲與難度的排行榜
 * @param {string} songUrl - 歌曲的 URL
 * @param {string} difficulty - 難度
 */
function displayLeaderboard(songUrl, difficulty) {
    const songDisplayName = Array.from(musicSelect.options).find(opt => opt.value === songUrl)?.textContent || '未知歌曲';
    const difficultyDisplayName = difficultySelect.querySelector(`option[value="${difficulty}"]`).textContent;
    
    leaderboardTitle.textContent = `${songDisplayName} - ${difficultyDisplayName}`;
    leaderboardList.innerHTML = '';
    leaderboardLoading.style.display = 'block';

    const songId = sanitizeFirebaseKey(songUrl);
    const leaderboardRef = database.ref(`leaderboards/${songId}/${difficulty}`);

    leaderboardRef.once('value', (snapshot) => {
        leaderboardLoading.style.display = 'none';
        const data = snapshot.val();

        if (data && data.length > 0) {
            data.forEach((entry, index) => {
                const li = document.createElement('li');
                li.className = 'leaderboard-item';
                li.innerHTML = `
                    <span class="leaderboard-rank">#${index + 1}</span>
                    <span class="leaderboard-name">${entry.name}</span>
                    <span class="leaderboard-score">${entry.score.toLocaleString()}</span>
                `;
                leaderboardList.appendChild(li);
            });
        } else {
            leaderboardList.innerHTML = '<li><p style="text-align: center; color: #aaa;">這個排行榜還沒有人挑戰過，快來成為第一名！</p></li>';
        }
    });
}

// ====== 【修訂後】的排行榜分數提交函數 ======
async function submitScoreToLeaderboard(songUrl, difficulty, finalScore) {
    // 檢查玩家是否已設定名稱，若無則不執行
    if (!playerName) {
        console.log("玩家未設定名稱，不提交分數至排行榜。");
        return;
    }

    const songId = sanitizeFirebaseKey(songUrl);
    const leaderboardRef = database.ref(`leaderboards/${songId}/${difficulty}`);

    try {
        const { committed, snapshot } = await leaderboardRef.transaction((currentData) => {
            // 如果排行榜是空的，初始化為一個空陣列
            if (currentData === null) {
                currentData = [];
            }
            
            // 【核心修訂】直接尋找玩家本人是否已在榜上
            const selfIndex = currentData.findIndex(entry => entry.name === playerName);

            // 情況一：玩家已在排行榜上
            if (selfIndex !== -1) {
                // 只有當新分數更高時才更新
                if (finalScore > currentData[selfIndex].score) {
                    currentData[selfIndex].score = finalScore;
                } else {
                    // 如果新分數沒有更高，則不進行任何修改，直接中止 transaction
                    return; 
                }
            } 
            // 情況二：玩家不在排行榜上
            else {
                // 檢查分數是否足以登上排行榜（排行榜未滿 3 人，或分數高於榜上最低分）
                const lowestScoreOnBoard = currentData.length < 3 ? 0 : currentData[currentData.length - 1].score;
                if (finalScore > lowestScoreOnBoard) {
                    currentData.push({ name: playerName, score: finalScore });
                } else {
                    // 分數不夠高，中止 transaction
                    return;
                }
            }

            // 無論是更新還是新增，都重新排序並只保留前三名
            currentData.sort((a, b) => b.score - a.score);
            return currentData.slice(0, 3);
        });

        // 交易成功後，根據最終結果給予玩家通知
        if (committed) {
            const finalBoard = snapshot.val() || [];
            const onFinalBoard = finalBoard.some(entry => entry.name === playerName);
            
            if (onFinalBoard) {
                const difficultyText = difficultySelect.querySelector(`option[value="${difficulty}"]`).textContent;
                showNotification('success', '成功登上排行榜！', `恭喜！你在「<strong>${difficultyText}</strong>」難度的分數已成功登上排行榜！`);
            } else {
                showNotification('info', '再接再厲', '你的分數已成功提交，但未達到目前排行榜前三名的標準。');
            }
        } 
        // 交易因上述邏輯中止時，committed 會是 false，不會顯示任何通知，這是正常的

    } catch (error) {
        console.error("提交分數時發生錯誤: ", error);
        showNotification('info', '提交錯誤', '與伺服器連線時發生問題，請稍後再試。');
    }
}

            // --- Game Logic ---
            function generateNote(noteData) {
    if (!gameActive) return;
    const trackIndex = noteData.track;
    const track = document.querySelector(`.track[data-track="${trackIndex}"]`);
    if (!track) return;
    const note = document.createElement('div');
    note.className = noteData.type === 'long' ? 'long-note' : 'note';
    note.dataset.track = trackIndex;
    note.style.animationDuration = `${noteSpeed}ms`;
    if (noteData.type === 'long') {
        const noteHeight = (noteData.duration / (noteSpeed / 1000)) * (tracksContainer.clientHeight + 50);
        note.style.height = `${Math.max(30, noteHeight)}px`;
    }
    track.appendChild(note);
    const noteObj = {
        element: note,
        track: trackIndex,
        type: noteData.type,
        duration: noteData.duration || 0,
        active: true,
        hitStarted: false,
        // ▼▼▼ 【優化】記錄音符被創造時的精確時間戳 ▼▼▼
        creationTime: Date.now(),
        // ▲▲▲ 優化結束 ▲▲▲
    };
    notes.push(noteObj);
}

          // ▼▼▼ 【修訂後】使用物件池的 createHitParticles 函數 ▼▼▼
function createHitParticles(trackIndex, judgment) {
    const track = document.querySelector(`.track[data-track="${trackIndex}"]`);
    if (!track) return;

    // ▼▼▼ 【修訂】稍微減少各等級的粒子數量，以降低渲染負擔 ▼▼▼
const particleCount = (judgment === 'perfect') ? 12 : (judgment === 'great' ? 8 : 5);
    const maxOffset = (judgment === 'perfect') ? 100 : (judgment === 'great' ? 80 : 60);

    const colors = {
        perfect: '#ffcc00', great: '#00ccff', good: '#00ff99'
    };

    for (let i = 0; i < particleCount; i++) {
        // 從池中獲取一個粒子
        currentHitParticleIndex = (currentHitParticleIndex + 1) % PARTICLE_POOL_SIZE;
        const particle = hitParticlePool[currentHitParticleIndex];

        // 重設樣式並啟動動畫
        particle.style.background = colors[judgment] || '#fff';
        const size = Math.floor(8 + Math.random() * 8);
        particle.style.setProperty('--size', `${size}px`);
        const x = (Math.random() - 0.5) * maxOffset * 2;
        const y = (Math.random() * -maxOffset) - 20;
        particle.style.setProperty('--x', `${x}px`);
        particle.style.setProperty('--y', `${y}px`);
        const rot = Math.random() * 360;
        const rotEnd = rot + (Math.random() * 720 - 360);
        particle.style.setProperty('--rot', `${rot}deg`);
        particle.style.setProperty('--rot-end', `${rotEnd}deg`);
        particle.style.left = `calc(${track.offsetLeft}px + 50% - ${size / 2}px)`;
        
        // 移除舊的動畫類別，強制重啟動畫
        particle.classList.remove('animate');
        void particle.offsetWidth; // 強制瀏覽器重繪
        particle.classList.add('animate');
        
        // 使用 animationend 事件來回收粒子，比 setTimeout 更精準
        particle.onanimationend = () => {
            particle.classList.remove('animate');
            particle.onanimationend = null; // 清除事件監聽器
        };
    }
}

// ▼▼▼ 【修訂後】使用物件池的 explodeNote 函數 ▼▼▼
function explodeNote(noteElement, judgment) {
    if (!noteElement) return;

    const rect = noteElement.getBoundingClientRect();
    const trackRect = tracksContainer.getBoundingClientRect();
    const particleCount = (judgment === 'perfect') ? 15 : (judgment === 'great' ? 10 : 7); // 減少粒子數量
    const maxOffset = 80;

    const colors = {
        perfect: '#ffcc00', great: '#00ccff', good: '#00ff99'
    };

    for (let i = 0; i < particleCount; i++) {
        // 從池中獲取一個粒子
        currentNoteParticleIndex = (currentNoteParticleIndex + 1) % PARTICLE_POOL_SIZE;
        const particle = noteParticlePool[currentNoteParticleIndex];

        particle.style.background = colors[judgment] || '#fff';
        const size = Math.floor(4 + Math.random() * 9);
        particle.style.setProperty('--size', `${size}px`);
        const x = (Math.random() - 0.5) * maxOffset * 2;
        const y = (Math.random() - 0.5) * maxOffset * 2;
        particle.style.setProperty('--x', `${x}px`);
        particle.style.setProperty('--y', `${y}px`);
        const rot = Math.random() * 360;
        const rotEnd = rot + (Math.random() * 720 - 360);
        particle.style.setProperty('--rot', `${rot}deg`);
        particle.style.setProperty('--rot-end', `${rotEnd}deg`);
        particle.style.left = `${rect.left - trackRect.left + rect.width / 2 - size / 2}px`;
        particle.style.top = `${rect.top - trackRect.top + rect.height / 2 - size / 2}px`;

        particle.classList.remove('animate');
        void particle.offsetWidth;
        particle.classList.add('animate');

        particle.onanimationend = () => {
            particle.classList.remove('animate');
            particle.onanimationend = null;
        };
    }
}



            

     function judgeHit(trackIndex, type) {
                const track = document.querySelector(`.track[data-track="${trackIndex}"]`);
                if (sounds[type]) {
                    sounds[type]();
                }

                // 創建並顯示判定文字 (Perfect, Great, etc.)
                currentJudgmentIndex = (currentJudgmentIndex + 1) % judgmentPool.length;
    const judgment = judgmentPool[currentJudgmentIndex];
    judgment.className = `judgment ${type}`; // 重新設定 class 來觸發動畫
                judgment.textContent = `${type.toUpperCase()}!`;
                if (track) {
                    track.appendChild(judgment);
                    judgment.style.left = '0';
                    judgment.style.width = '100%';
                    judgment.style.textAlign = 'center';

                }

 // ▼▼▼ 【優化】使用 animationend 事件來回收，比 setTimeout 更精準 ▼▼▼
    judgment.style.opacity = '1'; // 讓它可見
    judgment.onanimationend = () => {
        judgment.style.opacity = '0'; // 動畫結束後隱藏，等待下次使用
        judgment.onanimationend = null; // 清除監聽器，避免重複觸發
    };

         
               

                // 處理非 'miss' 的成功打擊
                if (type !== 'miss') {
                    // 觸發粒子效果
                    createHitParticles(trackIndex, type);

                    // 觸發打擊線的脈衝動畫
                    const hitLine = track.querySelector('.hit-line');
                    if (hitLine) {
                        hitLine.classList.remove('pulse-effect');
                        void hitLine.offsetWidth; // 強制瀏覽器重繪
                        hitLine.classList.add('pulse-effect');
                    }

                    // 根據判定等級觸發不同的軌道閃光效果
                    if (track) {
                        track.classList.remove('flash-perfect', 'flash-great', 'flash-good');
                        void track.offsetWidth;
                        if (type === 'perfect') {
                            track.classList.add('flash-perfect');
                        } else if (type === 'great') {
                            track.classList.add('flash-great');
                        } else if (type === 'good') {
                            track.classList.add('flash-good');
                        }
                    }

                    // 觸發裝置震動回饋
                    if (navigator.vibrate) {
                        let vibrationPattern;
                        if (type === 'perfect') {
                            vibrationPattern = [55]; // 短促有力的震動
                        } else if (type === 'great') {
                            vibrationPattern = [55]; // 中等震動
                        } else if (type === 'good') {
                            vibrationPattern = [50]; // 輕微震動
                        }
                        if (vibrationPattern) {
                            navigator.vibrate(vibrationPattern);
                        }
                    }

                   // 【關鍵修復 1】在這裡根據判定類型，定義 baseScore 的值
let baseScore = 0;
if (type === 'perfect') baseScore = 100;
else if (type === 'great') baseScore = 70;
else if (type === 'good') baseScore = 40;
                    
                    // 【關鍵修復 2】將 addScore 移到這裡，確保無論裝置是否支援震動，都會計分
                    addScore(baseScore);

                } else {
                    // 處理 'miss' 的情況
                    combo = 0;
                    const difficulty = getCurrentDifficulty();
                    trackCooldownUntil[trackIndex] = Date.now() + difficulty.cooldown;
                }

                updateUI();
            }

// 請將這個新函數，加在 addScore 函數的上面
function sendScoreUpdate() {
    if (!isScoreDirty || gameMode !== 'online' || !currentRoomId) {
        return;
    }
    const playerKey = isHost ? 'player1' : 'player2';
    database.ref(`rooms/${currentRoomId}/${playerKey}/score`).set(score);
    isScoreDirty = false; // 發送後，重設標記
}

            

          function addScore(baseScore) {
    combo++;
    if (combo > maxCombo) maxCombo = combo;
    
    pureHitScore += baseScore;
    score += baseScore + Math.floor(baseScore * (Math.floor(combo / 10) * 0.1)); 

    // ▼▼▼ 【修訂】請用這段程式碼，取代舊的 if (gameMode === 'online'...) 判斷式 ▼▼▼
    if (gameMode === 'online') {
        isScoreDirty = true;
        // 如果目前沒有排程中的更新，就安排一個
        if (!scoreUpdateTimeout) {
            scoreUpdateTimeout = setTimeout(() => {
                sendScoreUpdate();
                scoreUpdateTimeout = null; // 完成後清除 ID，允許下一次排程
            }, 250); // 每 250 毫秒最多發送一次
        }
    }
    // ▲▲▲ 修訂結束 ▲▲▲

    if (combo > 5) {
        currentComboIndex = (currentComboIndex + 1) % comboPool.length;
        const comboEl = comboPool[currentComboIndex];
        comboEl.className = 'combo-display';
        comboEl.textContent = `${combo} COMBO!`;
        if (combo >= 1000) comboEl.classList.add('combo-rainbow');
        else if (combo >= 500) comboEl.classList.add('combo-purple');
        else if (combo >= 200) comboEl.classList.add('combo-pink');
        else if (combo >= 100) comboEl.classList.add('combo-orange');
        else if (combo >= 50) comboEl.classList.add('combo-blue');
        else comboEl.classList.add('combo-base');
        tracksContainer.appendChild(comboEl);
        if (sounds.combo) sounds.combo();

        comboEl.style.opacity = '1';
        comboEl.onanimationend = () => {
            comboEl.style.opacity = '0';
            comboEl.onanimationend = null;
        };
    }
    
    let trackComboClass = '';
    if (combo >= 1000) trackComboClass = 'combo-rainbow';
    else if (combo >= 500) trackComboClass = 'combo-purple';
    else if (combo >= 200) trackComboClass = 'combo-pink';
    else if (combo >= 100) trackComboClass = 'combo-orange';
    else if (combo >= 50) trackComboClass = 'combo-blue';
    tracksContainer.className = 'tracks';
    if (trackComboClass) tracksContainer.classList.add(trackComboClass);
    
    updateUnlockMeter();
}

 // ▼▼▼ 新增的函數 ▼▼▼
           // ▼▼▼ 修正後的函數 ▼▼▼
function updateUnlockMeter() {
                if (maxScoreForCurrentLevel <= 0) return; // 避免除以零的錯誤
                
                // 【核心修正】進度條的百分比應基於不含 COMBO 的純粹分數（pureHitScore）來計算
                const currentPercent = Math.min(100, (pureHitScore / maxScoreForCurrentLevel) * 100);
                
                unlockProgressBar.style.width = `${currentPercent}%`;

                // 檢查是否超過了任一條解鎖線，如果超過則添加發光效果
                const hasReachedSongUnlock = currentPercent >= SONG_UNLOCK_PERCENTAGE * 100;
                const hasReachedDifficultyUnlock = currentPercent >= DIFFICULTY_UNLOCK_PERCENTAGE * 100;
                
                if (hasReachedSongUnlock || hasReachedDifficultyUnlock) {
                    unlockProgressBar.classList.add('glowing');
                } else {
                    unlockProgressBar.classList.remove('glowing');
                }
            }
            // ▲▲▲ 新增結束 ▲▲▲

            async function getAudioDuration(src) {
                return new Promise((resolve) => {
                    const tempAudio = new Audio(src);
                    tempAudio.addEventListener('loadedmetadata', () => resolve(tempAudio.duration));
                    tempAudio.addEventListener('error', () => resolve(120));
                });
            }

            async function analyzeAudioForBeats(url) {
                try {
                    const response = await fetch(url);
                    const arrayBuffer = await response.arrayBuffer();
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    const channelData = audioBuffer.getChannelData(0);
                    const sampleRate = audioBuffer.sampleRate;
                    const beats = [];
                    const bufferSize = 1024;
                    const historySize = 43;
                    const C = 1.3;
                    const energyHistory = []; // <-- [修訂] 新增這一行


                    
                    const getEnergy = (buffer) => {
                        let sum = 0;
                        for (let i = 0; i < buffer.length; i++) {
                            sum += buffer[i] * buffer[i];
                        }
                        return Math.sqrt(sum / buffer.length);
                    };
                    for (let i = 0; i < channelData.length; i += bufferSize) {
                        const buffer = channelData.slice(i, i + bufferSize);
                        const currentEnergy = getEnergy(buffer);
                        let averageEnergy = energyHistory.length > 0 ?
                            energyHistory.reduce((a, b) => a + b, 0) / energyHistory.length : 0;
                        if (currentEnergy > averageEnergy * C) {
                            const beatTime = i / sampleRate;
                            if (beats.length === 0 || beatTime > beats[beats.length - 1] + 0.2) {
                                beats.push(beatTime);
                            }
                        }
                        energyHistory.push(currentEnergy);
                        if (energyHistory.length > historySize) {
                            energyHistory.shift();
                        }
                    }
                    console.log(`偵測到 ${beats.length} 個節拍。`);
                    return beats;
                } catch (error) {
                    console.error("音訊分析失敗（可能是 CORS 跨域問題）:", error);
                    return [];
                }
            }

            function getCurrentDifficulty() {
                return difficultySettings[difficultySelect.value] || difficultySettings.normal;
            }


// 新增輔助函數：分析節拍間隔，估算基本時間單位（如十六分音符長度）
function analyzeBeatIntervals(beatTimestamps) {
    if (!beatTimestamps || beatTimestamps.length < 2) {
        console.warn("節拍數據不足，無法分析。");
        return { baseInterval: 0.5 }; // 返回一個默認值
    }

    const intervals = [];
    for (let i = 1; i < beatTimestamps.length; i++) {
        // 計算相鄰節拍之間的時間差
        const interval = beatTimestamps[i] - beatTimestamps[i - 1];
        // 過濾掉過於短或過於長的異常值（可選，根據實際數據調整）
        if (interval > 0.05 && interval < 5.0) {
             intervals.push(interval);
        }
    }

    if (intervals.length === 0) {
        console.warn("無有效節拍間隔數據。");
        return { baseInterval: 0.5 };
    }

    // 簡單方法：假設最小間隔對應於最短的音符（如十六分音符）
    // 更複雜的方法可以統計間隔的分佈，找出基頻
    const minInterval = Math.min(...intervals);
    // 四分音符間隔通常是這個最小間隔的倍數 (e.g., 4倍)
    // 我們可以估算一個基準間隔，這裡簡化為直接使用最小間隔或其一部分作為十六分音符長度
    // 假設最小間隔是十六分音符 (1/16) 的長度
    const baseInterval = minInterval; // 這代表 1/16 音符的長度

    console.log(`分析得出的基準間隔 (估計1/16音符長度): ${baseInterval.toFixed(3)} 秒`);
    return { baseInterval };
}


           // ▼▼▼ [新增] PRNG 函數 (確保這段代碼存在於你的腳本中) ▼▼▼
// Mulberry32 PRNG - https://gist.github.com/tommyettinger/46a874533244883189143505d203312c
function mulberry32(a) {
    return function() {
        a |= 0; a = a + 0x6D2B79F5 | 0;
        var t = Math.imul(a ^ a >>> 15, 1 | a);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
}
// ▲▲▲ [新增結束] ▲▲▲


function generateSongData(duration, difficulty, beatTimestamps, seed = 12345, noteSpeed) {
    console.log(`Generating notes with seed: ${seed}`);
    const seededRandom = mulberry32(seed);
    const tracks = 4;

    // --- 空間衛兵設定 ---
    const totalFallDistance = tracksContainer.clientHeight + 50;
    const pixelsPerSecond = totalFallDistance / (noteSpeed / 1000);
    const SHORT_NOTE_SAFE_HEIGHT = 40 + 10; // 【修訂】為短音符增加額外 10px 緩衝，防止視覺重疊
    const MIN_LONG_NOTE_SAFE_HEIGHT = 50;
    const VISUAL_COMFORT_GAP = difficulty.visualGap || 50;
    
    const data = [];
    // 空間衛兵：追蹤每個軌道在物理像素上的可用位置
    const trackFreeAtPixel = new Array(tracks).fill(0);
    
    // 時間衛兵：追蹤每個軌道在音樂時間上的可用時間點
    const trackFreeAtTime = new Array(tracks).fill(0);

    const baseIntervalAnalysis = analyzeBeatIntervals(beatTimestamps);
    const baseInterval = baseIntervalAnalysis.baseInterval;

    const rhythmPatterns = [
        { name: "十六分音符", duration: baseInterval, weight: 0.70 },
        { name: "三十二分音符", duration: baseInterval / 2, weight: 0.30 }
    ];
    const noteGenerationTypes = [
        { type: 'short', weight: 0.75 },
        { type: 'long', weight: 0.25 }
    ];

    const totalRhythmWeight = rhythmPatterns.reduce((sum, p) => sum + p.weight, 0);
    const totalTypeWeight = noteGenerationTypes.reduce((sum, t) => sum + t.weight, 0);

    let currentTime = 5.0;

    while (currentTime < duration - (2.0 + (noteSpeed / 1000))) {
        let randomRhythm = seededRandom() * totalRhythmWeight;
        let selectedRhythm = rhythmPatterns[0];
        for (const pattern of rhythmPatterns) {
            randomRhythm -= pattern.weight;
            if (randomRhythm <= 0) {
                selectedRhythm = pattern;
                break;
            }
        }
        const stepDuration = selectedRhythm.duration;

        // 【修訂】在遊戲開始前5秒，降低密度 20% 以減少密集生成
        let effectiveDensity = difficulty.noteDensity;
        if (currentTime < 5) {
            effectiveDensity *= 0.8; // 降低 20%
        }

        if (seededRandom() < effectiveDensity) {
            const availableTracks = [];
            for (let i = 0; i < tracks; i++) {
                availableTracks.push(i);
            }

            if (availableTracks.length > 0) {
                const trackIndex = availableTracks[Math.floor(seededRandom() * availableTracks.length)];

                const newNoteStartPixel = currentTime * pixelsPerSecond;
                // 【修訂】加強檢查：增加最小時間間隙 0.1 秒
                if (currentTime >= trackFreeAtTime[trackIndex] + 0.1 && newNoteStartPixel >= trackFreeAtPixel[trackIndex]) {

                    // 【修訂】在開始前5秒，降低長音符機率 50%
                    let effectiveLongWeight = 0.25;
                    if (currentTime < 5) {
                        effectiveLongWeight *= 0.5;
                    }
                    let randomType = seededRandom() * (0.75 + effectiveLongWeight); // 調整總權重
                    let selectedType = { type: 'short' };
                    if (randomType > 0.75) {
                        selectedType = { type: 'long' };
                    }

                    let finalNoteDuration = 0;
                    if (selectedType.type === 'long') {
                        const minMultiplier = difficulty.longNoteMinMultiplier || 2;
                        const maxMultiplier = difficulty.longNoteMaxMultiplier || 6;
                        const randomMultiplier = minMultiplier + seededRandom() * (maxMultiplier - minMultiplier);
                        finalNoteDuration = Math.min(baseInterval * randomMultiplier, 2.0);
                    }
                    
                    data.push({
                        time: currentTime,
                        track: trackIndex,
                        type: finalNoteDuration > 0 ? 'long' : 'short',
                        duration: finalNoteDuration
                    });

                    // --- 更新兩個衛兵的狀態 ---
                    
                    // 1. 更新空間衛兵
                    let currentNoteSafeHeight = (finalNoteDuration > 0)
                        ? Math.max(MIN_LONG_NOTE_SAFE_HEIGHT, finalNoteDuration * pixelsPerSecond)
                        : SHORT_NOTE_SAFE_HEIGHT;
                    trackFreeAtPixel[trackIndex] = newNoteStartPixel + currentNoteSafeHeight + VISUAL_COMFORT_GAP;

                    // 【修訂】更新時間衛兵，並為長音符後添加額外 0.2 秒冷卻
                    if (finalNoteDuration > 0) {
                        trackFreeAtTime[trackIndex] = currentTime + finalNoteDuration + 0.2; // 額外冷卻
                    } else {
                        trackFreeAtTime[trackIndex] = currentTime + stepDuration;
                    }
                }
            }
        }
        currentTime += stepDuration;
    }
    return data.sort((a, b) => a.time - b.time);
}

            function generateNotesContinuously() {
                if (!gameActive) return;
                const currentTime = (Date.now() - gameStartTime) / 1000;
                while (noteQueue.length > 0 && noteQueue[0].time < currentTime + (noteSpeed / 1000)) {
                    const noteData = noteQueue.shift();
                    if (trackCooldownUntil[noteData.track] > Date.now()) {
                        continue;
                    }
                    generateNote(noteData);
                }
                if (gameActive) {
                    generateNotesTimer = setTimeout(generateNotesContinuously, 50);
                }
            }


            // ▼▼▼ 【新增】所有與歌詞測驗相關的新函數 ▼▼▼

/**
 * 根據歌曲 URL 生成填充題
 * @param {string} songUrl - 歌曲的檔案名稱
 * @returns {Array} - 一個包含問題物件的陣列
 */
function generateQuizQuestions(songUrl) {
    const songLyricsForQuiz = songLyrics[songUrl];
    if (!songLyricsForQuiz || songLyricsForQuiz.length === 0) {
        return []; // 如果這首歌沒有歌詞，返回空陣列
    }

    const generatedQuestions = [];
    const usedLines = new Set(); // 確保不會重複使用同一句歌詞

    // 嘗試從歌詞中生成最多 10 個獨特的問題
    while (generatedQuestions.length < 10 && usedLines.size < songLyricsForQuiz.length) {
        let randomIndex;
        do {
            randomIndex = Math.floor(Math.random() * songLyricsForQuiz.length);
        } while (usedLines.has(randomIndex));
        
        const line = songLyricsForQuiz[randomIndex].text;
        usedLines.add(randomIndex);

        // 使用正則表達式找出歌詞中 2 到 4 個字的中文詞語作為答案選項
        const words = line.match(/[\u4e00-\u9fa5]{2,4}/g) || [];

        if (words.length > 0) {
            // 從找到的詞語中隨機選一個作為答案
            const answer = words[Math.floor(Math.random() * words.length)];
            const questionText = line.replace(answer, '____');
            
            // 確保問題已成功生成（替換前後文本不同）
            if (questionText !== line) {
                 generatedQuestions.push({
                    question: questionText,
                    answer: answer
                });
            }
        }
    }
    
    // 如果無法生成任何問題（例如歌詞太短），則創建一個備用問題
    if (generatedQuestions.length === 0 && songLyricsForQuiz.length > 0) {
         const fallbackLine = songLyricsForQuiz[0].text;
         if (fallbackLine.length > 2) {
             const answer = fallbackLine.substring(0, 2);
             const question = '____' + fallbackLine.substring(2);
             generatedQuestions.push({ question, answer });
         }
    }
    
    return generatedQuestions;
}

/**
 * 輔助函數：Fisher-Yates 洗牌演算法，用於打亂題庫順序
 * @param {Array} array - 要打亂的陣列
 * @returns {Array} - 打亂後的陣列
 */
function shuffleArray(array) {
    let currentIndex = array.length, randomIndex;
    while (currentIndex !== 0) {
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex--;
        [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
    }
    return array;
}

function startLyricsQuiz(rewards, songUrlForQuiz) {
    const predefinedQuestions = songData[songUrlForQuiz]?.quiz || [];

    if (predefinedQuestions.length === 0) {
        // 這個檢查理論上在 processPostGameRewards 中已經做過，但作為安全備用
        console.warn(`歌曲 ${songUrlForQuiz} 沒有預設題目，自動授予獎勵。`);
        grantAllRewards(rewards);
        return;
    }
    
    const shuffledPool = shuffleArray([...predefinedQuestions]);
    quizQuestions = shuffledPool.slice(0, 5);
    totalQuestionsInQuiz = quizQuestions.length;

    if (totalQuestionsInQuiz === 0) {
        grantAllRewards(rewards);
        return;
    }
    
    isQuizActive = true;
    quizRewardsQueue = rewards; // 【修改】儲存整個獎勵佇列
    questionsAnsweredCorrectly = 0;
    
    lyricsQuizModal.classList.add('active');
    displayNextQuizQuestion();
}
/**
 * 顯示下一個測驗問題
 */
function displayNextQuizQuestion() {
    // 如果題庫已空，代表全部答對
    if (quizQuestions.length === 0) {
        endQuiz(true); 
        return;
    }
    
    // 從題庫中取出下一題
    currentQuizQuestion = quizQuestions.pop();

    // ▼▼▼ 【核心修訂】將底線替換為帶有 class 的 span 元素 ▼▼▼
    const questionLine = currentQuizQuestion.line.replace(/__/g, '<span class="quiz-blank"></span>');
    quizQuestionText.innerHTML = questionLine;
    // ▲▲▲ 修訂結束 ▲▲▲

    quizProgress.textContent = `進度: ${questionsAnsweredCorrectly} / ${totalQuestionsInQuiz}`;
    quizAnswerInput.value = '';
    quizAnswerInput.classList.remove('correct', 'incorrect');
    quizAnswerInput.disabled = false;
    quizSubmitBtn.disabled = false;
    quizAnswerInput.focus();
}
/**
 * 檢查玩家提交的答案
 */
function checkQuizAnswer() {
    if (!isQuizActive || !currentQuizQuestion) return;

    const userAnswer = quizAnswerInput.value.trim();
    const correctAnswer = currentQuizQuestion.answer;

    quizAnswerInput.disabled = true;
    quizSubmitBtn.disabled = true;

    if (userAnswer === correctAnswer) {
        questionsAnsweredCorrectly++;
        quizAnswerInput.classList.add('correct');
        quizProgress.textContent = `進度: ${questionsAnsweredCorrectly} / ${totalQuestionsInQuiz}`;
        
        // 答對後，延遲一小段時間再進入下一題
        setTimeout(displayNextQuizQuestion, 800);
    } else {
        // 【核心規則】答錯，立即結束測驗並判定失敗
        quizAnswerInput.classList.add('incorrect');
        setTimeout(() => endQuiz(false), 1200); 
    }
}


function endQuiz(success) {
    if (!isQuizActive) return;

    isQuizActive = false;
    lyricsQuizModal.classList.remove('active');

    if (success) {
        // 成功邏輯保持不變
        const rewardsToGrant = [...quizRewardsQueue];
        if (rewardsToGrant.length > 0) {
             showNotification('success', '測驗通過！', '恭喜您通過歌詞測驗，所有獎勵正在發放中！');
             grantAllRewards(rewardsToGrant);
        }
    } else {
        // 【核心修改】根據失敗的目標類型，顯示不同的通知
        const wasTryingForLeaderboard = quizRewardsQueue.some(reward => reward.type === 'leaderboard');

        if (wasTryingForLeaderboard) {
            showNotification('info', '排行榜挑戰失敗', '歌詞測驗未通過，本次無法登上排行榜。下次請再接再厲！');
        } else {
            showNotification('info', '解鎖失敗', '歌詞測驗未通過，無法解鎖新內容。下次請再接再厲！');
        }
    }

    // 清空佇列和狀態
    quizRewardsQueue = [];
    quizQuestions = [];
    currentQuizQuestion = null;
    questionsAnsweredCorrectly = 0;
    totalQuestionsInQuiz = 0;
}



            



// ▼▼▼ 請將此函數完整複製，並替換掉您現有的 updateGameLyrics 函數 ▼▼▼
function updateGameLyrics(currentTime) {
    const selectedSong = musicSelect.value;
    const lyrics = songData[selectedSong]?.lyrics || [];
    const verticalLyricElement = document.getElementById('game-lyric-text');

    if (!verticalLyricElement) return; // 如果找不到元素，直接退出

    // 如果這首歌沒有歌詞，就清空文字
    if (lyrics.length === 0) {
        verticalLyricElement.textContent = '';
        return;
    }

    // 找出當前應該顯示哪一句歌詞
    let currentIndex = -1;
    for (let i = 0; i < lyrics.length; i++) {
        if (lyrics[i].time <= currentTime) {
            currentIndex = i;
        } else {
            break;
        }
    }
    const currentLyricText = (currentIndex >= 0) ? lyrics[currentIndex].text : '';

    // 將找到的歌詞文字，更新到我們的垂直歌詞元素中
    verticalLyricElement.textContent = currentLyricText;
}


/**
 * 處理遊戲開始前的倒數計時
 */
function handleCountdown() {
    // 如果遊戲已啟動或倒數已在進行中，則不重複執行
    if (gameActive || document.getElementById('countdown-overlay').style.display === 'flex') return;

    clearAllNotifications();
    const countdownOverlay = document.getElementById('countdown-overlay');
    
    // 鎖定開始按鈕，防止在倒數時誤觸
    startBtn.disabled = true;

    // 開始倒數
    countdownOverlay.style.display = 'flex';
    let count = 3;
    countdownOverlay.textContent = count;

    const countdownInterval = setInterval(() => {
        count--;
        if (count > 0) {
            countdownOverlay.textContent = count;
        } else {
            clearInterval(countdownInterval);
            countdownOverlay.textContent = '開始!';

            // 顯示 "開始!" 一小段時間後，隱藏畫面並同時啟動雙方遊戲
            setTimeout(() => {
                countdownOverlay.style.display = 'none';
                // 這個 startGame() 是真正啟動遊戲畫面和邏輯的函數
                startGame(); 
            }, 500);
        }
    }, 1000);
}

            
// ====================================================================
// ====== 【第一步：簡化 startGame 函數，專注於啟動遊戲】 ======
// ====================================================================
/**
 * 實際啟動遊戲畫面與邏輯 (不再處理線上模式的信號發送)
 */
async function startGame() {
    // 遊戲啟動前的最終檢查
    if (gameActive) return;

    clearAllNotifications();

    const selectedSong = musicSelect.value;
    const selectedDifficulty = difficultySelect.value;
    
    // 單機模式下的解鎖檢查
    if (gameMode === 'single') {
        if (!isSongUnlocked(selectedSong) || !isDifficultyUnlocked(selectedSong, selectedDifficulty)) {
            showNotification('info', '項目未解鎖', '此歌曲或難度尚未解鎖。');
            return;
        }
    }
    
    // ▼▼▼ 【修訂】根據遊戲模式添加/移除 class ▼▼▼
    if (gameMode === 'online') {
        mainGameContainer.classList.add('online-mode');
    } else {
        mainGameContainer.classList.remove('online-mode');
    }
    // ▲▲▲ 修訂結束 ▲▲▲

    gameActive = true;
    console.log("--- Game is now starting ---");

    startBtn.disabled = true;
    musicSelect.disabled = true;
    difficultySelect.disabled = true;
    mainGameContainer.classList.add('game-running'); 
    unlockProgressBar.style.height = '100%';
    unlockProgressBar.style.width = '0%';
    unlockProgressBar.classList.remove('glowing');
    songUnlockMarker.style.left = `${SONG_UNLOCK_PERCENTAGE * 100}%`;
    difficultyUnlockMarker.style.left = `${DIFFICULTY_UNLOCK_PERCENTAGE * 100}%`;
    startBtn.innerHTML = `<svg class="start-button-svg" viewBox="0 0 40 40" style="width:40px;height:40px;"><circle cx="20" cy="20" r="18" stroke="#ff8a00" stroke-width="3" fill="none" stroke-dasharray="89" stroke-dashoffset="20"><animateTransform attributeName="transform" type="rotate" from="0 20 20" to="360 20 20" dur="1s" repeatCount="indefinite" /></circle></svg>`;
    
    const difficulty = getCurrentDifficulty();
    const beatTimestamps = await analyzeAudioForBeats(selectedSong);
    startBtn.innerHTML = originalStartButtonSVG;

    progressContainerDiv.style.display = 'block';
    trackCooldownUntil.fill(0); 
    audio.src = selectedSong;
    audio.volume = volumeControlModal.value;
    currentSongDuration = await getAudioDuration(selectedSong);
    noteSpeed = Math.floor(4000 / difficulty.speedMultiplier);

    const songAndDifficultyString = selectedSong + selectedDifficulty;
    let seed = 0;
    for (let i = 0; i < songAndDifficultyString.length; i++) {
        const char = songAndDifficultyString.charCodeAt(i);
        seed = ((seed << 5) - seed) + char;
        seed |= 0;
    }
    seed = Math.abs(seed) || 1;
    
    noteQueue = generateSongData(currentSongDuration, difficulty, beatTimestamps, seed, noteSpeed);
    const maxBaseScorePerNote = 100;
    maxScoreForCurrentLevel = noteQueue.length * maxBaseScorePerNote;
    if (maxScoreForCurrentLevel === 0) {
        maxScoreForCurrentLevel = 300000;
    }
    
    const onAudioPlay = () => {
        gameStartTime = Date.now();
        generateNotesContinuously();
        gameLoop();
        progressInterval = setInterval(updateProgress, 100);
        audio.removeEventListener('play', onAudioPlay);
    };

    audio.addEventListener('play', onAudioPlay);
    
    audio.play().catch(e => {
        console.log("音訊播放失敗:", e);
        audio.removeEventListener('play', onAudioPlay);
        gameActive = false;
    });

    setTimeout(() => { if (gameActive) endGame(); }, currentSongDuration * 1000 + 2000);
}


            // ====================================================================
// ====== 【第二步：創建全新的統一按鈕處理函數】 ======
// ====================================================================
/**
 * 處理「開始/準備」按鈕的點擊事件
 */
function handleStartButtonClick() {
    // 情況一：單機模式，直接開始遊戲
    if (gameMode === 'single') {
        startGame();
        return;
    }

    // 情況二：線上對戰模式
    if (gameMode === 'online' && currentRoomId) {
        const roomRef = database.ref('rooms/' + currentRoomId);
        roomRef.get().then(snapshot => {
            if (!snapshot.exists()) return;
            const roomData = snapshot.val();
            const playerKey = isHost ? 'player1' : 'player2';

            // 根據遊戲狀態決定按鈕功能
            if (roomData.gameState === 'selecting_song') {
                // 此時是選歌方點擊，發送「選歌並準備」信號
                const selectedSong = musicSelect.value;
                const selectedDifficulty = difficultySelect.value;
                
                if (!isSongUnlocked(selectedSong) || !isDifficultyUnlocked(selectedSong, selectedDifficulty)) {
                    showNotification('info', '項目未解鎖', '你不能選擇尚未解鎖的歌曲或難度進行對戰。');
                    return;
                }
                
                roomRef.update({
                    selectedSong: selectedSong,
                    selectedDifficulty: selectedDifficulty,
                    gameState: 'readying_up',
                    [playerKey + '/isReady']: true
                });

            } else if (roomData.gameState === 'readying_up') {
                // 此時是非選歌方點擊，發送「我已準備」信號
                roomRef.child(playerKey).update({ isReady: true });
            }
        });
    }
}

            
            // ====================================================================
// ====== 【第二步：新增 handleReadyUpState 函數】 ======
// ====================================================================
/**
 * 處理線上對戰的「準備」階段
 * @param {object} roomData - 從 Firebase 獲取的房間資料
 */
function handleReadyUpState(roomData) {
    if (gameActive) return; // 遊戲已開始，則忽略

    const playerKey = isHost ? 'player1' : 'player2';
    
    // 更新並鎖定歌曲和難度選擇器，讓雙方看到一致的資訊
    musicSelect.value = roomData.selectedSong;
    difficultySelect.value = roomData.selectedDifficulty;
    musicSelect.disabled = true;
    difficultySelect.disabled = true;

    if (roomData[playerKey].isReady) {
        // 如果「我」已經點擊過準備，則禁用按鈕並顯示等待提示
        startBtn.disabled = true;
    
    } else {
        // 如果「我」還沒準備，表示我是需要確認的一方
        showNotification('info', '確認對戰', '對手已選擇歌曲，請點擊「開始」對戰！');
        
        // 將開始按鈕變為「準備」按鈕
        startBtn.disabled = false;
        // 為了簡單起見，我們直接修改按鈕的點擊事件
        startBtn.onclick = () => {
            database.ref(`rooms/${currentRoomId}/${playerKey}/isReady`).set(true);
            startBtn.disabled = true; // 點擊後禁用，防止重複發送
        };
    }
}

 // ====================================================================
// ====== 【第四步：確保 resetToMainMenu 函數的完整性】 ======
// ====================================================================
/**
 * 重置所有狀態回到主菜單 (修訂版)
 */
function resetToMainMenu() {
    clearAllNotifications();

    if (roomListener && currentRoomId) {
        database.ref('rooms/' + currentRoomId).off('value', roomListener);
    }
    
    gameActive = false;
    gameMode = 'single';
    currentRoomId = null;
    isHost = false;
    roomListener = null;
      isBattleQuizActive = false; // <-- 在這裡加入
    
    // 恢復UI
    opponentStats.style.display = 'none';
    restartBtnSingle.style.display = 'block';
    onlineRematchControls.style.display = 'none';
    startBtn.disabled = false;
    musicSelect.disabled = false;
    difficultySelect.disabled = false;
    gameOverModal.classList.remove('active');
    
    // 【核心新增】恢復開始按鈕的原始外觀和功能
    startBtn.innerHTML = originalStartButtonSVG;
}

            
// ====================================================================
// ====== 【最終版】統一的遊戲後獎勵處理函數 (支援前置通知) ======
// ====================================================================
async function processPostGameRewards(songUrl, difficulty, score, pureHitScore) {
    const rewardsQueue = [];
    const hasQuiz = songData[songUrl]?.quiz && songData[songUrl].quiz.length > 0;

    // --- 檢查所有可能的獎勵並加入佇列 (這部分邏輯不變) ---
    // 檢查 1: 新歌曲解鎖
    if (difficulty === 'normal') {
        const allSongs = Array.from(musicSelect.options).map(opt => opt.value);
        const lastUnlockedSong = saveData.unlockedSongs[saveData.unlockedSongs.length - 1];
        if (songUrl === lastUnlockedSong) {
            const currentIndex = allSongs.indexOf(lastUnlockedSong);
            if (currentIndex >= 0 && currentIndex < allSongs.length - 1) {
                const nextSong = allSongs[currentIndex + 1];
                if (!isSongUnlocked(nextSong)) {
                    const requiredScore = maxScoreForCurrentLevel * SONG_UNLOCK_PERCENTAGE;
                    if (pureHitScore >= requiredScore) {
                        rewardsQueue.push({ type: 'song', value: songUrl });
                    }
                }
            }
        }
    }
    // 檢查 2: 新難度解鎖
    if (difficulty === 'normal' && !isDifficultyUnlocked(songUrl, 'hard')) {
        if (pureHitScore >= maxScoreForCurrentLevel * DIFFICULTY_UNLOCK_PERCENTAGE) {
            rewardsQueue.push({ type: 'difficulty', value: { song: songUrl, difficulty: 'hard' } });
        }
    }
    if (difficulty === 'hard' && !isDifficultyUnlocked(songUrl, 'hell')) {
        if (pureHitScore >= maxScoreForCurrentLevel * DIFFICULTY_UNLOCK_PERCENTAGE) {
            rewardsQueue.push({ type: 'difficulty', value: { song: songUrl, difficulty: 'hell' } });
        }
    }
    // 檢查 3: 排行榜資格 (異步)
    if (playerName) {
        const songId = sanitizeFirebaseKey(songUrl);
        const leaderboardRef = database.ref(`leaderboards/${songId}/${difficulty}`);
        try {
            const snapshot = await leaderboardRef.once('value');
            const board = snapshot.val() || [];
            const lowestScoreOnBoard = board.length < 3 ? 0 : board[board.length - 1].score;
            const selfEntry = board.find(e => e.name === playerName);
            if (score > lowestScoreOnBoard || (selfEntry && score > selfEntry.score)) {
                rewardsQueue.push({ type: 'leaderboard', value: { songUrl, difficulty, score } });
            }
        } catch (error) { console.error("檢查排行榜資格時出錯:", error); }
    }

    // --- 【核心修改】根據佇列內容，決定下一步行動 ---
    if (rewardsQueue.length > 0) {
        if (hasQuiz) {
            // 如果有獎勵且有測驗，則顯示前置通知，並將「啟動測驗」作為回呼
            const hasLeaderboardReward = rewardsQueue.some(reward => reward.type === 'leaderboard');
            const hasUnlockReward = rewardsQueue.some(reward => reward.type !== 'leaderboard');

            let title = '恭喜！表現出色！';
            let message = '只要通過接下來的歌詞測驗，';

            if (hasLeaderboardReward && hasUnlockReward) {
                message += '你的名字就能登上排行榜，並解鎖新內容！';
            } else if (hasLeaderboardReward) {
                message += '你的名字就能登上排行榜！';
            } else if (hasUnlockReward) {
                message += '就能解鎖新的內容！';
            }

            // 呼叫升級後的通知函數
            showNotification(
                'success',          // 類型
                title,              // 標題
                message,            // 我們動態生成的消息
                6000,               // 顯示時長 (6秒)
                () => {             // 這是回呼函式，會在通知結束後執行
                    startLyricsQuiz(rewardsQueue, songUrl);
                }
            );
        } else {
            // 如果有獎勵但沒有測驗，則直接授予所有獎勵
            showNotification('info', '自動授予獎勵', '由於此歌曲無歌詞測驗，所有已達成的獎勵將自動授予給您。');
            grantAllRewards(rewardsQueue);
        }
    }
}

/**
 * 直接授予所有獎勵 (用於沒有測驗的歌曲)
 * @param {Array} rewards - 獎勵佇列
 */
function grantAllRewards(rewards) {
    rewards.forEach(reward => {
        switch (reward.type) {
            case 'song':
                unlockNextSong(reward.value);
                break;
            case 'difficulty':
                unlockDifficulty(reward.value.song, reward.value.difficulty);
                break;
            case 'leaderboard':
                submitScoreToLeaderboard(reward.value.songUrl, reward.value.difficulty, reward.value.score);
                break;
        }
    });
}
            

function endGame() {
    if (!gameActive) return;

    mainGameContainer.classList.remove('online-mode');
    
    // ▼▼▼ 【核心修訂】區分單人與對戰模式的結束流程 ▼▼▼
    if (gameMode === 'online' && currentRoomId) {
        // 對戰模式：
        // 停止本地計時器並發送最終的遊戲分數
        if (scoreUpdateTimeout) clearTimeout(scoreUpdateTimeout);
        scoreUpdateTimeout = null;
        sendScoreUpdate(); 
        database.ref(`rooms/${currentRoomId}/${isHost ? 'player1' : 'player2'}`).update({ maxCombo: maxCombo });
        
        // 由房主 (Host) 負責將遊戲狀態推進到「準備測驗」(pre_quiz)
        if (isHost) { 
            database.ref(`rooms/${currentRoomId}`).update({ gameState: 'pre_quiz' });
        }
        // 注意：此處不再直接顯示結算畫面，而是等待 Firebase 狀態變更

    } else {
        // 單人模式 (流程維持不變)：
        gameActive = false;
        audio.pause();
        audio.currentTime = 0;
        clearTimeout(generateNotesTimer);
        clearInterval(progressInterval);
        cancelAnimationFrame(animationFrame);
        startBtn.disabled = false;
        musicSelect.disabled = false;
        difficultySelect.disabled = false;

        mainGameContainer.classList.remove('game-running'); 
        unlockProgressBar.style.width = '0%';
        unlockProgressBar.classList.remove('glowing');
        progressBar.style.width = '0%';
        notes.forEach(note => note.element.remove());
        notes = [];

        const selectedSong = musicSelect.value;
        const selectedDifficulty = difficultySelect.value;
        updatePersonalHighScore(selectedSong, selectedDifficulty, score);

        // 單人模式依然走原有的解鎖測驗流程
        processPostGameRewards(selectedSong, selectedDifficulty, score, pureHitScore);

        showGameOver();
    }
    // ▲▲▲ 修訂結束 ▲▲▲
}


// ====================================================================
// ====== 【最終修訂版】啟動對戰歌詞測驗函數 ======
// ====================================================================
/**
 * 啟動對戰歌詞測驗。
 * 這個函數現在由一個本地狀態旗標 'isBattleQuizActive' 保護，
 * 確保在同一回合中只會被執行一次。
 */
function startBattleQuiz(roomData) {
    
    // 1. 【核心】設置單次入場券旗標
    // 一旦測驗開始，此旗標將阻止監聽器重複觸發此函數，直到回合完全重置。
    if (isBattleQuizActive) return; // 【修訂】添加此檢查，防止重複啟動
    isBattleQuizActive = true; 

    const songUrl = roomData.selectedSong;
    const allQuestions = songData[songUrl]?.quiz || [];

    // 2. 檢查題庫是否充足
    // 如果題庫題目少於5題，則無法進行測驗。
    if (allQuestions.length < 5) {
        console.warn(`歌曲 ${songUrl} 題庫不足5題，將自動跳過測驗。`);
        // 直接在Firebase上將測驗標記為完成，分數為0，避免對手卡住。
        const playerKey = isHost ? 'player1' : 'player2';
        database.ref(`rooms/${currentRoomId}/${playerKey}`).update({
            quizScore: 0,
            quizFinished: true
        });
        // 由於無法進行測驗，顯示提示後直接結束此函數的執行。
        showNotification('info', '測驗跳過', '由於此歌曲題庫不足，本回合歌詞測驗將被跳過。');
        return;
    }

    // 3. 初始化本地測驗狀態
    battleQuizScore = 0;
    battleQuizCurrentIndex = 0;
    // 從題庫中隨機洗牌並選取 5 題
    battleQuizQuestions = shuffleArray([...allQuestions]).slice(0, 5); 

    // 4. 更新並顯示測驗 Modal 視窗
    document.getElementById('quizTitle').textContent = '對戰歌詞測驗';
    document.getElementById('quizInstructions').textContent = '每題20秒作答時間，答對+1000分，答錯-1000分。';
    document.getElementById('battleQuizTimerContainer').style.display = 'block';
    quizCloseBtn.style.display = 'none'; // 根據要求，在對戰測驗中隱藏關閉按鈕
    lyricsQuizModal.classList.add('active');
    
    // 【新增】初始化得分顯示
    document.getElementById('quizScoreDisplay').textContent = `當前得分: ${battleQuizScore}`;

    // 5. 在 Firebase 中初始化玩家的測驗狀態
    // 這會通知系統和對手，你已經正式開始作答。
    const playerKey = isHost ? 'player1' : 'player2';
    database.ref(`rooms/${currentRoomId}/${playerKey}`).update({
        quizScore: 0,
        quizFinished: false
    });

    // 6. 顯示第一題並開始計時
    displayNextBattleQuestion();
}

/**
 * 2. 顯示下一道對戰測驗題目，並啟動計時器
 */
function displayNextBattleQuestion() {
    // 【修訂】添加嚴格檢查，防止重複循環
    if (battleQuizCurrentIndex >= 5 || !isBattleQuizActive) {
        finishBattleQuiz();
        return;
    }

    const questionData = battleQuizQuestions[battleQuizCurrentIndex];
    
    // 更新 UI
    quizProgress.textContent = `第 ${battleQuizCurrentIndex + 1} / 5 題`;
    const questionLine = questionData.line.replace(/__/g, '<span class="quiz-blank"></span>');
    quizQuestionText.innerHTML = questionLine;
    quizAnswerInput.value = '';
    quizAnswerInput.classList.remove('correct', 'incorrect');
    quizAnswerInput.disabled = false;
    quizSubmitBtn.disabled = false;
    quizAnswerInput.focus();

    // 重置並啟動 20 秒倒數計時器
    const timerBar = document.getElementById('battleQuizTimerBar');
    timerBar.style.transition = 'none'; // 先移除動畫效果
    timerBar.style.width = '100%';    // 立刻填滿
    
    // 強制瀏覽器重繪，讓樣式立即生效
    void timerBar.offsetWidth; 
    
    timerBar.style.transition = 'width 20s linear'; // 重新加上 20 秒的動畫
    timerBar.style.width = '0%';                     // 開始縮減

    // 設定計時器，20秒後自動判定為答錯
    battleQuizTimer = setTimeout(() => {
        handleBattleQuizAnswer(true); //傳入 true 代表是超時
    }, 20000);
}

/**
 * 3. 處理玩家的答案 (無論是提交還是超時)
 */
function handleBattleQuizAnswer(isTimeout = false) {
    clearTimeout(battleQuizTimer); // 清除計時器，防止重複觸發
    
    const correctAnswer = battleQuizQuestions[battleQuizCurrentIndex].answer;
    const userAnswer = quizAnswerInput.value.trim();

    quizAnswerInput.disabled = true;
    quizSubmitBtn.disabled = true;

    if (!isTimeout && userAnswer === correctAnswer) {
        // 答對
        battleQuizScore += 1000;
        quizAnswerInput.classList.add('correct');
        showNotification('success', '+1000 分', '答案正確！', 1500);
    } else {
        // 答錯或超時
        battleQuizScore -= 1000;
        quizAnswerInput.classList.add('incorrect');
        quizAnswerInput.value = `正確答案: ${correctAnswer}`; // 顯示正確答案
        showNotification('info', '-1000 分', isTimeout ? '作答超時！' : '答案錯誤！', 1500);
    }

    // 【新增】即時更新得分顯示
    document.getElementById('quizScoreDisplay').textContent = `當前得分: ${battleQuizScore}`;

    // 【新增】即時同步到 Firebase，讓對手也能看到你的得分變化（雖然需求只說看自己的，但這樣更完整）
    const playerKey = isHost ? 'player1' : 'player2';
    database.ref(`rooms/${currentRoomId}/${playerKey}/quizScore`).set(battleQuizScore);

    battleQuizCurrentIndex++; // 移至下一題
    
    // 延遲 1.8 秒後，顯示下一題或結束測驗
    setTimeout(displayNextBattleQuestion, 1800);
}
            


function finishBattleQuiz() {
    quizCloseBtn.style.display = 'block';

    lyricsQuizModal.classList.remove('active');
    document.getElementById('battleQuizTimerContainer').style.display = 'none';

    // 將最終測驗分數上傳到 Firebase (移除多餘的 quizInProgress)
    const playerKey = isHost ? 'player1' : 'player2';
    database.ref(`rooms/${currentRoomId}/${playerKey}`).update({
        quizScore: battleQuizScore,
        quizFinished: true
    });
}

            
/**
 * 5. 輔助函數：Fisher-Yates 洗牌演算法 (沿用你已有的即可)
 */
function shuffleArray(array) {
    let currentIndex = array.length, randomIndex;
    while (currentIndex !== 0) {
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex--;
        [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
    }
    return array;
}
// ====================================================================


            
            // ================================================================
// ====== 【全新】線上對戰核心功能 (參考範例代碼) ======
// ================================================================

/**
 * 創建一個新房間
 * 參考範例：此函數模擬了範例中創建一個帶有 player1 的新房間的行為。
 */
function createRoom() {
    let roomId = roomIdInput.value.trim();
    if (!/^\d{4}$/.test(roomId)) {
        roomId = Math.floor(1000 + Math.random() * 9000).toString();
    }

    const roomRef = database.ref('rooms/' + roomId);
    roomRef.get().then(snapshot => {
        if (snapshot.exists()) {
            matchStatusText.textContent = `房間 ${roomId} 已存在，請換一個號碼。`;
            return;
        }

        isHost = true;
        currentRoomId = roomId;
        gameMode = 'online';

        const roomData = {
            player1: {
                playerId: playerId,
                playerName: playerName || '玩家一',
                score: 0,
                rematch: false,
                isReady: false,
                player1Ended: false  // ▼▼▼ 新增：初始化ended状态 ▼▼▼
            },
            player2: null,
            gameState: 'waiting_for_players',
            createdAt: firebase.database.ServerValue.TIMESTAMP
        };

        roomRef.set(roomData).then(() => {
            onlineMatchModal.classList.remove('active');
            listenToRoomChanges();
            showNotification('info', '房間已創建', `房間號: <strong>${currentRoomId}</strong>。請等待另一位玩家加入。`);
        });
    });
}

/**
 * 加入一個指定的房間
 * 參考範例：此函數模擬了範例中玩家二加入一個已知ID的房間的行為。
 */
function joinRoom() {
    const roomId = roomIdInput.value.trim();
    if (!/^\d{4}$/.test(roomId)) {
        matchStatusText.textContent = '請輸入一個有效的4位數房間號碼。';
        return;
    }

    const roomRef = database.ref('rooms/' + roomId);
    roomRef.get().then(snapshot => {
        if (!snapshot.exists()) {
            matchStatusText.textContent = `房間 ${roomId} 不存在。`;
            return;
        }

        const roomData = snapshot.val();
        if (roomData.player2) {
            matchStatusText.textContent = `房間 ${roomId} 已滿。`;
            return;
        }
        if (roomData.player1.playerId === playerId) {
            matchStatusText.textContent = `你不能加入自己創建的房間。`;
            return;
        }

        isHost = false;
        currentRoomId = roomId;
        gameMode = 'online';
        
        const player2Data = {
            playerId: playerId,
            playerName: playerName || '玩家二',
            score: 0,
            rematch: false,
            isReady: false,
            player2Ended: false  // ▼▼▼ 新增：初始化ended状态 ▼▼▼
        };

        // 使用 transaction 確保加入操作的原子性
        database.ref(`rooms/${currentRoomId}/player2`).transaction(currentData => {
            if (currentData === null) {
                return player2Data;
            } else {
                return; // Abort transaction if player2 is already set
            }
        }).then(result => {
            if (result.committed) {
                database.ref(`rooms/${currentRoomId}`).update({ gameState: 'selecting_song' });
                onlineMatchModal.classList.remove('active');
                listenToRoomChanges();
            } else {
                matchStatusText.textContent = `加入房間 ${roomId} 失敗，可能已被佔用。`;
            }
        });
    });
}

/**
 * 隨機配對
 * 參考範例：此函數完整複製了範例中使用 `waitingQueue` 節點進行配對的邏輯。
 */
function randomMatch() {
    matchStatusText.textContent = '正在尋找對手...';
    const queueRef = database.ref('waitingQueue');
    
    // 【新增】一個臨時變數，用於在 transaction 內部儲存對手的資訊
    let opponentInfo = null;

    queueRef.transaction(currentQueue => {
        if (currentQueue === null) {
            // 佇列是空的，成為等待者
            return { hostId: playerId, playerName: playerName || '等待中的玩家' };
        } else {
            // 【修訂】佇列有人，配對成功。在清空佇列前，先將對手資訊存起來。
            opponentInfo = currentQueue;
            return {}; // 返回一個空對象來清空佇列
        }
    }).then(result => {
        if (!result.committed) {
             matchStatusText.textContent = '配對出錯，請重試。';
             return;
        }
        
        const postTransactionQueue = result.snapshot.val();
        if (postTransactionQueue && postTransactionQueue.hostId === playerId) {
            // 我成為了等待者 (這部分邏輯不變)
            isHost = true;
            gameMode = 'online';
            currentRoomId = 'queue_' + playerId.substring(7, 12); 
            database.ref('rooms/' + currentRoomId).set({
                player1: { playerId: playerId, playerName: playerName || '玩家一', score: 0, rematch: false, isReady: false },
                player2: null,
                gameState: 'waiting_for_players'
            });
            queueRef.on('value', (snapshot) => {
                if (!snapshot.exists()) {
                    queueRef.off();
                    database.ref('rooms/' + currentRoomId + '/officialRoomId').on('value', (officialSnapshot) => {
                        if (officialSnapshot.exists()) {
                            database.ref('rooms/' + currentRoomId).off();
                            currentRoomId = officialSnapshot.val();
                            listenToRoomChanges();
                            onlineMatchModal.classList.remove('active');
                        }
                    });
                }
            });
        } else {
            // 我配對到了別人
            // 【修訂】從我們預先儲存的 opponentInfo 中讀取對手資訊，而不是從已被清空的 result.snapshot 中讀取。
            if (opponentInfo) {
                isHost = false;
                gameMode = 'online';
                const hostPlayerId = opponentInfo.hostId;
                const hostPlayerName = opponentInfo.playerName;
                
                currentRoomId = Math.floor(1000 + Math.random() * 9000).toString();
                
                database.ref('rooms/' + currentRoomId).set({
                    player1: { playerId: hostPlayerId, playerName: hostPlayerName, score: 0, rematch: false, isReady: false },
                    player2: { playerId: playerId, playerName: playerName || '玩家二', score: 0, rematch: false, isReady: false },
                    gameState: 'selecting_song'
                }).then(() => {
                    const tempRoomId = 'queue_' + hostPlayerId.substring(7, 12);
                    database.ref('rooms/' + tempRoomId).update({ officialRoomId: currentRoomId });
                    listenToRoomChanges();
                    onlineMatchModal.classList.remove('active');
                });
            } else {
                // 備用錯誤處理
                matchStatusText.textContent = '配對失敗，找不到對手資訊，請重試。';
            }
        }
    });
}


/**
 * 專門處理線上對戰的「選歌」階段
 * @param {object} roomData - 從 Firebase 獲取的房間資料
 */
function handleSongSelectionState(roomData) {
    if (gameActive) return;

    // 恢復UI到可選歌狀態
    clearAllNotifications();
    startBtn.innerHTML = originalStartButtonSVG;

    // 決定由誰選歌。只有房主(Host)會執行一次此操作。
    if (!roomData.songSelector) {
        if (isHost) {
            const selector = Math.random() < 0.5 ? 'player1' : 'player2';
            database.ref('rooms/' + currentRoomId).update({ songSelector: selector });
        }
        return; // 等待監聽器再次觸發
    }

    const isMyTurnToSelect = (isHost && roomData.songSelector === 'player1') || (!isHost && roomData.songSelector === 'player2');

    if (isMyTurnToSelect) {
        // 輪到我選歌
        musicSelect.disabled = false;
        difficultySelect.disabled = false;
        startBtn.disabled = false;
        showNotification('info', '選擇歌曲！', '請選擇歌曲和難度，並點擊「開始」按鈕確認。');
    } else {
        // 等待對方選歌
        musicSelect.disabled = true;
        difficultySelect.disabled = true;
        startBtn.disabled = true;
  
    }
}

/**
 * 處理線上對戰的「準備」階段
 * @param {object} roomData - 從 Firebase 獲取的房間資料
 */
function handleReadyUpState(roomData) {
    if (gameActive) return;

    clearAllNotifications();

    // 雙方玩家的介面都會同步顯示被選中的歌曲和難度
    musicSelect.value = roomData.selectedSong;
    difficultySelect.value = roomData.selectedDifficulty;
    musicSelect.disabled = true;
    difficultySelect.disabled = true;

    const myPlayerKey = isHost ? 'player1' : 'player2';

    if (roomData[myPlayerKey].isReady) {
        // 如果我已經點擊過「準備」
        startBtn.disabled = true;
       
    } else {
        // 如果我還未點擊「準備」
        startBtn.disabled = false;
        showNotification('info', '確認對戰', '對手已選擇歌曲，請點擊「開始」按鈕對戰！');
    }
}

            

function listenToRoomChanges() {
    if (roomListener) {
        database.ref('rooms/' + currentRoomId).off('value', roomListener);
    }
    const roomRef = database.ref('rooms/' + currentRoomId);
    
    const myPlayerKey = isHost ? 'player1' : 'player2';
    myPlayerRef = roomRef.child(myPlayerKey);
    myPlayerRef.onDisconnect().update({ disconnected: true });
    myPlayerRef.update({ disconnected: false });

    roomListener = roomRef.on('value', (snapshot) => {
        if (!snapshot.exists()) {
            if(gameActive || isBattleQuizActive){ // 如果在遊戲或測驗中斷
                showNotification('info', '對戰已結束', '對手已離開房間，您已返回主選單。');
            } else {
                showNotification('info', '對戰已結束', '房間已被解散。');
            }
            resetToMainMenu();
            return;
        }

        const roomData = snapshot.val();
        const opponentKey = isHost ? 'player2' : 'player1';
        const myEndedKey = isHost ? 'player1Ended' : 'player2Ended';
        const opponentEndedKey = isHost ? 'player2Ended' : 'player1Ended';
        
        // ▼▼▼ 新增：检测对方ended ▼▼▼
        if (roomData[opponentEndedKey] && !roomData[myEndedKey]) {
            // 对方ended，但我还没，按需求：显示提示，但不强制结束（允许继续看分数）
            showNotification('info', '對手已離開', '對手已點擊“結束遊戲”，您可以繼續查看分數，或點擊“結束遊戲”離開。');
        }
        // 如果自己ended，直接重置（但因为点击结束时已本地reset，这里只是冗余检查）
        if (roomData[myEndedKey]) {
            resetToMainMenu();
        }
        // ▲▲▲ 新增结束 ▲▲▲

        if (roomData[opponentKey] && roomData[opponentKey].disconnected === true && (gameActive || isBattleQuizActive)) {
            gameActive = false; 
            isBattleQuizActive = false; // 也要停止測驗
            
            const myData = roomData[myPlayerKey];
            const opponentData = roomData[opponentKey];
            updateBattleScore(myData.playerId, myData.playerName, 1000);
            updateBattleScore(opponentData.playerId, opponentData.playerName, -500);
            
            showNotification('success', '對手已斷線', '對手中途離開遊戲，系統判定您獲勝！');
            
            roomRef.remove(); 
            resetToMainMenu();
            return;
        }
        
        // --- UI 更新 (保持不變) ---
        if (roomData[opponentKey]) {
            opponentStats.style.display = 'block';
            const opponentScore = roomData[opponentKey].score;
            opponentScoreDisplay.textContent = opponentScore;
            opponentNameLabel.textContent = roomData[opponentKey].playerName || '對手';

            if (gameActive && maxScoreForCurrentLevel > 0) {
                const opponentProgress = Math.min(100, (opponentScore / maxScoreForCurrentLevel) * 100);
                opponentProgressBar.style.width = `${opponentProgress}%`;
            } else {
                opponentProgressBar.style.width = '0%';
            }
        } else {
            opponentStats.style.display = 'none';
            opponentNameLabel.textContent = '對手分數';
            opponentProgressBar.style.width = '0%';
        }
        
        // --- 狀態檢查與推進 (由房主負責) ---
        if (isHost) {
            // 檢查是否從「準備」進入「倒數」
            if (roomData.gameState === 'readying_up' && roomData.player1?.isReady && roomData.player2?.isReady) {
                roomRef.update({ gameState: 'countdown' });
            }
            // 檢查雙方是否都完成了測驗
            if (roomData.gameState === 'pre_quiz' && roomData.player1?.quizFinished && roomData.player2?.quizFinished) {
                // 計算最終總分
                const finalP1Score = roomData.player1.score + roomData.player1.quizScore;
                const finalP2Score = roomData.player2.score + roomData.player2.quizScore;

                // 更新分數並推進到最終的「遊戲結束」狀態
                roomRef.update({
                    'player1/score': finalP1Score,
                    'player2/score': finalP2Score,
                    gameState: 'game_over'
                });
            }
        }
        
        // --- 根據狀態執行客戶端操作 ---
        switch (roomData.gameState) {
            case 'selecting_song':
                handleSongSelectionState(roomData);
                break;
            
            case 'readying_up':
                handleReadyUpState(roomData);
                break;

            case 'countdown':
                handleCountdown();
                break;

            case 'pre_quiz':
                // 只有當本地測驗未啟動時才執行
                if (!isBattleQuizActive) {
                    startBattleQuiz(roomData);
                }
                // 檢查是否需要顯示等待通知（僅對先完成者）
                if (roomData[myPlayerKey].quizFinished && !roomData[opponentKey].quizFinished) {
                    showNotification('info', '測驗完成', '已提交你的測驗分數，請等待對手完成...', Infinity);
                }
                break;

            case 'playing':
                // 遊戲進行中，由本地 gameLoop 處理
                break;

            case 'game_over':
                if (gameActive || isBattleQuizActive) {
                    isBattleQuizActive = false; // 確保測驗狀態被重設
                    clearAllNotifications(); // 手動關閉等待通知
                    handleOnlineGameOver(roomData);
                }
                break;
                
            case 'rematch_reset':
                 resetForRematch();
                 if(isHost){
                    database.ref(`rooms/${currentRoomId}`).update({ gameState: 'selecting_song' });
                 }
                break;
        }
        
        if (roomData.gameState === 'game_over') {
            handleRematchStatus(roomData);
        }
    });
}
/**
 * 從線上同步的狀態啟動遊戲
 * 參考範例：確保雙方在收到 `gameStarted` 信號後同時進入遊戲。
 */
function startGameFromOnline(song, difficulty) {
    // 設置好歌曲和難度
    musicSelect.value = song;
    difficultySelect.value = difficulty;
    updateDifficultyOptions(song);
    
    // 直接調用原有的開始遊戲邏輯
    // 移除原有的開始按鈕點擊事件，避免重複綁定
    startBtn.onclick = null;
    startGame(true); // 傳入一個標誌表示是線上模式
}

function handleOnlineGameOver(roomData) {
    // 【修訂】新增：在显示结束画面前，先关闭等待通知
    closeCurrentNotification();

    if (!gameActive && !isBattleQuizActive) return; // 防止重复执行
    gameActive = false;
    isBattleQuizActive = false;

    audio.pause();
    cancelAnimationFrame(animationFrame);
    clearTimeout(generateNotesTimer);
    clearInterval(progressInterval);
    
    const myPlayerKey = isHost ? 'player1' : 'player2';
    const opponentPlayerKey = isHost ? 'player2' : 'player1';
    
    const myData = roomData[myPlayerKey];
    const opponentData = roomData[opponentPlayerKey];
    
    // 使用包含測驗分數的最終成績來判斷勝負
    const myFinalScore = myData.score; 
    const opponentFinalScore = opponentData.score;

    let myScoreChange = 0;
    let opponentScoreChange = 0;
    let iAmWinner = false;

    if (myFinalScore > opponentFinalScore) {
        gameOverTitle.textContent = "勝利！";
        gameOverTitle.classList.remove('defeat'); // 確保無紅 class
        myScoreChange = 1000;       // 勝方得 1000 分
        opponentScoreChange = -500; // 敗方失 500 分
        iAmWinner = true;
    } else if (myFinalScore < opponentFinalScore) {
        gameOverTitle.textContent = "惜敗！";
        gameOverTitle.classList.add('defeat'); // 加紅 class
        myScoreChange = -500;       // 敗方失 500 分
        opponentScoreChange = 1000; // 勝方得 1000 分
    } else {
        gameOverTitle.textContent = "平局！";
        gameOverTitle.classList.remove('defeat');
        // 平局分數不變 (0)
    }

    // 使用修正後的積分變化來更新雙方的對戰總分
    updateBattleScore(myData.playerId, myData.playerName, myScoreChange);
    updateBattleScore(opponentData.playerId, opponentData.playerName, opponentScoreChange);

    // --- 顯示結算畫面的 UI 邏輯 (保持不變) ---
    const statsContainer = gameOverModal.querySelector('.game-over-stats');
    
    const myCardClass = iAmWinner ? 'stats-player-card your-card winner' : 'stats-player-card your-card';
    const opponentCardClass = !iAmWinner && (myFinalScore < opponentFinalScore) ? 'stats-player-card opponent-card winner' : 'stats-player-card opponent-card';

    statsContainer.innerHTML = `
        <div class="${myCardClass}">
            <h3 class="stats-player-title">您的成績</h3>
            <div class="stats-data-container">
                <div class="stats-data-item">
                    <span class="stats-data-label">最終分數</span>
                    <span class="stats-data-value">${myFinalScore.toLocaleString()}</span>
                </div>
                <div class="stats-data-item">
                    <span class="stats-data-label">最高連擊</span>
                    <span class="stats-data-value">${myData.maxCombo || maxCombo}</span>
                </div>
                <!-- ▼▼▼ 新增：显示积分变化 ▼▼▼ -->
                <div class="stats-data-item">
                    <span class="stats-data-label">積分變化</span>
                    <span class="stats-data-value" id="myScoreChange">${myScoreChange > 0 ? '+' : ''}${myScoreChange.toLocaleString()}</span>
                </div>
            </div>
        </div>
        <div class="${opponentCardClass}">
            <h3 class="stats-player-title">對手成績</h3>
            <div class="stats-data-container">
                <div class="stats-data-item">
                    <span class="stats-data-label">最終分數</span>
                    <span class="stats-data-value">${opponentFinalScore.toLocaleString()}</span>
                </div>
                <div class="stats-data-item">
                    <span class="stats-data-label">最高連擊</span>
                    <span class="stats-data-value">${opponentData.maxCombo || 0}</span>
                </div>
            </div>
        </div>
    `;
    
    restartBtnSingle.style.display = 'none';
    onlineRematchControls.style.display = 'flex';
    rematchBtn.disabled = false;
    rematchStatus.textContent = '';
    gameOverModal.classList.add('active');

    // 【核心修訂】在結束遊戲後，移除 'game-running' class 以恢復選擇器的可見性
    mainGameContainer.classList.remove('game-running');
}

            
/**
 * 處理重賽狀態的顯示與邏輯
 * @param {object} roomData - 從 Firebase 獲取的房間資料
 */
function handleRematchStatus(roomData) {
    const myRematch = roomData[isHost ? 'player1' : 'player2'].rematch;
    const opponentRematch = roomData[isHost ? 'player2' : 'player1']?.rematch;

    if (myRematch && opponentRematch) {
        // 雙方都同意重賽，由主機方負責重置房間狀態
        if (isHost) {
            database.ref(`rooms/${currentRoomId}`).update({
                gameState: 'rematch_reset', // 觸發客戶端重置
                songSelector: null,          // 清除選歌者，下一局重新隨機
                'player1/rematch': false,    // 重置重賽狀態
                'player2/rematch': false,
                'player1/isReady': false,    // 重置準備狀態
                'player2/isReady': false
            });
        }
    } else if (myRematch) {
        rematchStatus.textContent = "已發送重賽請求，等待對方回應...";
    } else if (opponentRematch) {
        rematchStatus.textContent = "對方請求再戰一局！";
    }
}

/**
 * 為重賽重置客戶端的遊戲狀態和UI
 */
function resetForRematch() {
    gameOverModal.classList.remove('active');
    gameActive = false;
    isBattleQuizActive = false; // <-- 在這裡加入
    
    // 重置分數和UI
    score = 0;
    pureHitScore = 0;
    combo = 0;
    maxCombo = 0;
    updateUI();
    opponentScoreDisplay.textContent = '0';
    
    // 清理遊戲區域並重新初始化
    tracksContainer.innerHTML = '';
    initGame();
    
    // 解鎖按鈕
    startBtn.disabled = false;

    // 【核心修訂】在重賽重置時，移除 'game-running' class 以恢復選擇器的可見性
    mainGameContainer.classList.remove('game-running');
}

/**
 * 重置所有狀態並安全返回主菜單 (UI 恢復增強版)
 */
function resetToMainMenu() {
    clearAllNotifications();

    if (roomListener && currentRoomId) {
        database.ref('rooms/' + currentRoomId).off('value', roomListener);
    }
    
    // --- 狀態重置 ---
    gameActive = false;
    gameMode = 'single';
    currentRoomId = null;
    isHost = false;
    roomListener = null;
    
    // --- 核心修改：強制恢復所有主選單 UI 元素的可見性 ---
    
    // 1. 恢復按鈕和選擇器的可用狀態
    startBtn.disabled = false;
    musicSelect.disabled = false;
    difficultySelect.disabled = false;
    
    // 2. 確保選擇器容器是可見的
    // (假設 .music-selector 是包含所有選單和按鈕的容器)
    const musicSelectorContainer = document.querySelector('.music-selector');
    if (musicSelectorContainer) {
        musicSelectorContainer.style.display = 'flex'; 
    }
    
    // 3. 恢復其他相關 UI
    opponentStats.style.display = 'none';
    restartBtnSingle.style.display = 'block';
    onlineRematchControls.style.display = 'none';
    gameOverModal.classList.remove('active');
    
    // 移除遊戲進行中添加的 class
    mainGameContainer.classList.remove('game-running');
    mainGameContainer.classList.remove('online-mode');

    // 恢復開始按鈕的原始 SVG 圖示和功能
    startBtn.innerHTML = originalStartButtonSVG;
    // 重新綁定單人模式的點擊事件
    startBtn.onclick = handleStartButtonClick; 

    // 最後，初始化一次遊戲板，清理可能殘留的音符
    initGame();
}
// ================================================================
// ====== 【功能函數新增結束】 ========================================
// ================================================================

          function showGameOver() {
    // ▼▼▼ 【修訂】根据游戏模式显示不同内容 ▼▼▼
    if (gameMode === 'single') {
        gameOverTitle.textContent = "";  // 改为为空，不显示“遊戲結束”
        finalScoreDisplay.textContent = score.toLocaleString();
        finalComboDisplay.textContent = maxCombo;
        restartBtnSingle.style.display = 'block';
        onlineRematchControls.style.display = 'none';
        rematchStatus.textContent = '';
        gameOverModal.classList.add('active');
    }
    // 線上模式的結束畫面由 handleOnlineGameOver 觸發，這裡不需要處理
    // ▲▲▲ 修訂結束 ▲▲▲
}

            function restartGame() {
    // 這個函數現在只負責單機模式的重啟
    gameOverModal.classList.remove('active');
    initGame();
}

          function gameLoop() {
    if (!gameActive) return;

    // --- 核心優化：在迴圈外快取不會變動的數值 ---
    // 獲取軌道總高度，音符需要移動的總距離
    const fallDistance = tracksContainer.clientHeight; 
    // 計算判定線的 Y 座標 (相對於軌道頂部)
    const hitLineY = fallDistance - 100; 
    // 計算音符每毫秒移動的像素距離
    const pixelsPerMillisecond = fallDistance / noteSpeed;

    const now = Date.now();

    for (let i = notes.length - 1; i >= 0; i--) {
        const note = notes[i];
        if (!note.active) continue;

        // --- 核心優化：用數學公式「計算」音符的當前位置 ---
        const timeElapsed = now - note.creationTime;
        // 音符頂部的 Y 座標 = 已過時間 * 每毫秒移動距離 - 音符自身高度(動畫是從-50px開始的)
        const noteTopY = (timeElapsed * pixelsPerMillisecond) - 50;

        // --- 使用計算出的位置來進行判斷 ---
        // 如果音符頂部已經超過了判定線加一個緩衝區 (20px)
        if (noteTopY > hitLineY + 20) {
            const isTrackInvincible = notes.some(n =>
                n.track === note.track &&
                n.type === 'long' &&
                n.hitStarted
            );

            if (!isTrackInvincible) {
                judgeHit(note.track, 'miss');
            }
            
            note.active = false;
            note.element.remove(); // 這裡的 remove 是必要的，因為 miss 了
            notes.splice(i, 1);
        }
    }

    animationFrame = requestAnimationFrame(gameLoop);
}

         function handleKeyDown(e) {
                if (!gameActive) return;
                const keyCode = e.keyCode;
                if (keyStates[keyCode]) return;
                keyStates[keyCode] = true;
                const trackIndex = keyCodes.indexOf(keyCode);
                if (trackIndex !== -1) {
                    const trackEl = document.querySelector(`.track[data-track="${trackIndex}"]`);
                    if (trackEl) {
                        trackEl.classList.remove('hit-effect');
                        void trackEl.offsetWidth;
                        trackEl.classList.add('hit-effect');
                    }
                    const trackRect = tracksContainer.getBoundingClientRect();
                    const hitLineY = trackRect.top + trackRect.height - 100;
                    let hitNote = null;
                    let minDistance = Infinity;
                    let hitIndex = -1;
                    notes.forEach((note, index) => {
                        if (note.track === trackIndex && note.active && !note.hitStarted) {
                            const rect = note.element.getBoundingClientRect();
                            const distance = Math.abs(rect.bottom - hitLineY);
                            if (distance < minDistance) {
                                minDistance = distance;
                                hitNote = note;
                                hitIndex = index;
                            }
                        }
                    });
                   if (hitNote && minDistance < 50) {
    let judgment;
    if (minDistance < 15) judgment = 'perfect';
    else if (minDistance < 30) judgment = 'great';
    else judgment = 'good';
    if (hitNote.type === 'long') {
        hitNote.hitStarted = true;
        hitNote.element.classList.add('held');
        judgeHit(trackIndex, judgment);
        explodeNote(hitNote.element, judgment); // 新增：長音符按下時分解粒子
    } else {
        hitNote.active = false;
        explodeNote(hitNote.element, judgment); // 新增：短音符擊中時分解粒子
        hitNote.element.remove();
        notes.splice(hitIndex, 1);
        judgeHit(trackIndex, judgment);
    }
} else {
                        // 如果按下時，沒有任何音符在可擊中範圍內，則判定為 MISS
                        judgeHit(trackIndex, 'miss');

                        // ▼▼▼ 修訂的關鍵之處 ▼▼▼
                        // 並且，如果軌道上確實有一個最近的音符（只是太遠了），
                        // 則將該音符移除，以懲罰提早按鍵的行為。
                        if (hitNote) {
                            hitNote.active = false;
                            hitNote.element.remove();
                            notes.splice(hitIndex, 1);
                        }
                        // ▲▲▲ 修訂結束 ▲▲▲
                    }
                }
            }

         function handleKeyUp(e) {
    if (!gameActive) return;
    const keyCode = e.keyCode;
    keyStates[keyCode] = false;
    const trackIndex = keyCodes.indexOf(keyCode);
    if (trackIndex !== -1) {
        const heldNoteIndex = notes.findIndex(note =>
            note.track === trackIndex && note.type === 'long' && note.hitStarted
        );
        if (heldNoteIndex !== -1) {
            const note = notes[heldNoteIndex];
            const trackRect = tracksContainer.getBoundingClientRect();
            const hitLineY = trackRect.top + trackRect.height - 100;
            const rect = note.element.getBoundingClientRect();
            const noteTailY = rect.top;
            const distance = Math.abs(noteTailY - hitLineY);
            let type = 'miss';  // 預設為 MISS
if (distance < 50) {
    if (distance < 15) type = 'perfect';
    else if (distance < 30) type = 'great';
    else type = 'good';
}

// 修訂：無論 MISS 或非 MISS，都呼叫 judgeHit，讓它處理所有效果（包括粒子/震動）
judgeHit(trackIndex, type);
if (type !== 'miss') {
    explodeNote(note.element, type); // 新增：長音符釋放成功時分解粒子
}

note.active = false;
note.element.remove();
notes.splice(heldNoteIndex, 1);
        }
    }
}
            function onTouchStart(e) {
                e.preventDefault();
                const keyElement = e.target.closest('.touch-key');
                if (keyElement) {
                    keyElement.classList.add('pressed');
                    handleKeyDown({ keyCode: parseInt(keyElement.dataset.key) });
                }
            }

            function onTouchEnd(e) {
                e.preventDefault();
                const changedTouches = e.changedTouches || [e];
                for (const touch of changedTouches) {
                    const originalKeyElement = e.target.closest('.touch-key');
                    if (originalKeyElement) {
                        originalKeyElement.classList.remove('pressed');
                        handleKeyUp({ keyCode: parseInt(originalKeyElement.dataset.key) });
                    }
                }
            }


// 尋找下一首啟用的歌曲
function findNextEnabledSong(currentIndex) {
    for (let i = currentIndex + 1; i < playlistItems.length; i++) {
        const playlistItem = playlist.children[i];
        if (playlistItem && playlistItem.dataset.enabled === 'true') {
            return i;
        }
    }
    return -1; // 沒有找到下一首啟用的歌曲
}

// 尋找上一首啟用的歌曲
function findPrevEnabledSong(currentIndex) {
    for (let i = currentIndex - 1; i >= 0; i--) {
        const playlistItem = playlist.children[i];
        if (playlistItem && playlistItem.dataset.enabled === 'true') {
            return i;
        }
    }
    return -1; // 沒有找到上一首啟用的歌曲
}


            // --- Music Player Logic ---
            function initMusicPlayer() {

  // ▼▼▼ 在函數開頭加入這行 ▼▼▼
    updatePlaybackModeButtonUI(); 
    // ▲▲▲ 新增結束 ▲▲▲
                
                // Filter playlist items to only include unlocked songs
                const unlockedSongsSet = new Set(saveData.unlockedSongs);
                playlistItems = Array.from(musicSelect.options)
                    .filter(opt => unlockedSongsSet.has(opt.value)) // Only unlocked songs
                    .map((opt, index) => ({
                        url: opt.value,
                        title: opt.textContent.replace(' (未解鎖)', ''),
                        index: index
                    }));

                playlist.innerHTML = '';
playlistItems.forEach(item => {
    const li = document.createElement('li');
    li.className = 'playlist-item';
    li.textContent = item.title;
    li.dataset.index = item.index;
    
    // 從儲存的設定中恢復歌曲狀態
    const savedState = playerSettings.playlistStates[item.url];
    const isEnabled = savedState ? savedState.enabled : true;
    li.dataset.enabled = isEnabled ? 'true' : 'false';
    
    if (!isEnabled) {
        li.classList.add('disabled');
    }
    
    let clickCount = 0;
    let clickTimer = null;
    
    li.addEventListener('click', () => {
        clickCount++;
        
        if (clickTimer) {
            clearTimeout(clickTimer);
        }
        
       clickTimer = setTimeout(() => {
    if (clickCount === 1) {
        // 單擊：播放該歌曲或啟用該歌曲
        li.dataset.enabled = 'true';
        li.classList.remove('disabled');
        playSong(item.index);
        savePlayerSettings(); // 保存設定
    } else if (clickCount === 2) {
        // 雙擊：停用該歌曲，不播放
        li.dataset.enabled = 'false';
        li.classList.add('disabled');
        savePlayerSettings(); // 保存設定
                
                // 如果當前正在播放這首歌，則暫停並尋找下一首啟用的歌曲
                if (currentPlaylistIndex === item.index && playerIsPlaying) {
                    const nextIndex = findNextEnabledSong(currentPlaylistIndex);
                    if (nextIndex !== -1) {
                        playSong(nextIndex);
                    } else {
                        playerAudio.pause();
                    }
                }
            }
            clickCount = 0;
        }, 300); // 300毫秒內的點擊視為雙擊
    });
    
    playlist.appendChild(li);
});

                playerAudio.addEventListener('loadedmetadata', () => {
                    durationDisplay.textContent = formatTime(playerAudio.duration);
                    progressSlider.max = playerAudio.duration;
                });

               playerAudio.addEventListener('timeupdate', () => {
    if (!isUpdatingSlider) {
        currentTimeDisplay.textContent = formatTime(playerAudio.currentTime);
        progressSlider.value = playerAudio.currentTime;
        updateLyrics(playerAudio.currentTime);
        
        // 每5秒自動保存播放進度
        if (Math.floor(playerAudio.currentTime) % 5 === 0) {
            savePlayerSettings();
        }
    }
});

// 【修訂後】的 pause 事件監聽
playerAudio.addEventListener('pause', () => {
    updatePlayingVisuals(false); // 統一更新為暫停視覺
    savePlayerSettings(); // 保存暫停狀態
});

playerAudio.addEventListener('pause', () => {
    playerIsPlaying = false;
    playPauseBtn.textContent = '\u25B6';
    updatePlayerUI();
    savePlayerSettings(); // 保存暫停狀態
});
             // 【修訂後】的音樂播放結束事件
// 【全新修訂版】音樂播放結束事件
playerAudio.addEventListener('ended', () => {
    updatePlayingVisuals(false); // 更新視覺為停止狀態

    // 規則1：單曲循環的優先級最高
    if (loopMode === 'single') {
        playerAudio.currentTime = 0;
        playerAudio.play();
        return; // 結束後續判斷
    }

    // 規則2：判斷是隨機模式還是循序模式
    if (playbackMode === 'shuffle') {
        // --- 隨機播放邏輯 ---
        const enabledSongs = playlistItems
            .map((item, index) => ({ ...item, originalIndex: index }))
            .filter(item => {
                const li = playlist.children[item.originalIndex];
                return li && li.dataset.enabled === 'true';
            });

        if (enabledSongs.length > 1) {
            let nextSong;
            // 確保下一首隨機歌曲不是當前這首
            do {
                const randomIndex = Math.floor(Math.random() * enabledSongs.length);
                nextSong = enabledSongs[randomIndex];
            } while (nextSong.index === currentPlaylistIndex);
            playSong(nextSong.index);
        } else if (enabledSongs.length === 1) {
            playSong(enabledSongs[0].index); // 如果只有一首歌啟用，就播那一首
        }

    } else {
        // --- 循序播放邏輯 (預設) ---
        let nextIndex = findNextEnabledSong(currentPlaylistIndex);

        // 如果列表循環開啟且已到結尾，則從頭開始
        if (nextIndex === -1 && loopMode === 'list') {
            nextIndex = findNextEnabledSong(-1); // 從頭尋找第一首啟用的歌曲
        }

        if (nextIndex !== -1) {
            playSong(nextIndex);
        }
    }
});

               // 【修訂後】的 play 事件監聽，主要用於同步狀態
playerAudio.addEventListener('play', () => {
    playerIsPlaying = true; // 確保狀態同步
    // 保留 savePlayerSettings 以便在意外情況下也能保存狀態
    savePlayerSettings(); 
});

                playerAudio.addEventListener('pause', () => {
                    playerIsPlaying = false;
                    playPauseBtn.textContent = '\u25B6'; // Play icon
                    updatePlayerUI();
// 新增：停止 CD 旋轉
    document.getElementById('cdCoverImage').classList.remove('playing');
                });
            }

            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
            }

// 【新增】一個統一的、只負責更新畫面的主函數
function setupSongUI(index) {
    if (index < 0 || index >= playlistItems.length) return;

    const song = playlistItems[index];
    currentPlaylistIndex = index; // 更新當前索引

    // 更新"正在播放"的文字
    nowPlaying.textContent = `正在播放: ${song.title}`;
    
    // 更新封面和歌詞 (這是準備工作)
    updateCdCover(song.url);
    lyrics = songData[song.url]?.lyrics || [];
    updateLyricsContainer();
    
    // 更新播放列表的高亮狀態
    updatePlayerUI();
    
    // 將音訊來源準備好，但先不播放
    playerAudio.src = song.url;
    playerAudio.volume = volumeSliderPlayer.value;
}

            
// 【最終修訂版】playSong 函數
function playSong(index) {
    // 呼叫主函數，完成所有畫面的設定
    setupSongUI(index);
    
    // 如果畫面設定成功 (音訊來源已準備好)，就播放
    if (playerAudio.src) {
        playerAudio.play().catch(e => console.error("播放器播放失敗:", e));
        
        // 【核心修正】在下達播放指令後，立即手動更新視覺為「播放中」
        updatePlayingVisuals(true); 
        
        savePlayerSettings();
    }
}
            
// 在現有函數之前新增這兩個輔助函數
function findNextEnabledSong(currentIndex) {
    for (let i = currentIndex + 1; i < playlistItems.length; i++) {
        const playlistItem = playlist.children[i];
        if (playlistItem && playlistItem.dataset.enabled === 'true') {
            return i;
        }
    }
    return -1; // 沒有找到下一首啟用的歌曲
}

function findPrevEnabledSong(currentIndex) {
    for (let i = currentIndex - 1; i >= 0; i--) {
        const playlistItem = playlist.children[i];
        if (playlistItem && playlistItem.dataset.enabled === 'true') {
            return i;
        }
    }
    return -1; // 沒有找到上一首啟用的歌曲
}

            function updateLyricsContainer() {
                lyricsContainer.innerHTML = '';
                if (lyrics.length === 0) {
                    lyricsContainer.innerHTML = '<div class="no-lyrics">無歌詞</div>';
                    return;
                }
                lyrics.forEach((line, i) => {
                    const p = document.createElement('p');
                    p.className = 'lyric-line';
                    p.textContent = line.text;
                    p.dataset.time = line.time;
                    lyricsContainer.appendChild(p);
                });
            }

            function updateLyrics(currentTime) {
                if (lyrics.length === 0) return;
                let activeIndex = -1;
                for (let i = 0; i < lyrics.length; i++) {
                    if (lyrics[i].time <= currentTime) {
                        activeIndex = i;
                    } else {
                        break;
                    }
                }
                document.querySelectorAll('.lyric-line').forEach((line, i) => {
                    line.classList.toggle('active', i === activeIndex);
                    if (i === activeIndex) {
                        line.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                });
            }



// 更新 CD 封面的函數
function updateCdCover(songUrl) {
    const coverImage = document.getElementById('cdCoverImage');
    // 根據歌曲 URL 獲取對應的封面，如果沒有則使用默認封面
    const coverUrl = songCovers[songUrl] || songCovers["default"];
    coverImage.src = coverUrl;
    // 可選：添加加載錯誤的回退
    coverImage.onerror = function() {
        this.src = songCovers["default"];
    };
}


            function updatePlayerUI() {
    document.querySelectorAll('.playlist-item').forEach((item, i) => {
        item.classList.toggle('active', i === currentPlaylistIndex);
    });
    
    // 檢查是否有上一首/下一首啟用的歌曲來決定按鈕狀態
    const hasPrev = findPrevEnabledSong(currentPlaylistIndex) !== -1;
    const hasNext = findNextEnabledSong(currentPlaylistIndex) !== -1;
    
    prevBtn.disabled = !hasPrev;
    nextBtn.disabled = !hasNext;
}

           // 一個統一的函數，根據播放狀態更新所有視覺效果
function updatePlayingVisuals(isPlaying) {
    const cdCover = document.getElementById('cdCoverImage');
    if (isPlaying) {
        // 更新為「播放中」的視覺效果
        playerIsPlaying = true;
        playPauseBtn.innerHTML = '&#10074;&#10074;'; // 暫停符號
        cdCover.classList.add('playing');
    } else {
        // 更新為「暫停/停止」的視覺效果
        playerIsPlaying = false;
        playPauseBtn.innerHTML = '&#9658;'; // 播放符號
        cdCover.classList.remove('playing');
    }
}

//【新增】初始化循環按鈕的圖示
           function initializeLoopButton() {
    // 因為預設是列表循環，所以初始圖示也要對應
    loopBtn.innerHTML = loopIconList; 
    loopBtn.title = '列表循環';
}

            

            // --- Event Listeners ---
            touchKeys.forEach(key => {
                key.addEventListener('touchstart', onTouchStart, { passive: false });
                key.addEventListener('touchend', onTouchEnd, { passive: false });
                key.addEventListener('touchcancel', onTouchEnd, { passive: false });
            });

            settingsBtn.addEventListener('click', () => settingsModal.classList.add('active'));
            closeSettings.addEventListener('click', () => settingsModal.classList.remove('active'));
            window.addEventListener('click', (e) => {
                if (e.target === settingsModal) settingsModal.classList.remove('active');
                if (e.target === personalHighScoreModal) personalHighScoreModal.classList.remove('active');
                if (e.target === unlockModal) unlockModal.classList.remove('active');
            });

         // 【修訂】為音樂音量滑桿添加事件監聽，並即時更新CSS變數
            volumeControlModal.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                audio.volume = isNaN(value) ? 1.0 : value; // 將後備值從 0.7 改為 1.0
                // 更新CSS變數來控制背景填充
                const percent = value * 100;
                e.target.style.background = `linear-gradient(to right, #3b82f6 ${percent}%, #4a5568 ${percent}%)`;
            });

            // 【修訂】為音效音量滑桿添加事件監聽，並即時更新CSS變數
            sfxVolumeControl.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                sfxVolume = isNaN(value) ? 0.5 : value;
                // 更新CSS變數來控制背景填充
                const percent = value * 100;
                e.target.style.background = `linear-gradient(to right, #3b82f6 ${percent}%, #4a5568 ${percent}%)`;
            });
            
            startBtn.addEventListener('click', handleStartButtonClick);
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            restartBtn.addEventListener('click', restartGame);
            // --- Handle Page Visibility to Prevent Ghost Notes ---
            document.addEventListener('visibilitychange', () => {
                // 我們只關心頁面從「隱藏」變為「可見」的那個瞬間
                // 並且只有在遊戲正在進行中才需要處理
                if (!document.hidden && gameActive) {
                    const now = Date.now();
                    
                    // 遍歷所有當前在畫面上的音符
                    // 我們從後往前遍歷，這樣在刪除陣列元素時才不會出錯
                    for (let i = notes.length - 1; i >= 0; i--) {
                        const note = notes[i];
                        const timeAlive = now - note.creationTime;

                        // 【核心清理邏輯】
                        // 如果一個音符的存活時間，已經超過了它跑完整個軌道所需的時間 (noteSpeed)
                        // 再加上一個小的緩衝時間（例如 500 毫秒），
                        // 我們就認定它是一個在頁面隱藏期間就應該消失的「幽靈音符」。
                        if (timeAlive > noteSpeed + 500) {
                            note.active = false;      // 標記為非作用中
                            note.element.remove();    // 從畫面中移除 DOM 元素
                            notes.splice(i, 1);       // 從我們的遊戲邏輯陣列中移除
                        }
                    }
                }
            });

            // New Event Listeners
            personalHighScoreBtn.addEventListener('click', () => {
                const selectedSong = musicSelect.value;
                populatePersonalHighScoreList(selectedSong);
                personalHighScoreModal.classList.add('active');
            });
            closePersonalHighScore.addEventListener('click', () => personalHighScoreModal.classList.remove('active'));

           musicPlayerBtn.addEventListener('click', () => {
    musicPlayerModal.classList.add('active');
    initMusicPlayer(); // Re-initialize playlist on open to reflect unlocks
    loadPlayerSettings(); // 載入儲存的設定
    
    // 恢復上次的播放狀態
    if (playerSettings.currentSong && playlistItems.length > 0) {
        const songIndex = playlistItems.findIndex(item => item.url === playerSettings.currentSong);
        if (songIndex !== -1) {
            currentPlaylistIndex = songIndex;
            playerAudio.src = playerSettings.currentSong;
            playerAudio.currentTime = playerSettings.currentTime || 0;
            nowPlaying.textContent = `正在播放: ${playlistItems[songIndex].title}`;
            
            // 恢復歌詞和UI
            const song = playlistItems[songIndex];
            lyrics = songLyrics[song.url] || [];
            updateLyricsContainer();
            updatePlayerUI();
            
            // 如果之前是播放狀態，則自動繼續播放
            if (playerSettings.isPlaying) {
                playerAudio.play().catch(e => console.error("自動播放失敗:", e));
            }
        }
    }
});
           closeMusicPlayer.addEventListener('click', () => {
    savePlayerSettings(); // 保存當前狀態再關閉
    musicPlayerModal.classList.remove('active');
    playerAudio.pause();
});
// 【最終修訂版】的播放/暫停按鈕事件
playPauseBtn.addEventListener('click', () => {
    // 檢查是否已有準備好的歌曲
    if (playerAudio.src && !playerAudio.src.endsWith('/')) { 
        if (playerIsPlaying) {
            // 如果正在播放，就暫停
            playerAudio.pause();
        } else {
            // 如果是暫停狀態，就播放
            playerAudio.play();
            // 【核心修正】在下達播放指令後，立即手動更新視覺為「播放中」
            updatePlayingVisuals(true); 
        }
    } else {
        // 如果播放器是空的，呼叫 playSong 來完整地設定畫面並播放
        const firstEnabledIndex = findNextEnabledSong(-1);
        if (firstEnabledIndex !== -1) {
            playSong(firstEnabledIndex);
        }
    }
});
//【新增】循環按鈕的點擊事件
            loopBtn.addEventListener('click', () => {
    if (loopMode === 'list') {
        loopMode = 'single'; // 從 列表 切換到 單曲
        loopBtn.innerHTML = loopIconSingle;
        loopBtn.title = '單曲循環';
    } else if (loopMode === 'single') {
        loopMode = 'none';   // 從 單曲 切換到 關閉
        loopBtn.innerHTML = loopIconNone;
        loopBtn.title = '關閉循環';
    } else { // loopMode === 'none'
        loopMode = 'list';   // 從 關閉 切換回 列表
        loopBtn.innerHTML = loopIconList;
        loopBtn.title = '列表循環';
    }
});

            
          prevBtn.addEventListener('click', () => {
    const prevIndex = findPrevEnabledSong(currentPlaylistIndex);
    if (prevIndex !== -1) {
        playSong(prevIndex);
    }
});

nextBtn.addEventListener('click', () => {
    const nextIndex = findNextEnabledSong(currentPlaylistIndex);
    if (nextIndex !== -1) {
        playSong(nextIndex);
    }
});

            progressSlider.addEventListener('input', () => {
                isUpdatingSlider = true;
                playerAudio.currentTime = progressSlider.value;
                currentTimeDisplay.textContent = formatTime(progressSlider.value);
            });
            progressSlider.addEventListener('change', () => {
                 isUpdatingSlider = false;
            });

            // Fixed volume slider input listeners for player to use 'change' event for full range
            volumeSliderPlayer.addEventListener('change', () => {
    const value = parseFloat(volumeSliderPlayer.value);
    playerAudio.volume = isNaN(value) ? 0.7 : value;
    savePlayerSettings(); // 保存音量設定
});

            musicSelect.addEventListener('change', () => {
                const selectedSong = musicSelect.value;
                updateDifficultyOptions(selectedSong);
                populatePersonalHighScoreList(selectedSong); // Update personal score list on song change
            });

            difficultySelect.addEventListener('change', () => {
                // Optional: Add logic if difficulty change needs immediate UI update
            });

            closeUnlock.addEventListener('click', () => unlockModal.classList.remove('active'));

             // --- 【新增】排行榜 Modal 的事件監聽器 ---
            leaderboardBtn.addEventListener('click', () => {
                leaderboardModal.classList.add('active');
                handlePlayerName(); // 處理玩家名稱
                // 預設顯示當前主介面選擇的歌曲和難度
                displayLeaderboard(musicSelect.value, difficultySelect.value);
            });

            closeLeaderboard.addEventListener('click', () => {
                leaderboardModal.classList.remove('active');
            });

            // 當主介面的歌曲或難度改變時，如果排行榜是開啟的，就同步更新
            musicSelect.addEventListener('change', () => {
                if (leaderboardModal.classList.contains('active')) {
                    displayLeaderboard(musicSelect.value, difficultySelect.value);
                }
                // 這一段會與上面的 musicSelect.addEventListener 重複，但影響不大，因為它們的功能不衝突
                // 為了程式碼簡潔，你可以考慮將兩個 change 事件的邏輯合併，但分開寫也完全可以運作
            });


            

            difficultySelect.addEventListener('change', () => {
                if (leaderboardModal.classList.contains('active')) {
                    displayLeaderboard(musicSelect.value, difficultySelect.value);
                }
            });

            // ▼▼▼ 請將您的新程式碼貼在這裡 ▼▼▼

// 【新增】為對戰排行榜按鈕綁定事件
showBattleRankingsBtn.addEventListener('click', () => {
    battleRankingsModal.classList.add('active');
    displayBattleRankings();
});

closeBattleRankingsModal.addEventListener('click', () => {
    battleRankingsModal.classList.remove('active');
});

// ▲▲▲ 新增結束 ▲▲▲


            // --- Initialization ---
            const originalStartButtonSVG = startBtn.innerHTML;
            updateSongOptions(); // Apply unlock status on load
            populatePersonalHighScoreList(musicSelect.value); // Show scores for initially selected song
            initGame();
             initializeLoopButton(); //【新增】在這裡呼叫初始化函數

             // ▼▼▼ 【請在這裡加入此行】 ▼▼▼
            checkAndApplyAdminUnlocks();
            // ▲▲▲ 【加入結束】 ▲▲▲


            

          // ====================================================================
// ====== 【全新修訂】統一的測驗答案提交邏輯 ======
// ====================================================================

/**
 * 總管函數：根據測驗模式決定執行哪個答案處理邏輯
 */
function handleQuizSubmit() {
    // 檢查是否處於對戰測驗模式
    if (isBattleQuizActive) {
        handleBattleQuizAnswer(); // 呼叫對戰模式的答案處理函數
    } else {
        checkQuizAnswer(); // 否則，呼叫單人模式的答案處理函數
    }
}

// 綁定事件到新的總管函數
quizSubmitBtn.addEventListener('click', handleQuizSubmit);

quizAnswerInput.addEventListener('keydown', (e) => {
    // 當按下 Enter 鍵時，也觸發同一個總管函數
    if (e.key === 'Enter') {
        e.preventDefault(); 
        handleQuizSubmit();
    }
});
quizCloseBtn.addEventListener('click', () => {
    if (isQuizActive) {
        endQuiz(false); // 玩家手動關閉視窗，視為測驗失敗
    }
});


// 為版權聲明按鈕添加事件監聽器
const showDisclaimerBtn = document.getElementById('showDisclaimerBtn');
const disclaimerModal = document.getElementById('disclaimerModal');
const closeDisclaimer = document.getElementById('closeDisclaimer');

showDisclaimerBtn.addEventListener('click', () => {
    disclaimerModal.classList.add('active');
});

closeDisclaimer.addEventListener('click', () => {
    disclaimerModal.classList.remove('active');
});

// 點擊模態框外部關閉
disclaimerModal.addEventListener('click', (e) => {
    if (e.target === disclaimerModal) {
        disclaimerModal.classList.remove('active');
    }
});

// ==========================================================
// ====== 【新增】線上對戰相關的事件監聽器 ======
// ==========================================================

onlineMatchBtn.addEventListener('click', () => {
    if (!playerName) {
        // 未设置名称：弹出通知并强制打开排行榜Modal设置
      
        leaderboardModal.classList.add('active');
        handlePlayerName(); // 强制处理名称设置
        return; // 阻止继续打开对战Modal
    }
    
    // 已设置名称：正常打开对战Modal
    onlineMatchModal.classList.add('active');
    matchStatusText.textContent = ''; // 清空状态文字
    roomIdInput.value = ''; // 清空输入框
});

closeOnlineMatchModal.addEventListener('click', () => {
    onlineMatchModal.classList.remove('active');
    // 如果正在等待配對，取消等待
    database.ref('waitingQueue').transaction(currentQueue => {
        if (currentQueue && currentQueue.hostId === playerId) {
            return {};
        }
        return;
    });
    if(currentRoomId && currentRoomId.startsWith('queue_')) {
        database.ref('rooms/' + currentRoomId).remove();
    }
    resetToMainMenu();
});

createRoomBtn.addEventListener('click', createRoom);
joinRoomBtn.addEventListener('click', joinRoom);
randomMatchBtn.addEventListener('click', randomMatch);

// 重賽按鈕
rematchBtn.addEventListener('click', () => {
    const playerKey = isHost ? 'player1' : 'player2';
    database.ref(`rooms/${currentRoomId}/${playerKey}/rematch`).set(true);
    rematchBtn.disabled = true;
});

// 結束遊戲按鈕
endGameBtn.addEventListener('click', () => {
    const myPlayerKey = isHost ? 'player1' : 'player2';
    const myEndedKey = isHost ? 'player1Ended' : 'player2Ended';

    // 设置自己的ended = true
    database.ref(`rooms/${currentRoomId}/${myEndedKey}`).set(true);

    // 本地立即重置到主菜单（不等待对方）
    resetToMainMenu();

    // 检查如果双方都ended，且我是主机，则移除房间
    database.ref(`rooms/${currentRoomId}`).once('value').then(snapshot => {
        const roomData = snapshot.val();
        if (roomData && roomData.player1Ended && roomData.player2Ended && isHost) {
            database.ref('rooms/' + currentRoomId).remove();
        }
    });
});

// 監聽房間號輸入，自動格式化
roomIdInput.addEventListener('input', (e) => {
    e.target.value = e.target.value.replace(/[^0-9]/g, '');
});

// ==========================================================
// ====== 【新增結束】 ========================================
// ==========================================================
            
});
    </script>

    <footer class="copyright-footer">
<p>Copyright © 2025 陳冠健. All rights reserved.</p>
</footer>


<!-- Copyright Disclaimer Modal -->
<div class="copyright-disclaimer-modal" id="disclaimerModal">
    <div class="disclaimer-content">
        <button class="close-disclaimer" id="closeDisclaimer">&times;</button>
        <h2 class="disclaimer-title">音樂版權聲明</h2>
        <div class="disclaimer-section">
            <h3>音樂來源</h3>
            <p>本專案中使用的音樂由 AI 工具（豆包）生成。</p>
        </div>
        <div class="disclaimer-section">
            <h3>使用限制</h3>
            <p>本音樂僅用於語文教育用途，禁止任何用戶下載後用於商業等其他場景。</p>
        </div>
        <div class="disclaimer-section">
            <h3>免責聲明</h3>
            <p>若音樂違反任何版權，本人將立即刪除有關作品。</p>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【修正】歌詞填充測驗視窗 (已加入 ID) ▼▼▼ -->
<div class="lyrics-quiz-modal" id="lyricsQuizModal">
    <div class="quiz-content">
        <!-- 【修訂】在這兩行加入了 id 屬性 -->
        <h2 class="quiz-title" id="quizTitle">歌詞填充測驗</h2>
        <p class="quiz-instructions" id="quizInstructions">連續答對五題即可解鎖新內容或登入排行榜！</p>
        
        <div class="quiz-progress" id="quizProgress">連續答對: 0 / 5</div>
        <!-- 新增得分顯示（放在進度後） -->
<div id="quizScoreDisplay" style="font-size: 1.2rem; color: #17a2b8; margin-bottom: 20px;">當前得分: 0</div>
        
        <!-- 【新增】對戰測驗專用計時器 -->
        <div id="battleQuizTimerContainer" style="display: none; width: 100%; height: 8px; background-color: #e9ecef; border-radius: 4px; margin-bottom: 20px; overflow: hidden;">
            <div id="battleQuizTimerBar" style="width: 100%; height: 100%; background-color: #17a2b8; transition: width 0.1s linear;"></div>
        </div>
        
        <div class="quiz-question-container">
            <p id="quizQuestionText"></p>
        </div>
        <input type="text" id="quizAnswerInput" class="quiz-answer-input" placeholder="請在此輸入答案..." autocomplete="off">
        <button id="quizSubmitBtn" class="quiz-submit-btn">提交答案</button>
        <button id="quizCloseBtn" class="quiz-close-btn">&times;</button>
    </div>
</div>
<!-- ▲▲▲ 修正結束 ▲▲▲ -->

    <!-- ====== 【新增】排行榜 Modal ====== -->
<div class="settings-modal" id="leaderboardModal">
    <div class="settings-content">
        <button class="close-settings" id="closeLeaderboard">&times;</button>
        <h2 class="settings-title">歌曲排行榜</h2>
        
        <!-- 玩家名稱設定 -->
        <div class="setting-group" id="playerNameGroup">
            <label class="setting-label" for="playerNameInput">你的顯示名稱:</label>
            <input type="text" id="playerNameInput" class="setting-control" placeholder="輸入你的名稱" maxlength="20">
            <button id="savePlayerNameBtn" class="restart-btn"></button>
        </div>

        <!-- 排行榜顯示區域 -->
        <div class="leaderboard-display">
            <h3 id="leaderboardTitle" class="personal-high-score-title" style="margin-top: 20px;">請選擇歌曲與難度</h3>
            <ol class="personal-high-score-list" id="leaderboardList">
                <!-- 排行榜資料會由 JS 動態填入 -->
            </ol>
            <p id="leaderboardLoading" style="display: none;">讀取中...</p>
        </div>
    </div>
</div>

    <!-- ▼▼▼ 【新增】線上對戰彈出視窗 ▼▼▼ -->
<div class="settings-modal" id="onlineMatchModal">
    <div class="settings-content">
        <button class="close-settings" id="closeOnlineMatchModal">&times;</button>
        <h2 class="settings-title">線上對戰模式</h2>

        <div class="setting-group" style="text-align: center;">
            <p id="matchStatusText" style="color: #00c9ff; min-height: 24px;"></p>
        </div>
        
        <div class="setting-group">
            <input type="text" id="roomIdInput" class="setting-control" placeholder="輸入四位房間號碼" maxlength="4" style="text-align: center; font-size: 1rem; letter-spacing: 0.1em;">
        </div>

        <div class="setting-group" style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
            <button class="restart-btn" id="createRoomBtn">➕創建房間</button>
            <button class="restart-btn" id="joinRoomBtn">✔️加入房間</button>
        </div>
        <div class="setting-group">
            <button class="restart-btn" id="randomMatchBtn" style="width: 100%; background: linear-gradient(45deg, #ff8a00, #e52e71);">🐦隨機配對</button>
        </div>
        <!-- ▼▼▼ 請將這段新的按鈕程式碼，加在「隨機配對」按鈕的下方 ▼▼▼ -->
<div class="setting-group">
    <button class="restart-btn" id="showBattleRankingsBtn" style="width: 100%;">
        🏇🏻對戰排行榜
    </button>
</div>
    </div>
</div>
<!-- ▲▲▲ 新增結束 ▲▲▲ -->

    <!-- ▼▼▼ 【全新】對戰模式排行榜 Modal ▼▼▼ -->
<div class="settings-modal" id="battleRankingsModal">
    <div class="settings-content">
        <button class="close-settings" id="closeBattleRankingsModal">&times;</button>
        <h2 class="settings-title">對戰排行榜</h2>
        
        <div class="leaderboard-display">
            <p style="text-align: center; color: #aaa; margin-bottom: 20px;">根據勝負積分，顯示總分最高的前十名玩家。</p>

 <!-- ▼▼▼ 請將這段新的 HTML 程式碼加在這裡 ▼▼▼ -->
    <div id="myBattleRankDisplay" class="my-rank-display" style="display: none;">
        <!-- 內容將由 JavaScript 動態填入 -->
    </div>
    <!-- ▲▲▲ 新增結束 ▲▲▲ -->
            
            <ol class="personal-high-score-list" id="battleRankingsList">
                <!-- 排行榜資料會由 JS 動態填入 -->
            </ol>
            <p id="battleRankingsLoading" style="display: none;">讀取中...</p>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增結束 ▲▲▲ -->

</body>
</html>
